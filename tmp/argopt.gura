#!/usr/bin/env gura

Entry = struct(type:symbol, longName:string, shortName:string:nil)

Parser = class {
	__init__() = {
		self.entries = []
	}
	parse(argv[]:string) = {
		cfg = %{}
		cfg[self.entries.filter(self.entries:*type == `boolean):*longName] = false
		argvRest = []
		i = argv.offset(1)
		while (arg = i.next()) {
			//println('* ', arg)
			[entry, value] = [nil, nil]
			if (arg.startswith('--')) {
				if (arg.len() == 2) {
					argvRest.add(arg)
					continue
				}
				fields = arg.mid(2).split('='):list
				if (fields.len() == 1) {
					longName = fields[0]
				} else {
					[longName, value] = fields
				}
				entry = self.entries.seek(self.entries:*longName == longName)
				!entry && raise(KeyError, 'unknown option --' + longName)
			} elsif (arg.startswith('-')) {
				if (arg.len() == 1) {
					argvRest.add(arg)
					continue
				}
				shortName = arg.mid(1, 1)
				if (arg.len() > 2) {
					value = arg.mid(2)
				}
				entry = self.entries.seek(self.entries:*shortName == shortName)
				!entry && raise(KeyError, 'unknown option -' + shortName)
				if (entry.type != `boolean && !value) {
					value = i.next()
				}
			} else {
				argvRest.add(arg)
				continue
			}
			if (entry.type == `boolean) {
				cfg[entry.longName] = true
			} elsif (value) {
				cfg[entry.longName] = value
			} else {
				raise(KeyError, 'value is necessary')
			}
		}
		[cfg, argvRest]
	}
	add(type:symbol, longName:string, shortName?:string) = {
		if (!(type in [`boolean, `string])) {
			raise(ValueError, 'invalid type ' + type)
		}
		self.entries.add(Entry(type, longName, shortName))
	}
}

if (__name__ == '__main__') {
	Parser {|p|
		p.add(`string, 'text')
		p.add(`boolean, 'test')
		p.add(`boolean, 'bold', 'b')
		[cfg, argv] = p.parse(sys.argv)
	}
	println(cfg)
}
