<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Gura Programming Language</title>
    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/vnd.microsoft.icon" />
    <link rel="icon" href="/images/favicon.ico" type="image/vnd.microsoft.icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="/"><img src="/images/banner-medium.png" alt="Gura Programming Language/" /></a>
        <p></p>
        <p>
        <a href="../en/MemberMapping.html" class="radio-on">English</a> |
        <a href="../ja/MemberMapping.html" class="radio-off">Japanese</a>
        </p>
        <p class="view"><a href="/">Top Page</a></p>
        <p class="view"><a href="/en/Download.html">Download</a></p>
        <p class="view"><a href="/en/Install.html">Install</a></p>
        <p class="view"><a href="/en/Gallery.html">Gallery</a></p>
        <!--
        <ul>
          <li><a href="https://github.com/jxg/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/jxg/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/jxg">View On <strong>GitHub</strong></a></li>
        </ul>
        -->
      </header>
      <section>
<!-- ====================================================================== -->

<h2>Member-mapping</h2>

<p>
You might have faced cases that you have multiple instances of the same class
and you want to execute a same method on them or refer to member variables in them.
You can use Member-mapping for such a case.
</p>

<p>
To see how Member-mapping works, we prepare a simple structure Fruit.
</p>

<pre><code>Fruit = struct(name:string, price:number) {
    Print() = printf('name:%s  price:%d\n', self.name, self.price)
}
</code></pre>

<p>
Function struct returns a constructor function of a structure
that has both of member variables specified by arguments and
member functions declared in the block expression.
</p>

<p>
When you call this constructor function like follows it would create
a instance of the structure.
</p>

<pre><code>fruit = Fruit('apple', 100)
</code></pre>

<p>
The following code shows an example of how to access members in an instance.
</p>

<pre><code>printf('%s costs %d\n', fruit.name, fruit.price)
fruit.Print()
</code></pre>

<p>
Now, let's create a list of instances of Fruit structure.
</p>

<pre><code>fruits = [
    Fruit('apple', 100), Fruit('orange', 80), Fruit('grape', 120)
]
</code></pre>

<p>
Here's a question: How can we execute a method Print for each instance
in the list? The first idea may be to extract a instance by repeating
statement and then apply the method on each item.
This approach can be realized as follows that use Gura's function for.
</p>

<pre><code>for (fruit in fruits) {
    fruit.Print()
}
</code></pre>

<p>
Using Member-mapping, the above process can be written like follows.
</p>

<pre><code>fruits::Print()
</code></pre>

<p>
Operator :: shows an operation of Member-mapping.
In this case, it executes Print method for each item in the list fruits.
</p>

<p>
It may not enough to make you recognize an advantage of a power of Member-mapping.
Now then, the next question. Get a summation of prices of fruits.
</p>

<p>
Using repeating process, this may be described like follows.
</p>

<pre><code>priceSum = 0
for (fruit in fruits) {
    priceSum += fruit.price
}
</code></pre>

<p>
Using Member-mapping, this comes like follows.
</p>

<pre><code>fruits::price.sum()
</code></pre>

<p>
It's much simpler. After fruits::prices is evaluated, it returns a list
that contains evaluation result of price member variable in each instance.
The code above executes sum method for the list to get the summation.
</p>

<p>
The next problem may be a little bit more complicated.
How many characters are contained in the longest name among the Fruit instances?
</p>

<p>
A solution using repeating statement comes as follows.
</p>

<pre><code>lenMax = -1
for (fruit in fruits) {
    len = fruit.name.len()
    if (lenMax &gt; len) {
        lenMax = len
    }
}
</code></pre>

<p>
Using Member-mapping, it can be described like follows.
</p>

<pre><code>fruits::name::len().max()
</code></pre>

<p>
An expression fruits::name means a list of names for the instances,
and you can get a list of name length by applying len method to them.
Then, evaluating max method to the whole list shall pick up the maximum
length among them.
</p>

<p>
It would be a big advantage that you can desribe such a process in a simple expression
when you need to build up more complicated program.
Using the process above, the following example shows how to print a list
of names and prices after aligning name strings to the longest one.
</p>

<pre><code>printf('%-*s %d\n', fruits::name::len().max(), fruits::name, fruits::price)
</code></pre>

<p>
</p>
By the way, as Member-mapping operator :: creates a list at each process,
you would get a list at any time you evaluate name or len().
This increases the number of lists created during the process depending on
the number of Fruit instances, and causes a less performance
in speed and memory consumption.
</p>

<p>
To avoid the problem, there's another Member-mapping operator :*.
Using this operator, the result shall be an iterator that
delays the evaluation to the timing when the actual calculation is necessary.
The example above can be described as follows.
</p>

<pre><code>printf('%-*s %d\n', fruits:*name:*len().max(), fruits:*name, fruits:*price)
</code></pre>

<p>
Let's take a look at a little more complicated program using Member-mapping.
The following example performs some statistic calculation after reading
a CSV file that records names, ages and other fields.
Take notice that there's no repeating process any more,
which has been necessary for multiple data handling.
</p>

<pre><code>import(csv)

Person = struct(name:string, email:string, gender:string, age:number, rest*)
people = Person * csv.reader(open('50records-en.csv'))

familyNames = (people:*name:*split(' '):list)::get(0).sort()
familyNameSet = set(familyNames)

println('== occurance counting ==')
Stat = struct(name:string, occurance:number):map
stats = Stat(familyNameSet, familyNames.count(familyNameSet):map)
printf('%s(%d), ', stats:*name, stats:*occurance)
println()
stats = stats.sort(&{-($stat1.occurance &lt;=&gt; $stat2.occurance)}):stable
printf('%s(%d), ', stats:*name, stats:*occurance)
println()

println('== some statistical information ==')
genders = people::gender
printf('all=%d male=%d female=%d\n', people.len(), genders.count('male'), genders.count('female'))
ages = people::age
printf('age &lt; 30        %d\n', ages.count(&{$age &lt; 30}))
printf('30 &lt;= age &lt; 40  %d\n', ages.count(&{30 &lt;= $age && $age &lt; 40}))
printf('40 &lt;= age &lt; 50  %d\n', ages.count(&{40 &lt;= $age && $age &lt; 50}))
printf('50 &lt;= age &lt; 60  %d\n', ages.count(&{50 &lt;= $age && $age &lt; 60}))
printf('60 &lt;= age &lt; 70  %d\n', ages.count(&{60 &lt;= $age && $age &lt; 70}))
printf('70 &lt;= age       %d\n', ages.count(&{70 &lt;= $age}))
</code></pre>
<!-- ====================================================================== -->
      </section>
      <footer>
        <a href="http://sourceforge.jp/">
        <img src="http://sourceforge.jp/sflogo.php?group_id=5586&type=2" alt="SourceForge.JP" />
        </a>
        <!--
        <p>This project is maintained by <a href="https://github.com/jxg">jxg</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
        -->
      </footer>
    </div>
    <script src="/javascripts/scale.fix.js"></script>
  </body>
</html>
