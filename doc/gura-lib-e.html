<html>
<head>
<meta charset="utf-8">
<title>Gura Library Reference</title>
<link rel="stylesheet" href="styles.css">
</head>
<body class="wrapper">
<div class="title">Gura Library Reference</div>
<div class="copyright">Copyright &copy; 2011-2015 ypsitau (<a href="ypsitau@nifty.com">ypsitau@nifty.com</a>)</div>
<div class="official-site">Official Site: <a href="http://www.gura-lang.org/">http://www.gura-lang.org/</a></div>
<hr />
<h1>Table of Contents</h1>
<div><span class="toc-index-1">1</span><a href="#caption-1">About This Reference</a></div>
<div><span class="toc-index-1">2</span><a href="#caption-2">Explanatory Note</a></div>
<div><span class="toc-index-1">3</span><a href="#caption-3">Predefined Variables</a></div>
<div><span class="toc-index-1">4</span><a href="#caption-4">Built-in Functions</a></div>
<div><span class="toc-index-2">4.1</span><a href="#caption-4-1">Formatting and Printing of Text</a></div>
<div><span class="toc-index-2">4.2</span><a href="#caption-4-2">Repetition</a></div>
<div><span class="toc-index-2">4.3</span><a href="#caption-4-3">Flow Control</a></div>
<div><span class="toc-index-2">4.4</span><a href="#caption-4-4">Branch Control</a></div>
<div><span class="toc-index-2">4.5</span><a href="#caption-4-5">Handling Exception</a></div>
<div><span class="toc-index-2">4.6</span><a href="#caption-4-6">Data Transformation</a></div>
<div><span class="toc-index-2">4.7</span><a href="#caption-4-7">Class Operations</a></div>
<div><span class="toc-index-2">4.8</span><a href="#caption-4-8">Scope Operations</a></div>
<div><span class="toc-index-2">4.9</span><a href="#caption-4-9">Module Operations</a></div>
<div><span class="toc-index-2">4.10</span><a href="#caption-4-10">Value Type Information</a></div>
<div><span class="toc-index-2">4.11</span><a href="#caption-4-11">Data Processing</a></div>
<div><span class="toc-index-2">4.12</span><a href="#caption-4-12">Random</a></div>
<div><span class="toc-index-2">4.13</span><a href="#caption-4-13">Help Information</a></div>
<div><span class="toc-index-1">5</span><a href="#caption-5">Built-in Operators</a></div>
<div><span class="toc-index-1">6</span><a href="#caption-6">Built-in Classes</a></div>
<div><span class="toc-index-2">6.1</span><a href="#caption-6-1">args Class</a></div>
<div><span class="toc-index-2">6.2</span><a href="#caption-6-2">array Class</a></div>
<div><span class="toc-index-2">6.3</span><a href="#caption-6-3">audio Class</a></div>
<div><span class="toc-index-2">6.4</span><a href="#caption-6-4">binary Class</a></div>
<div><span class="toc-index-2">6.5</span><a href="#caption-6-5">codec Class</a></div>
<div><span class="toc-index-2">6.6</span><a href="#caption-6-6">color Class</a></div>
<div><span class="toc-index-2">6.7</span><a href="#caption-6-7">datetime Class</a></div>
<div><span class="toc-index-2">6.8</span><a href="#caption-6-8">declaration Class</a></div>
<div><span class="toc-index-2">6.9</span><a href="#caption-6-9">dict Class</a></div>
<div><span class="toc-index-2">6.10</span><a href="#caption-6-10">directory Class</a></div>
<div><span class="toc-index-2">6.11</span><a href="#caption-6-11">environment Class</a></div>
<div><span class="toc-index-2">6.12</span><a href="#caption-6-12">error Class</a></div>
<div><span class="toc-index-2">6.13</span><a href="#caption-6-13">expr Class</a></div>
<div><span class="toc-index-2">6.14</span><a href="#caption-6-14">formatter Class</a></div>
<div><span class="toc-index-2">6.15</span><a href="#caption-6-15">function Class</a></div>
<div><span class="toc-index-2">6.16</span><a href="#caption-6-16">help Class</a></div>
<div><span class="toc-index-2">6.17</span><a href="#caption-6-17">image Class</a></div>
<div><span class="toc-index-2">6.18</span><a href="#caption-6-18">iterator Class</a></div>
<div><span class="toc-index-2">6.19</span><a href="#caption-6-19">list Class</a></div>
<div><span class="toc-index-2">6.20</span><a href="#caption-6-20">matrix Class</a></div>
<div><span class="toc-index-2">6.21</span><a href="#caption-6-21">operator Class</a></div>
<div><span class="toc-index-2">6.22</span><a href="#caption-6-22">palette Class</a></div>
<div><span class="toc-index-2">6.23</span><a href="#caption-6-23">pointer Class</a></div>
<div><span class="toc-index-2">6.24</span><a href="#caption-6-24">semaphore Class</a></div>
<div><span class="toc-index-2">6.25</span><a href="#caption-6-25">stream Class</a></div>
<div><span class="toc-index-2">6.26</span><a href="#caption-6-26">suffixmgr Class</a></div>
<div><span class="toc-index-2">6.27</span><a href="#caption-6-27">template Class</a></div>
<div><span class="toc-index-2">6.28</span><a href="#caption-6-28">timedelta Class</a></div>
<div><span class="toc-index-2">6.29</span><a href="#caption-6-29">uri Class</a></div>
<div><span class="toc-index-1">7</span><a href="#caption-7">base64 Module</a></div>
<div><span class="toc-index-1">8</span><a href="#caption-8">bmp Module</a></div>
<div><span class="toc-index-1">9</span><a href="#caption-9">bzip2 Module</a></div>
<div><span class="toc-index-1">10</span><a href="#caption-10">cairo Module</a></div>
<div><span class="toc-index-1">11</span><a href="#caption-11">conio Module</a></div>
<div><span class="toc-index-1">12</span><a href="#caption-12">csv Module</a></div>
<div><span class="toc-index-1">13</span><a href="#caption-13">curl Module</a></div>
<div><span class="toc-index-1">14</span><a href="#caption-14">emf Module</a></div>
<div><span class="toc-index-1">15</span><a href="#caption-15">freetype Module</a></div>
<div><span class="toc-index-1">16</span><a href="#caption-16">fs Module</a></div>
<div><span class="toc-index-1">17</span><a href="#caption-17">gif Module</a></div>
<div><span class="toc-index-1">18</span><a href="#caption-18">glu Module</a></div>
<div><span class="toc-index-1">19</span><a href="#caption-19">glut Module</a></div>
<div><span class="toc-index-1">20</span><a href="#caption-20">gmp Module</a></div>
<div><span class="toc-index-1">21</span><a href="#caption-21">guri Module</a></div>
<div><span class="toc-index-1">22</span><a href="#caption-22">gzip Module</a></div>
<div><span class="toc-index-1">23</span><a href="#caption-23">hash Module</a></div>
<div><span class="toc-index-1">24</span><a href="#caption-24">http Module</a></div>
<div><span class="toc-index-1">25</span><a href="#caption-25">jpeg Module</a></div>
<div><span class="toc-index-1">26</span><a href="#caption-26">llvm Module</a></div>
<div><span class="toc-index-1">27</span><a href="#caption-27">markdown Module</a></div>
<div><span class="toc-index-1">28</span><a href="#caption-28">math Module</a></div>
<div><span class="toc-index-1">29</span><a href="#caption-29">midi Module</a></div>
<div><span class="toc-index-1">30</span><a href="#caption-30">msico Module</a></div>
<div><span class="toc-index-1">31</span><a href="#caption-31">mysql Module</a></div>
<div><span class="toc-index-1">32</span><a href="#caption-32">opengl Module</a></div>
<div><span class="toc-index-1">33</span><a href="#caption-33">os Module</a></div>
<div><span class="toc-index-1">34</span><a href="#caption-34">path Module</a></div>
<div><span class="toc-index-1">35</span><a href="#caption-35">png Module</a></div>
<div><span class="toc-index-1">36</span><a href="#caption-36">postgresql Module</a></div>
<div><span class="toc-index-1">37</span><a href="#caption-37">ppm Module</a></div>
<div><span class="toc-index-1">38</span><a href="#caption-38">re Module</a></div>
<div><span class="toc-index-1">39</span><a href="#caption-39">sdl2 Module</a></div>
<div><span class="toc-index-1">40</span><a href="#caption-40">sqlite3 Module</a></div>
<div><span class="toc-index-1">41</span><a href="#caption-41">sys Module</a></div>
<div><span class="toc-index-1">42</span><a href="#caption-42">tar Module</a></div>
<div><span class="toc-index-1">43</span><a href="#caption-43">tester Module</a></div>
<div><span class="toc-index-1">44</span><a href="#caption-44">tiff Module</a></div>
<div><span class="toc-index-1">45</span><a href="#caption-45">uuid Module</a></div>
<div><span class="toc-index-1">46</span><a href="#caption-46">wav Module</a></div>
<div><span class="toc-index-1">47</span><a href="#caption-47">wx Module</a></div>
<div><span class="toc-index-1">48</span><a href="#caption-48">xml Module</a></div>
<div><span class="toc-index-1">49</span><a href="#caption-49">xpm Module</a></div>
<div><span class="toc-index-1">50</span><a href="#caption-50">yaml Module</a></div>
<div><span class="toc-index-1">51</span><a href="#caption-51">zip Module</a></div>
<hr />
<h1><span class="caption-index-1">1</span><a name="caption-1"></a>About This Reference</h1>
<p>
This reference explains about functions and classes that are shipped with Gura interpreter. Refer to Gura Language Manual if you want information about syntax and specifications of Gura language itself.
</p>
<h1><span class="caption-index-1">2</span><a name="caption-2"></a>Explanatory Note</h1>
<p>
Functions in this reference are described in a generic expression. For example, if there is a reference described like <code>func(num:number)</code>, it means that <code>func</code> function takes one argument named <code>num</code> with value type of <code>number</code>. You can call it like <code>func(3)</code>.
</p>
<p>
If an argument is optional, the argument name is followed by a symbol <code>?</code>. For example: <code>func(num?:number)</code>. You can call it as <code>func(2)</code> or can omit the arugument like <code>func()</code>.
</p>
<p>
If the the arument name has <code>*</code> symbol followed, the arument takes zero or more values. For a function that has a generic expression <code>func(args*:number)</code>, it can be called like <code>func()</code>, <code>func(3)</code>, <code>func(3, 4)</code>, <code>func(3, 4, 2)</code>, and so on.
</p>
<p>
If the the arument name has <code>+</code> symbol followed, the arument takes one or more values. For a function that has a generic expression <code>func(args+:number)</code>, it can be called like <code>func(3)</code>, <code>func(3, 4)</code>, <code>func(3, 4, 2)</code>, and so on. In difference with <code>*</code>, it must take at least one value.
</p>
<p>
An argument may have a default value. The default value is described with <code>=&gt;</code> operator like <code>func(num:number =&gt; 4)</code>. In such a case, if <code>num</code> is omitted, the default value <code>4</code> shall be used.
</p>
<h1><span class="caption-index-1">3</span><a name="caption-3"></a>Predefined Variables</h1>
<p>
<table>

<tr>
<th>
Variable</th>
<th>
Type</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
*</code>
</td>
<td>
<code>
iterator</code>
</td>

<td>
An iterator instance equivalent with "<code>
0..</code>
".</td>
</tr>


<tr>
<td>
<code>
-</code>
</td>
<td>
<code>
nil</code>
</td>

<td>
Value of <code>
nil</code>
.</td>
</tr>


<tr>
<td>
<code>
@rem</code>
</td>
<td>
<code>
nil</code>
</td>

<td>
Value of <code>
nil</code>
.</td>
</tr>


<tr>
<td>
<code>
__name__</code>
</td>
<td>
<code>
string</code>
</td>

<td>
If the current script is a main one that the interpreter launches, this variable is set to <code>
'__main__'</code>
.
If it is imported by another as a module, this variable is set to that module name.</td>
</tr>


<tr>
<td>
<code>
false</code>
</td>
<td>
<code>
boolean</code>
</td>

<td>
Value of false.</td>
</tr>


<tr>
<td>
<code>
nil</code>
</td>
<td>
<code>
nil</code>
</td>

<td>
Value of <code>
nil</code>
.</td>
</tr>


<tr>
<td>
<code>
root</code>
</td>
<td>
<code>
environment</code>
</td>

<td>
Top level scope.</td>
</tr>


<tr>
<td>
<code>
true</code>
</td>
<td>
<code>
boolean</code>
</td>

<td>
Value of true.</td>
</tr>


</table>

</p>
<h1><span class="caption-index-1">4</span><a name="caption-4"></a>Built-in Functions</h1>
<h2><span class="caption-index-2">4.1</span><a name="caption-4-1"></a>Formatting and Printing of Text</h2>
<p>
<strong>format</strong>
</p>
<p>
<code>format(format:string, values*):map</code>
</p>
<p>
Converts <code>values</code> into string depending on formatter specifications in <code>format</code> and returns the result in string. For a detail information about formatter specications, refer to the document of <code>printf()</code> function.
</p>
<p>
<strong>print</strong>
</p>
<p>
<code>print(values*):map:void</code>
</p>
<p>
Prints out <code>values</code> to standard output.
</p>
<p>
<strong>printf</strong>
</p>
<p>
<code>printf(format:string, values*):map:void</code>
</p>
<p>
Prints out <code>values</code> to standard output depending on formatter specifications in <code>format</code>. The format specifier has a format of <code>%[flags][width][.precision]specifier</code>.
</p>
<p>
<code>specifier</code> is one of the following:
</p>
<ul>
<li><code>d</code>, <code>i</code> .. decimal integer number with a sign mark</li>
<li><code>u</code> .. decimal integer number wihout a sign mark</li>
<li><code>b</code> .. binary integer number without a sign mark</li>
<li><code>o</code> .. octal integer number without a sign mark</li>
<li><code>x</code> .. hexadecimal integer number in lower character without a sign mark</li>
<li><code>X</code> .. hexadecimal integer number in upper character without a sign mark</li>
<li><code>e</code> .. floating number in exponential form</li>
<li><code>E</code> .. floating number in exponential form (in upper character)</li>
<li><code>f</code> .. floating number in decimal form</li>
<li><code>F</code> .. floating number in decimal form (in upper character)</li>
<li><code>g</code> .. better form between <code>e</code> and <code>f</code></li>
<li><code>G</code> .. better form between <code>E</code> and <code>F</code></li>
<li><code>s</code> .. string</li>
<li><code>c</code> .. character</li>
</ul>
<p>
<code>flags</code> is one of the following.
</p>
<ul>
<li><code>+</code> .. <code>+</code> precedes for positive numbers</li>
<li><code>-</code> .. adjust a string to left</li>
<li><code>[SPC]</code> .. space character precedes for positive numbers</li>
<li><code>#</code> .. converted results of binary, octdecimal and hexadecimal are preceded by <code>'0b'</code>, <code>'0'</code> and <code>'0x'</code> respectively</li>
<li><code>0</code> .. fill lacking columns with <code>'0'</code></li>
</ul>
<p>
<code>width</code> specifies a minimum character width with a decimal number. If the length of the corresponding field is less than this number, the lacking part will be filled with space characters. If the length is equal to or more than this number, there's nothing to be processed. If an asterisk character "<code>*</code>" is specified for <code>width</code>, the minimum character width will be retrieved from the argument list.
</p>
<p>
<code>precision</code> has different effects depending on <code>specifier</code>:
</p>
<ul>
<li><p>
For specifiers that formats integer numbers .. it specifies a minimum character width and fills <code>0</code> for the lacking column. Format specifiers "<code>%03d</code>" and "<code>%.3d</code>" have the same effect. When it works in combination with <code>width</code>, <code>precision</code> fills <code>0</code> in the lacking space before <code>width</code> does padding. An example is shown below:
</p>
<pre><code>printf('%5.3d', 23) .. prints "  023"
</code></pre>
</li>
<li><p>
For <code>e</code>, <code>f</code> and <code>g</code> .. it specifies a digit number after a decimal point. Examples are shown below:
</p>
<pre><code>printf('%.3f', 1 / 3) .. prints "0.333"
printf('%.5f', 1 / 3) .. prints "0.33333"
</code></pre>
</li>
<li>For other specifiers .. it has no effect.</li>
</ul>
<p>
<strong>println</strong>
</p>
<p>
<code>println(values*):map:void</code>
</p>
<p>
Prints out <code>values</code> and a carriage return to standard output.
</p>
<h2><span class="caption-index-2">4.2</span><a name="caption-4-2"></a>Repetition</h2>
<p>
<strong>cross</strong>
</p>
<p>
<code>cross (`expr+) {block}</code>
</p>
<p>
Executes the block until it evaluates all the combinations of results from exprs "<code>var in iteratable</code>." You can specify one or more such exprs as arguments and they are counted up from the one on the right side. Iterators and lists are the most popular iteratables, but even any objects that are cable of generating iterators can be specified as such.
</p>
<p>
It returns the last evaluated value in the block as its own result, but, if one of <code>:list</code>, <code>:xlist</code>, <code>:set</code>, <code>:xset</code> or <code>:iter</code> is specified, it returns a list or evaluated value or an iterator. The rule is as follows:
</p>
<ul>
<li><code>:list</code> .. returns a list of result values</li>
<li><code>:xlist</code> .. returns a list of result values eliminating <code>nil</code></li>
<li><code>:set</code> .. returns a list of unique values of results</li>
<li><code>:xset</code> .. returns a list of unique values of results eliminating <code>nil</code></li>
<li><code>:iter</code> .. returns an iterator that executes the block</li>
<li><code>:xiter</code> .. returns an iterator that executes the block, skipping <code>nil</code></li>
</ul>
<p>
Block parameter format is <code>|idx:number, i0:number, i1:number, ..|</code> where <code>idx</code> indicates an index of the whole loop and each of <code>i0</code>, <code>i1</code> .. indicates an index of each corresponding iterable.
</p>
<p>
<strong>for</strong>
</p>
<p>
<code>for (`expr+) {block}</code>
</p>
<p>
Executes the block until any of the exprs of "<code>var in iteratable</code>" reach at their ends. You can specify one or more such exprs as arguments. Iterators and lists are the most popular iteratables, but even any objects that are cable of generating iterators can be specified as such.
</p>
<p>
It returns the last evaluated value in the block as its own result, but, if one of <code>:list</code>, <code>:xlist</code>, <code>:set</code>, <code>:xset</code> or <code>:iter</code> is specified, it returns a list or evaluated value or an iterator. The rule is as follows:
</p>
<ul>
<li><code>:list</code> .. returns a list of result values</li>
<li><code>:xlist</code> .. returns a list of result values eliminating <code>nil</code></li>
<li><code>:set</code> .. returns a list of unique values of results</li>
<li><code>:xset</code> .. returns a list of unique values of results eliminating <code>nil</code></li>
<li><code>:iter</code> .. returns an iterator that executes the block</li>
<li><code>:xiter</code> .. returns an iterator that executes the block, skipping <code>nil</code></li>
</ul>
<p>
Block parameter format is <code>|idx:number|</code> where <code>idx</code> indicates an index of the loop.
</p>
<p>
<strong>repeat</strong>
</p>
<p>
<code>repeat (n?:number) {block}</code>
</p>
<p>
Executes the block for <code>n</code> times. If <code>n</code> is omitted, it repeats the block execution forever.
</p>
<p>
It returns the last evaluated value in the block as its own result, but, if one of <code>:list</code>, <code>:xlist</code>, <code>:set</code>, <code>:xset</code> or <code>:iter</code> is specified, it returns a list or evaluated value or an iterator. The rule is as follows:
</p>
<ul>
<li><code>:list</code> .. returns a list of result values</li>
<li><code>:xlist</code> .. returns a list of result values eliminating <code>nil</code></li>
<li><code>:set</code> .. returns a list of unique values of results</li>
<li><code>:xset</code> .. returns a list of unique values of results eliminating <code>nil</code></li>
<li><code>:iter</code> .. returns an iterator that executes the block</li>
<li><code>:xiter</code> .. returns an iterator that executes the block, skipping <code>nil</code></li>
</ul>
<p>
Block parameter format is <code>|idx:number|</code> where <code>idx</code> indicates an index of the loop.
</p>
<p>
<strong>while</strong>
</p>
<p>
<code>while (`cond) {block}</code>
</p>
<p>
Executes the block while the evaluation result of <code>cond</code> is true.
</p>
<p>
It returns the last evaluated value in the block as its own result, but, if one of <code>:list</code>, <code>:xlist</code>, <code>:set</code>, <code>:xset</code> or <code>:iter</code> is specified, it returns a list or evaluated value or an iterator. The rule is as follows:
</p>
<ul>
<li><code>:list</code> .. returns a list of result values</li>
<li><code>:xlist</code> .. returns a list of result values eliminating <code>nil</code></li>
<li><code>:set</code> .. returns a list of unique values of results</li>
<li><code>:xset</code> .. returns a list of unique values of results eliminating <code>nil</code></li>
<li><code>:iter</code> .. returns an iterator that executes the block</li>
<li><code>:xiter</code> .. returns an iterator that executes the block, skipping <code>nil</code></li>
</ul>
<p>
Block parameter format is <code>|idx:number|</code> where <code>idx</code> indicates an index of the loop.
</p>
<h2><span class="caption-index-2">4.3</span><a name="caption-4-3"></a>Flow Control</h2>
<p>
<strong>break</strong>
</p>
<p>
<code>break(value?):symbol_func:void</code>
</p>
<p>
Exits from an inside of a loop that is formed with functions <code>repeat()</code>, <code>while()</code>, <code>for()</code> and <code>cross()</code>. If it takes an argument, that value is treated as a result of the loop function. Otherwise, the result is nil and an argument list can be omitted.
</p>
<p>
If the loop function is called with one of attributes, <code>:list</code>, <code>:xlist</code>, <code>:set</code>, <code>:xset</code>, <code>:iter</code> and <code>:xiter</code>, the argument value of <code>break()</code> is NOT included as an element in the list or iterator.
</p>
<p>
<strong>continue</strong>
</p>
<p>
<code>continue(value?):symbol_func:void</code>
</p>
<p>
In a loop that is formed with functions <code>repeat()</code>, <code>while()</code>, <code>for()</code> and <code>cross()</code>, skips the following part of it and gets to the top of its process. If it takes an argument, that value is treated as a result of the loop function. Otherwise, the result is nil and an argument list can be omitted.
</p>
<p>
If the loop function is specified with one of <code>:list</code>, <code>:xlist</code>, <code>:set</code>, <code>:xset</code>, <code>:iter</code> and <code>:xiter</code>, the argument value of <code>continue()</code> is included as an element in the list or iterator.
</p>
<p>
<strong>return</strong>
</p>
<p>
<code>return(value?):symbol_func:void</code>
</p>
<p>
Skips the remaining procedure of the current function and returns to context that calls it. If it takes an argument, the value is treated as a result of the function. Otherwise, the returned value would be <code>nil</code>.
</p>
<h2><span class="caption-index-2">4.4</span><a name="caption-4-4"></a>Branch Control</h2>
<p>
<strong>if</strong>
</p>
<p>
<code>if (`cond):leader {block}</code>
</p>
<p>
Specify an "if" block within a statement of <code>if-elsif-else</code>.
</p>
<p>
If the evaluation result of <code>cond</code> is determined as true, the block would be executed, and its evaluation result would become the returned value of the function.
</p>
<p>
Otherwise, if the function is followed by a trailer <code>elsif</code> or <code>else</code>, that would be evaluated. If no trailer exists, the function returns <code>nil</code> value.
</p>
<p>
<strong>elsif</strong>
</p>
<p>
<code>elsif (`cond):leader:trailer {block}</code>
</p>
<p>
Specify an "elsif" block within a statement of <code>if-elsif-else</code>.
</p>
<p>
If the evaluation result of <code>cond</code> is determined as true, the block would be executed, and its evaluation result would become the returned value of the function.
</p>
<p>
Otherwise, if the function is followed by a trailer <code>elsif</code> or <code>else</code>, that would be evaluated. If no trailer exists, the function returns <code>nil</code> value.
</p>
<p>
<strong>else</strong>
</p>
<p>
<code>else():trailer {block}</code>
</p>
<p>
Specify an "else" block within a statement of <code>if-elsif-else</code> or <code>try-catch-else</code>.
</p>
<p>
<strong>end</strong>
</p>
<p>
<code>end(dummy*):symbol_func:trailer:end_marker:void</code>
</p>
<p>
Specify an end of a sequence. This is supposed to appear in a template script.
</p>
<p>
<strong>switch</strong>
</p>
<p>
<code>switch() {block}</code>
</p>
<p>
Form a switch block that contains <code>case()</code> and <code>default()</code> function calls. It calls these functions sequentially and exits the execution when one of the conditions is evaluated as true.
</p>
<p>
<strong>case</strong>
</p>
<p>
<code>case(`cond) {block}</code>
</p>
<p>
Specify an case block within a switch block. After evaluating an expr object cond, the block shall be executed if it has a value of true.
</p>
<p>
<strong>default</strong>
</p>
<p>
<code>default() {block}</code>
</p>
<p>
Specify a default block within a switch block. If all the preceding condition of case block are not evaluated as true, this block shall be executed.
</p>
<h2><span class="caption-index-2">4.5</span><a name="caption-4-5"></a>Handling Exception</h2>
<p>
<strong>try</strong>
</p>
<p>
<code>try():leader {block}</code>
</p>
<p>
Specify a try block of a statement of try-catch-else. It catches signals that occur in the block and executes a corresponding <code>catch()</code> or <code>else()</code> function that follow after it.
</p>
<p>
<strong>catch</strong>
</p>
<p>
<code>catch(errors*:error):leader:trailer {block}</code>
</p>
<p>
Specify an catch block of a statement of try-catch-else. It can take multiple numbers of arguments of error objects to handle. If there's no error objects specified, it handles all the errors that are not handled in the preceding <code>catch()</code> function calls. Block parameter format: <code>|error:error|</code> <code>error</code> is an error object that contains information of the handled error.
</p>
<p>
<strong>finally</strong>
</p>
<p>
<code>finally():trailer:finalizer {block}</code>
</p>
<p>
<strong>raise</strong>
</p>
<p>
<code>raise(error:error, msg:string =&gt; 'error', value?)</code>
</p>
<p>
Raises an error signal with a specified error object, a message string and an additional value.
</p>
<h2><span class="caption-index-2">4.6</span><a name="caption-4-6"></a>Data Transformation</h2>
<p>
<strong>chr</strong>
</p>
<p>
<code>chr(num:number):map:[nil]</code>
</p>
<p>
Converts a UTF-8 code into a string.
</p>
<p>
A number between 128 and 255 is an invalid number and is converted to a null string. If attribute <code>:nil</code> is specified, it returns <code>nil</code> for that case.
</p>
<p>
<strong>hex</strong>
</p>
<p>
<code>hex(num:number, digits?:number):map:[upper]</code>
</p>
<p>
Converts a number into a hexadecimal string. Argument <code>digits</code> specifies a minimum columns of the converted result and fills <code>0</code> in the lacking space.
</p>
<p>
In default, it uses lower-case characters in its conversion, while it uses upper-case ones when <code>:upper</code> attribute is specified.
</p>
<p>
<strong>int</strong>
</p>
<p>
<code>int(value):map</code>
</p>
<p>
Converts a value into an integer number like below:
</p>
<ul>
<li>For a number value, it would be converted into an integer number.</li>
<li>For a compex value, its absolute number would be converted into an integer number.</li>
<li>For a string value, it would be parsed as an integer number. An error occurs if it has an invalid format.</li>
<li>For other values, an error occurs.</li>
</ul>
<p>
<strong>ord</strong>
</p>
<p>
<code>ord(str:string):map</code>
</p>
<p>
Converts the first character of a string into a number of UTF-8 code. If the string contains more than one characters, it simply neglects trailing ones.
</p>
<p>
<strong>tonumber</strong>
</p>
<p>
<code>tonumber(value):map:[nil,raise,strict,zero]</code>
</p>
<p>
Converts a string value into a number by a lexical parsing. If the value is not a string, it first tries to convert the value into a string.
</p>
<p>
If the string starts with a sequence of characters that can be parsed as a number literal, it's not a failure even when it contains other characters following them. Specifying an attribute <code>:strict</code> doesn't allow such a case and fails the process.
</p>
<p>
If it fails the conversion, it would return <code>nil</code> value. Attributes described below are prepared to customize the behaviour in the case of a failure.
</p>
<ul>
<li><code>:raise</code> .. raises an error</li>
<li><code>:zero</code> .. returns zero value</li>
<li><code>:nil</code> .. returns <code>nil</code> value (default)</li>
</ul>
<p>
<strong>tostring</strong>
</p>
<p>
<code>tostring(value):map</code>
</p>
<p>
Converts a value into a string.
</p>
<p>
<strong>tosymbol</strong>
</p>
<p>
<code>tosymbol(str:string):map</code>
</p>
<p>
Converts a string into a symbol.
</p>
<h2><span class="caption-index-2">4.7</span><a name="caption-4-7"></a>Class Operations</h2>
<p>
<strong>class</strong>
</p>
<p>
<code>class(superclass?:function) {block?}</code>
</p>
<p>
Returns a function object of a constructor for a class that includes methods and properties described in the content of the <code>block</code>. For a detail on how to describe the block content for this function, refer to "Gura Language Manual".
</p>
<p>
Example:
</p>
<pre><code>Person = class {
    __init__(name:string, age:number) = {
        this.name = name
        this.age = age
    }
    Print() = {
        printf('name:%s age:%d\n', this.name, this.age)
    }
}
person = Person('Smith', 26)
person.Print()
</code></pre>
<p>
If argument <code>superclass</code>, which is expected to be a constructor function of a super class, is specified, the created class shall inherits methods and properties from the specified class.
</p>
<p>
<strong>classref</strong>
</p>
<p>
<code>classref(type+:expr):map {block?}</code>
</p>
<p>
Looks up a class by an expression of a type name.
</p>
<p>
<strong>struct</strong>
</p>
<p>
<code>struct(`args+):[loose] {block?}</code>
</p>
<p>
Returns a function object of a constructor for a structure that contains properties specified by <code>args</code>. It can optionally take block which declares methods and properties just like <code>class</code> function.
</p>
<p>
An element in <code>args</code> is an expression that has the same format with one in the argument list of a function's declaration. Each variable name becomes a member name in the created instance.
</p>
<p>
Example:
</p>
<pre><code>Person = struct(name:string, age:number)
person = Person('Smith', 26)
printf('name:%s age:%d\n', person.name, person.age)
</code></pre>
<p>
If <code>:loose</code> attribute is speicied, the generated constructor would take all the arguments as optional. Omitted variables are set to <code>nil</code>
</p>
<p>
<strong>super</strong>
</p>
<p>
<code>super(obj):map {block?}</code>
</p>
<p>
Returns a reference to <code>obj</code> that searches methods in a scope of the super class of its own.
</p>
<p>
Example:
</p>
<pre><code>A = class {
    func() = {}
}

B = class(A) {
    func() = {}
}

b = B()
b.func()         // B#func() is called.
super(b).func()  // A#func() is called.
</code></pre>
<h2><span class="caption-index-2">4.8</span><a name="caption-4-8"></a>Scope Operations</h2>
<p>
<strong>local</strong>
</p>
<p>
<code>local(`syms+)</code>
</p>
<p>
Declares symbols that is supposed to access variables in a local scope.
</p>
<p>
<strong>locals</strong>
</p>
<p>
<code>locals(module?:module) {block?}</code>
</p>
<p>
Returns an environment object that belongs to a specified module. If module is omitted, it returns an environment object of the current scope.
</p>
<p>
<strong>outers</strong>
</p>
<p>
<code>outers() {block?}</code>
</p>
<p>
Returns an environment object that accesses to an outer scope.
</p>
<p>
<strong>public</strong>
</p>
<p>
<code>public():void {block}</code>
</p>
<p>
Declares symbols as public ones that are accessible from outer scopes.
</p>
<p>
If you want to make <code>foo</code> and <code>bar</code> accessible, call this function like below:
</p>
<pre><code>public { foo, bar }
</code></pre>
<p>
<strong>scope</strong>
</p>
<p>
<code>scope(target?) {block}</code>
</p>
<p>
Evaluates block with a local scope.
</p>
<h2><span class="caption-index-2">4.9</span><a name="caption-4-9"></a>Module Operations</h2>
<p>
<strong>import</strong>
</p>
<p>
<code>import(`module, `alias?):void:[binary,mixin_type,overwrite] {block?}</code>
</p>
<p>
Imports a module stored in directories specified by a variable sys.path and creates a variable that represents the imported module. There are three format of calling this function like follow:
</p>
<ul>
<li><code>import(foo)</code> .. imports <code>foo</code> module and creates a module object named <code>foo</code></li>
<li><code>import(foo, bar)</code> .. imports <code>foo</code> module and creates a module object named <code>bar</code></li>
<li><code>import(foo) {symbol1, symbol2, symbol3}</code> .. imports <code>foo</code> and mixes up properties <code>symbol1</code>, <code>symbol2</code> and <code>symbol3</code> in the current scope, which are defined in the module.</li>
</ul>
<p>
In the third format, you can specify an asterisk character to mixes up all the symbols defined in the module like below:
</p>
<pre><code>import(foo) {*}
</code></pre>
<p>
If a specified symbol conflicts with what already exists in the current scope, it will cause an error. Specifying the attribute <code>:overwrite</code> will avoid such an error and allow overwriting of symbols.
</p>
<p>
If the argument <code>module</code> is prefixed by a minus operator like <code>-foo</code>, it will not create a variable that represents the imported module.
</p>
<p>
If the argument <code>module</code> is prefixed by an and operator like <code>&amp;foo</code>, the trailing expression will be evaluated and its result, which must be a string, is treated as a module name to be imported. Below is a sample to import <code>foo</code> module through a variable that contains that name:
</p>
<pre><code>var = 'foo'
import(&amp;var)
</code></pre>
<p>
<strong>module</strong>
</p>
<p>
<code>module() {block}</code>
</p>
<p>
Creates a module that contains functions and variables defined in the block and returns it as a module object. This can be used to realize a namespace.
</p>
<h2><span class="caption-index-2">4.10</span><a name="caption-4-10"></a>Value Type Information</h2>
<p>
<strong>isbinary</strong>
</p>
<p>
<code>isbinary(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is binary, and <code>false</code> otherwise.
</p>
<p>
<strong>isboolean</strong>
</p>
<p>
<code>isboolean(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is boolean, and <code>false</code> otherwise.
</p>
<p>
<strong>isclass</strong>
</p>
<p>
<code>isclass(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is class, and <code>false</code> otherwise.
</p>
<p>
<strong>iscomplex</strong>
</p>
<p>
<code>iscomplex(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is complex, and <code>false</code> otherwise.
</p>
<p>
<strong>isdatetime</strong>
</p>
<p>
<code>isdatetime(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is datetime, and <code>false</code> otherwise.
</p>
<p>
<strong>isdict</strong>
</p>
<p>
<code>isdict(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is dict, and <code>false</code> otherwise.
</p>
<p>
<strong>isenvironment</strong>
</p>
<p>
<code>isenvironment(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is environment, and <code>false</code> otherwise.
</p>
<p>
<strong>iserror</strong>
</p>
<p>
<code>iserror(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is error, and <code>false</code> otherwise.
</p>
<p>
<strong>isexpr</strong>
</p>
<p>
<code>isexpr(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is expr, and <code>false</code> otherwise.
</p>
<p>
<strong>isfunction</strong>
</p>
<p>
<code>isfunction(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is function, and <code>false</code> otherwise.
</p>
<p>
<strong>isiterator</strong>
</p>
<p>
<code>isiterator(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is iterator, and <code>false</code> otherwise.
</p>
<p>
<strong>islist</strong>
</p>
<p>
<code>islist(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is list, and <code>false</code> otherwise.
</p>
<p>
<strong>ismatrix</strong>
</p>
<p>
<code>ismatrix(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is matrix, and <code>false</code> otherwise.
</p>
<p>
<strong>ismodule</strong>
</p>
<p>
<code>ismodule(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is module, and <code>false</code> otherwise.
</p>
<p>
<strong>isnil</strong>
</p>
<p>
<code>isnil(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is nil, and <code>false</code> otherwise.
</p>
<p>
<strong>isnumber</strong>
</p>
<p>
<code>isnumber(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is number, and <code>false</code> otherwise.
</p>
<p>
<strong>isrational</strong>
</p>
<p>
<code>isrational(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is rational, and <code>false</code> otherwise.
</p>
<p>
<strong>issemaphore</strong>
</p>
<p>
<code>issemaphore(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is semaphore, and <code>false</code> otherwise.
</p>
<p>
<strong>isstring</strong>
</p>
<p>
<code>isstring(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is string, and <code>false</code> otherwise.
</p>
<p>
<strong>issymbol</strong>
</p>
<p>
<code>issymbol(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is symbol, and <code>false</code> otherwise.
</p>
<p>
<strong>istimedelta</strong>
</p>
<p>
<code>istimedelta(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is timedelta, and <code>false</code> otherwise.
</p>
<p>
<strong>isuri</strong>
</p>
<p>
<code>isuri(value)</code>
</p>
<p>
Returns <code>true</code> if the type of the specified <code>value</code> is uri, and <code>false</code> otherwise.
</p>
<p>
<strong>isdefined</strong>
</p>
<p>
<code>isdefined(`identifier)</code>
</p>
<p>
Returns <code>true</code> if <code>identifier</code> is defined, and <code>false</code> otherwise.
</p>
<p>
<strong>isinstance</strong>
</p>
<p>
<code>isinstance(value, type+:expr):map</code>
</p>
<p>
Returns <code>true</code> if <code>value</code> is an instance of <code>type</code> or its descendant, and <code>false</code> otherwise.
</p>
<p>
<strong>istype</strong>
</p>
<p>
<code>istype(value, type+:expr):map</code>
</p>
<p>
Returns <code>true</code> if <code>value</code> is of the type of <code>type</code>, and <code>false</code> otherwise.
</p>
<p>
<strong>typename</strong>
</p>
<p>
<code>typename(`value)</code>
</p>
<p>
Returns a type name of the value.
</p>
<p>
<strong>undef</strong>
</p>
<p>
<code>undef(`identifier+):[raise]</code>
</p>
<p>
Undefines <code>identifier</code> in the current scope.
</p>
<h2><span class="caption-index-2">4.11</span><a name="caption-4-11"></a>Data Processing</h2>
<p>
<strong>choose</strong>
</p>
<p>
<code>choose(index:number, values+):map</code>
</p>
<p>
Picks up a value placed at <code>index</code> in the argument list <code>values</code>.
</p>
<p>
Sample:
</p>
<pre><code>choose(0, 'apple', 'orange', 'banana') // returns 'apple'
choose(2, 'apple', 'orange', 'banana') // returns 'banana'
</code></pre>
<p>
<strong>cond</strong>
</p>
<p>
<code>cond(flag:boolean, value1:nomap, value2?:nomap):map</code>
</p>
<p>
Returns <code>value1</code> if <code>flag</code> is determined as true, and <code>value2</code> otherwise. If argument <code>value2</code> is omitted, it will return <code>nil</code> when <code>flag</code> is determined as false.
</p>
<p>
This function behaves in a similar way with <code>if</code> function when it's called like below:
</p>
<pre><code>if (flag) { value1 } else { value2 }
</code></pre>
<p>
But they are different in the following points:
</p>
<ul>
<li>Function <code>cond()</code> always evaluates arguments <code>value1</code> and <code>value2</code> no matter what <code>flag</code> value is, while function <code>if()</code> doesn't evaluate <code>value1</code> expression when <code>flag</code> is determined as false.</li>
<li>Function <code>cond()</code> works with implicit mapping, which means that arguments <code>flag</code> may be lists or iterators that are to be supplied to a mapping process.</li>
</ul>
<p>
Arguments <code>value1</code> and <code>value2</code> are not processed by implicit mapping, so you can specify a list or an iterator for them as selected items.
</p>
<p>
<strong>conds</strong>
</p>
<p>
<code>conds(flag:boolean, value1, value2?):map</code>
</p>
<p>
Returns <code>value1</code> if <code>flag</code> is determined as true, and <code>value2</code> otherwise. If argument <code>value2</code> is omitted, it will return <code>nil</code> when <code>flag</code> is determined as false.
</p>
<p>
This function behaves in a similar way with <code>if</code> function when it's called like below:
</p>
<pre><code>if (flag) { value1 } else { value2 }
</code></pre>
<p>
But they are different in the following points:
</p>
<ul>
<li>Function <code>conds()</code> always evaluates arguments <code>value1</code> and <code>value2</code> no matter what <code>flag</code> value is, while function <code>if()</code> doesn't evaluate <code>value1</code> expression when <code>flag</code> is determined as false.</li>
<li>Function <code>conds()</code> works with implicit mapping, which means that arguments <code>flag</code>, <code>value1</code> and <code>value2</code> may be lists or iterators that are to be supplied to a mapping process.</li>
</ul>
<p>
If you want to specify a list or an iterator for <code>value1</code> and <code>value2</code> as selected values, use <code>cond()</code> function instead.
</p>
<p>
<strong>dim</strong>
</p>
<p>
<code>dim(n+:number) {block?}</code>
</p>
<p>
Returns a list that contains <code>n</code> values of <code>nil</code>. If you pass multiple numbers for <code>n</code>, it would create a nested list.
</p>
<p>
Example:
</p>
<pre><code>x = dim(3)     // x is [nil, nil, nil]
x = dim(3, 2)  // x is [[nil, nil], [nil, nil], [nil, nil]]
</code></pre>
<p>
The optional <code>block</code> provides values for each element and takes a block parameters: <code>|i0:number, i1:number, ..|</code>.
</p>
<p>
Example:
</p>
<pre><code>x = dim(3) {'Hi'}
// x is ['Hi', 'Hi', 'Hi']
x = dim(3, 2) {|i, j| format('%d-%d', i, j) }
// x is [['0-0', '0-1'], ['1-0', '1-1'], ['2-0', '2-1']]
</code></pre>
<p>
<strong>max</strong>
</p>
<p>
<code>max(values+):map</code>
</p>
<p>
Returns the maximum value among the given arguments.
</p>
<p>
<strong>min</strong>
</p>
<p>
<code>min(values+):map</code>
</p>
<p>
Returns the minimum value among the given arguments.
</p>
<h2><span class="caption-index-2">4.12</span><a name="caption-4-12"></a>Random</h2>
<p>
<strong>rand</strong>
</p>
<p>
<code>rand(range?:number) {block?}</code>
</p>
<p>
Returns a random number between <code>0</code> and <code>range - 1</code>. If argument <code>range</code> is not specified, it generates random numbers in a range of [0, 1).
</p>
<p>
<strong>randseed</strong>
</p>
<p>
<code>randseed(seed:number):void</code>
</p>
<p>
Initializes random seed with a specified number.
</p>
<h2><span class="caption-index-2">4.13</span><a name="caption-4-13"></a>Help Information</h2>
<p>
<strong>dir</strong>
</p>
<p>
<code>dir(obj?):[noesc]</code>
</p>
<p>
Returns a symbol list of variables and functions that are assigned in the environment of <code>obj</code>.
</p>
<p>
In default, when the <code>obj</code> is an instance of a class, it also searches symbols assigned in the class that it belongs to and its parent classes. Specifying attribute <code>:noesc</code> avoids that behavior.
</p>
<p>
<strong>dirtype</strong>
</p>
<p>
<code>dirtype(obj?):[noesc]</code>
</p>
<p>
Returns a symbol list of value types that are assigned in the environment of <code>obj</code>.
</p>
<p>
In default, when the <code>obj</code> is an instance of a class, it also searches symbols assigned in the class that it belongs to and its parent classes. Specifying attribute <code>:noesc</code> inhibits avoids behavior.
</p>
<p>
<strong>help</strong>
</p>
<p>
<code>help(func:function, lang?:symbol):map:void</code>
</p>
<p>
Prints a help message for the specified function object.
</p>
<h1><span class="caption-index-1">5</span><a name="caption-5"></a>Built-in Operators</h1>
<p>
<table>

<tr>
<th>
Operation</th>
<th>
Explanation</th>
</tr>

<tr>
<td>
<code>
+number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+complex</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+rational</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+matrix</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+timedelta</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@char</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@uchar</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@short</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@ushort</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@long</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@ulong</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@int</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@uint</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@float</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
+array@double</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-complex</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-rational</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-matrix</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-timedelta</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@char</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@uchar</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@short</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@ushort</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-prray@long</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@ulong</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@int</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@uint</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@float</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
-array@double</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
~number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
!any</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
number..</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
any?</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
any*</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
number + number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
number + complex</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
number + rational</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
complex + number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
complex + complex</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
rational + number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
rational + rational</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
matrix + matrix</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
datetime + timedelta</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
timedelta + datetime</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
string + string</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
binary + binary</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
binary + string</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
string + binary</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
pointer + number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
string + any</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
any + string</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
number - number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
number - complex</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
number - rational</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
complex - number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
complex - complex</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
rational - number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
rational - rational</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
matrix - matrix</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
datetime - timedelta</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
datetime - datetime</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
timedelta - timedelta</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
color - color</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
pointer - number</code>
</td>
<td>
</td>
</tr>

<tr>
<td>
<code>
pointer - pointer</code>
</td>
<td>
</td>
</tr>

</table>

</p>
<h1><span class="caption-index-1">6</span><a name="caption-6"></a>Built-in Classes</h1>
<h2><span class="caption-index-2">6.1</span><a name="caption-6-1"></a>args Class</h2>
<p>
The <code>args</code> class provides measures to access argument information that is passed to a function. One of its purposes is to check if an attribute is specified in the function call. It also provides a method to control a leader-trailer sequence, a mechanism that flow controls such as <code>if-elsif-else</code> and <code>try-catch</code> utilize.
</p>
<p>
There's no constructor to realize an instance of <code>args</code> class. Its instance is implicitly created when a function is called, and you can refer to it by a variable named <code>__args__</code>.
</p>
<p>
Below is an example to use <code>args</code> class:
</p>
<pre><code>func(v0, v1, v2):[attr1,attr2] = {
    printf('arg#%d %s\n', 0.., __args__.values)
    printf('attr1:%s attr2:%s\n', __args__.isset(`attr1), __args__.isset(`attr2))
}       
</code></pre>
<h3><span class="caption-index-3">6.1.1</span><a name="caption-6-1-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
args#values</code>
</td>
<td>
<code>
list</code>
</td>
<td>
R</td>

<td>
A list of argument values.</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.1.2</span><a name="caption-6-1-2"></a>Methods</h3>
<p>
<strong>args#finalize_trailer</strong>
</p>
<p>
<code>args#finalize_trailer():void</code>
</p>
<p>
Signals finalizing status to trailers after the current function.
</p>
<p>
<strong>args#isset</strong>
</p>
<p>
<code>args#isset(symbol:symbol)</code>
</p>
<p>
Returns <code>true</code> if the function is called with an attribute that matches the specified symbol.
</p>
<p>
<strong>args#quit_trailer</strong>
</p>
<p>
<code>args#quit_trailer():void</code>
</p>
<p>
Cancels evaluation of following trailers.
</p>
<p>
Example:
</p>
<pre><code>f(flag:boolean) = {
    !flag &amp;&amp; __args__.quit_trailer() 
}

f(true) println('printed')
f(false) println('not printed')
</code></pre>
<h2><span class="caption-index-2">6.2</span><a name="caption-6-2"></a>array Class</h2>
<p>
An instance of the <code>array</code> class stores multiple numeric values in a seamless binary sequence. With such a structure, data in the instances can be passed without any conversion to functions in C library that expect arrays of <code>char</code>, <code>short</code>, <code>int</code> and so on.
</p>
<h3><span class="caption-index-3">6.2.1</span><a name="caption-6-2-1"></a>Methods</h3>
<p>
<strong>array@XXX</strong>
</p>
<p>
<code>array@XXX(arg, init?:number) {block?}</code>
</p>
<p>
<strong>array@XXX#dump</strong>
</p>
<p>
<code>array@XXX#dump(stream?:stream):void:[upper]</code>
</p>
<p>
Prints out a binary dump of the array's content.
</p>
<p>
<strong>array@XXX#each</strong>
</p>
<p>
<code>array@XXX#each() {block?}</code>
</p>
<p>
Creates an iterator that iterates each element in the array.
</p>
<p>
<strong>array@XXX#fill</strong>
</p>
<p>
<code>array@XXX#fill(value:number):map:void</code>
</p>
<p>
Fills array with a specified value.
</p>
<p>
<strong>array@XXX#head</strong>
</p>
<p>
<code>array@XXX#head(n:number):map {block?}</code>
</p>
<p>
Creates an array that extracts specified number of elements at the beginning of the source.
</p>
<p>
<strong>array@XXX#offset</strong>
</p>
<p>
<code>array@XXX#offset(n:number):map {block?}</code>
</p>
<p>
Creates an array that skips <code>n</code> elements of the source.
</p>
<p>
<strong>array@XXX#paste</strong>
</p>
<p>
<code>array@XXX#paste(offset:number, src:array@XXX):map</code>
</p>
<p>
Pastes values in another source array.
</p>
<p>
<strong>array@XXX#tail</strong>
</p>
<p>
<code>array@XXX#tail(n:number):map {block?}</code>
</p>
<p>
Creates an array that extracts specified number of elements at the bottom of the source.
</p>
<h2><span class="caption-index-2">6.3</span><a name="caption-6-3"></a>audio Class</h2>
<p>
The <code>audio</code> class provides measures to work on audio data.
</p>
<h3><span class="caption-index-3">6.3.1</span><a name="caption-6-3-1"></a>Methods</h3>
<p>
<strong>audio#each</strong>
</p>
<p>
<code>audio#each(channel:number, offset?:number):map {block?}</code>
</p>
<p>
<strong>audio#get</strong>
</p>
<p>
<code>audio#get(channel:number, offset:number):map</code>
</p>
<p>
<strong>audio#put</strong>
</p>
<p>
<code>audio#put(channel:number, offset:number, data:number):map:reduce</code>
</p>
<p>
<strong>audio#sinewave</strong>
</p>
<p>
<code>audio#sinewave(channel:number, freq:number, len:number, amplitude?:number):map:reduce</code>
</p>
<p>
<strong>audio#store</strong>
</p>
<p>
<code>audio#store(channel:number, offset:number, data:iterator):reduce</code>
</p>
<h2><span class="caption-index-2">6.4</span><a name="caption-6-4"></a>binary Class</h2>
<p>
The <code>binary</code> class provides measures to work on binary data that is a byte sequence without any format.
</p>
<h3><span class="caption-index-3">6.4.1</span><a name="caption-6-4-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
binary#writable</code>
</td>
<td>
<code>
boolean</code>
</td>
<td>
R</td>

<td>
Indicates if the content of the binary object is writable.</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.4.2</span><a name="caption-6-4-2"></a>Methods</h3>
<p>
<strong>binary</strong>
</p>
<p>
<code>binary(buff*) {block?}</code>
</p>
<p>
<strong>binary#add</strong>
</p>
<p>
<code>binary#add(buff+:binary):map:reduce</code>
</p>
<p>
<strong>binary.alloc</strong>
</p>
<p>
<code>binary.alloc(bytes:number, data?:number):static:map {block?}</code>
</p>
<p>
<strong>binary.decode</strong>
</p>
<p>
<code>binary.decode(codec:codec)</code>
</p>
<p>
<strong>binary#dump</strong>
</p>
<p>
<code>binary#dump(stream?:stream:w):void:[upper]</code>
</p>
<p>
<strong>binary#each</strong>
</p>
<p>
<code>binary#each() {block?}</code>
</p>
<p>
Returns an iterator picking up each byte in the buffer
</p>
<p>
<strong>binary#encodeuri</strong>
</p>
<p>
<code>binary#encodeuri()</code>
</p>
<p>
Returns a string in which non-URIC characters are percent-encoded.
</p>
<p>
<strong>binary#hex</strong>
</p>
<p>
<code>binary#hex():[carray,cstr,upper]</code>
</p>
<p>
<strong>binary#len</strong>
</p>
<p>
<code>binary#len()</code>
</p>
<p>
Returns the length of the buffer in binary.
</p>
<p>
<strong>binary.pack</strong>
</p>
<p>
<code>binary.pack(format:string, value*):static:map {block?}</code>
</p>
<p>
<strong>binary#pointer</strong>
</p>
<p>
<code>binary#pointer(offset:number =&gt; 0) {block?}</code>
</p>
<p>
Returns a pointer instance that has an initial offset specified by the argument.
</p>
<p>
<strong>binary#reader</strong>
</p>
<p>
<code>binary#reader() {block?}</code>
</p>
<p>
<strong>binary#store</strong>
</p>
<p>
<code>binary#store(offset:number, buff+:binary):map:reduce</code>
</p>
<p>
<strong>binary#unpack</strong>
</p>
<p>
<code>binary#unpack(format:string, values*:number):[nil]</code>
</p>
<p>
<strong>binary#unpacks</strong>
</p>
<p>
<code>binary#unpacks(format:string, values*:number) {block?}</code>
</p>
<p>
<strong>binary#writer</strong>
</p>
<p>
<code>binary#writer() {block?}</code>
</p>
<h2><span class="caption-index-2">6.5</span><a name="caption-6-5"></a>codec Class</h2>
<p>
The <code>codec</code> class provides measures to convert character codes.
</p>
<h3><span class="caption-index-3">6.5.1</span><a name="caption-6-5-1"></a>Methods</h3>
<p>
<strong>codec#addcr</strong>
</p>
<p>
<code>codec#addcr(flag?:boolean):reduce</code>
</p>
<p>
<strong>codec#decode</strong>
</p>
<p>
<code>codec#decode(buff:binary):map</code>
</p>
<p>
<strong>codec#delcr</strong>
</p>
<p>
<code>codec#delcr(flag?:boolean):reduce</code>
</p>
<p>
<strong>codec#encode</strong>
</p>
<p>
<code>codec#encode(string:string):map</code>
</p>
<h2><span class="caption-index-2">6.6</span><a name="caption-6-6"></a>color Class</h2>
<p>
An instance of the <code>color</code> class represents a color data that consists of red, green, blue and alpha elements.
</p>
<h3><span class="caption-index-3">6.6.1</span><a name="caption-6-6-1"></a>Predefined Variables</h3>
<p>
<table>

<tr>
<th>
Variable</th>
<th>
Type</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
color.names</code>
</td>
<td>
<code>
string[]</code>
</td>

<td>
A list of color names that can be passed to <code>
color()</code>
 function.</td>
</tr>


</table>

</p>
<p>
And some color instances are assigned to the variables: <code>color.black</code>, <code>color.maroon</code>, <code>color.green</code>, <code>color.olive</code>, <code>color.navy</code>, <code>color.purple</code>, <code>color.teal</code>, <code>color.gray</code>, <code>color.silverk</code>, <code>color.red</code>, <code>color.lime</code>, <code>color.yellow</code>, <code>color.blue</code>, <code>color.aqua</code>, <code>color.white</code>.
</p>
<h3><span class="caption-index-3">6.6.2</span><a name="caption-6-6-2"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
color#r</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Value of the red element.</td>
</tr>


<tr>
<td>
<code>
color#g</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Value of the green element.</td>
</tr>


<tr>
<td>
<code>
color#b</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Value of the blue element.</td>
</tr>


<tr>
<td>
<code>
color#a</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Value of the alpha element.</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.6.3</span><a name="caption-6-6-3"></a>Methods</h3>
<p>
<strong>color</strong>
</p>
<p>
<code>color(args+):map {block?}</code>
</p>
<p>
Creates a color instance.
</p>
<p>
If <code>block</code> is specified, it would be evaluated with a block parameter <code>|c:color|</code>, where <code>c</code> is the created instance. In this case, the block's result would become the function's returned value.
</p>
<p>
There are two forms to call this function as below:
</p>
<ul>
<li><code>color(name:symbol, a?:number)</code> .. Specifies a color name and an optional alpha element.</li>
<li><code>color(r:number, g?:number, b?:number, a?:number)</code> .. Specifies RGB and an optional alpha elements.</li>
</ul>
<p>
<strong>color#getgray</strong>
</p>
<p>
<code>color#getgray()</code>
</p>
<p>
Calculates a gray scale from RGB elements in the <code>color</code> instance.
</p>
<p>
This is computed by a formula: <code>gray = 0.299 * red + 0.587 * blue + 0.114 * blue</code>.
</p>
<p>
<strong>color#html</strong>
</p>
<p>
<code>color#html()</code>
</p>
<p>
Returns a color string in a format of <code>#rrggbb</code> that is used in HTML documents.
</p>
<p>
<strong>color#tolist</strong>
</p>
<p>
<code>color#tolist():[alpha]</code>
</p>
<p>
Returns a list of RGB elements in a form <code>[r, g, b]</code>. Specifying <code>:alpha</code> attribute would add alpha element to the list.
</p>
<h2><span class="caption-index-2">6.7</span><a name="caption-6-7"></a>datetime Class</h2>
<p>
The <code>datetime</code> class provides measures to handle date and time information.
</p>
<h3><span class="caption-index-3">6.7.1</span><a name="caption-6-7-1"></a>Predefined Variables</h3>
<p>
<table>

<tr>
<th>
Variable</th>
<th>
Type</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
datetime.Sunday</code>
</td>
<td>
<code>
number</code>
</td>

<td>
Assigned with number 0 that represents Sunday.</td>
</tr>


<tr>
<td>
<code>
datetime.Monday</code>
</td>
<td>
<code>
number</code>
</td>

<td>
Assigned with number 1 that represents Monday.</td>
</tr>


<tr>
<td>
<code>
datetime.Tuesday</code>
</td>
<td>
<code>
number</code>
</td>

<td>
Assigned with number 2 that represents Tuesday.</td>
</tr>


<tr>
<td>
<code>
datetime.Wednesday</code>
</td>
<td>
<code>
number</code>
</td>

<td>
Assigned with number 3 that represents Wednesday.</td>
</tr>


<tr>
<td>
<code>
datetime.Thursday</code>
</td>
<td>
<code>
number</code>
</td>

<td>
Assigned with number 4 that represents Thursday.</td>
</tr>


<tr>
<td>
<code>
datetime.Friday</code>
</td>
<td>
<code>
number</code>
</td>

<td>
Assigned with number 5 that represents Friday.</td>
</tr>


<tr>
<td>
<code>
datetime.Saturday</code>
</td>
<td>
<code>
number</code>
</td>

<td>
Assigned with number 6 that represents Saturday.</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.7.2</span><a name="caption-6-7-2"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
datetime#year</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Chritian year.</td>
</tr>


<tr>
<td>
<code>
datetime#month</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Month starting from 1. Numbers from 1 to 12 correspond to January to December.</td>
</tr>


<tr>
<td>
<code>
datetime#day</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Day in a month starting from 1. </td>
</tr>


<tr>
<td>
<code>
datetime#hour</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Hour in a day between 0 and 23.</td>
</tr>


<tr>
<td>
<code>
datetime#min</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Minute in an hour between 0 and 59.</td>
</tr>


<tr>
<td>
<code>
datetime#sec</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Second in a minute between 0 and 59.</td>
</tr>


<tr>
<td>
<code>
datetime#usec</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
Millisecond in a second between 0 and 999.</td>
</tr>


<tr>
<td>
<code>
datetime#wday</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
Week number starting from 0. Number from 0 to 6 corresponds to Sunday to Saturday.</td>
</tr>


<tr>
<td>
<code>
datetime#week</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>

Week symbol that takes one of the followings:
`` `sunday``, `` `monday``, `` `tuesday``, `` `wednesday``,
`` `thursday``, `` `friday``, `` `saturday``
</td>
</tr>


<tr>
<td>
<code>
datetime#yday</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
Day in a year starting from 1.</td>
</tr>


<tr>
<td>
<code>
datetime#unixtime</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
Seconds passed from 00:00:00 on January 1st in 1970 in UTC.</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.7.3</span><a name="caption-6-7-3"></a>Methods</h3>
<p>
<strong>datetime</strong>
</p>
<p>
<code>datetime(year:number, month:number, day:number, hour:number =&gt; 0, min:number =&gt; 0, sec:number =&gt; 0, usec:number =&gt; 0, minsoff?:number):map {block?}</code>
</p>
<p>
Creates an instance of <code>datetime</code> class based on the specified arguments.
</p>
<p>
If <code>block</code> is specified, it would be evaluated with a block parameter <code>|dt:datetime|</code>, where <code>dt</code> is the created instance. In this case, the block's result would become the function's returned value.
</p>
<p>
Meaning of the arguments are shown below:
</p>
<ul>
<li><code>year</code> .. Christian year.</li>
<li><code>month</code> .. Month starting from 1. Numbers from 1 to 12 correspond to January to December.</li>
<li><code>day</code> .. Day in a month starting from 1.</li>
<li><code>hour</code> .. Hour in a day between 0 and 23.</li>
<li><code>min</code> .. Minute in an hour between 0 and 59.</li>
<li><code>sec</code> .. Second in a minute between 0 and 59.</li>
<li><code>usec</code> .. Millisecond in a second between 0 and 999.</li>
<li><code>minsoff</code> .. Timezone offset in minutes.</li>
</ul>
<p>
In default, the instance has a timezone offset based on the current system settings.
</p>
<p>
<strong>datetime#clrtzoff</strong>
</p>
<p>
<code>datetime#clrtzoff():reduce</code>
</p>
<p>
Eliminates timezone offset information from the instance.
</p>
<p>
<strong>datetime#format</strong>
</p>
<p>
<code>datetime#format(format =&gt; `w3c)</code>
</p>
<p>
Returns a string of the datetime properties based on the specified format. For the argument <code>format</code>, you can specify either a string of user-specific format or a symbol of predefined style.
</p>
<p>
A string of user-specific format contains following specifiers:
</p>
<ul>
<li><code>%d</code> .. day of month</li>
<li><code>%H</code> .. hour in 24-hour format</li>
<li><code>%I</code> .. hour in 12-hour format</li>
<li><code>%m</code> .. month</li>
<li><code>%M</code> .. minute</li>
<li><code>%S</code> .. second</li>
<li><code>%w</code> .. week number starting from 0 for Sunday.</li>
<li><code>%y</code> .. lower two digits of year</li>
<li><code>%Y</code> .. four digits of year</li>
</ul>
<p>
Below are the symbols of predefined styles:
</p>
<ul>
<li><code>`w3c</code> .. W3C style. eg) "<code>2015-01-01T12:34:56+09:00</code>"</li>
<li><code>`http</code> .. a style used in HTTP protocol. eg) "<code>Thu, 01 Jan 2015 12:34:56 +0900</code>"</li>
<li><code>`asctime</code> .. a style used by the C function <code>asctime()</code>. eg) "<code>Thu Jan  1 12:34:56 +0900 2015</code>"</li>
</ul>
<p>
<strong>datetime.isleap</strong>
</p>
<p>
<code>datetime.isleap(year:number):static:map</code>
</p>
<p>
Returns <code>true</code> if the specified year is a leap one.
</p>
<p>
<strong>datetime.monthdays</strong>
</p>
<p>
<code>datetime.monthdays(year:number, month:number):static:map {block?}</code>
</p>
<p>
Returns a number of days that exists in the specified month.
</p>
<p>
<strong>datetime.now</strong>
</p>
<p>
<code>datetime.now():static:[utc] {block?}</code>
</p>
<p>
Creates a <code>datetime</code> instance of the current time.
</p>
<p>
In default, the timezone offset is set to one in the system setting. Specifying <code>:utc</code> attribute would set the offset to 0.
</p>
<p>
<strong>datetime.parse</strong>
</p>
<p>
<code>datetime.parse(str:string):static:map {block?}</code>
</p>
<p>
Parses a string that describs date and time information and returns the <code>datetime</code> instance.
</p>
<p>
It is capable of parsing the following style:
</p>
<ul>
<li>RFC1123 style. eg) <code>'Sat, 06 Nov 2010 08:49:37 GMT'</code></li>
<li>RFC1036 style. eg) <code>'Saturday, 06-Nov-10 08:49:37 GMT'</code></li>
<li>C's <code>asctime()</code> style. eg) <code>'Sat Nov  6 08:49:37 2010'</code>, <code>'Sat Nov  6 08:49:37 +0000 2010'</code></li>
<li>W3C style. eg) <code>'2010-11-06T08:49:37Z'</code></li>
</ul>
<p>
<strong>datetime#settzoff</strong>
</p>
<p>
<code>datetime#settzoff(mins:number):reduce</code>
</p>
<p>
Sets timezone offset in minutes.
</p>
<p>
<strong>datetime.time</strong>
</p>
<p>
<code>datetime.time(hour:number =&gt; 0, minute:number =&gt; 0, sec:number =&gt; 0, usec:number =&gt; 0):static:map {block?}</code>
</p>
<p>
Creates a <code>datetime</code> instance from time information. The date inforomation is set to 1st of January in 0000.
</p>
<p>
<strong>datetime.today</strong>
</p>
<p>
<code>datetime.today():static:[utc] {block?}</code>
</p>
<p>
Creates a <code>datetime</code> instance of today. All the time information are cleared to 0.
</p>
<p>
In default, the timezone offset is set to one in the system setting. Specifying <code>:utc</code> attribute would set the offset to 0.
</p>
<p>
<strong>datetime#utc</strong>
</p>
<p>
<code>datetime#utc()</code>
</p>
<p>
Calculates UTC time of the target <code>datetime</code> instance. An error occurs if the instance has no timezone offset
</p>
<p>
<strong>datetime.weekday</strong>
</p>
<p>
<code>datetime.weekday(year:number, month:number, day:number):static:map</code>
</p>
<p>
Returns a week number for the specified date, which starts from 0 for Sunday.
</p>
<h2><span class="caption-index-2">6.8</span><a name="caption-6-8"></a>declaration Class</h2>
<h3><span class="caption-index-3">6.8.1</span><a name="caption-6-8-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
declaration#symbol</code>
</td>
<td>
<code>
symbol</code>
</td>
<td>
R</td>

<td>
The name of the declaration in symbol.</td>
</tr>


<tr>
<td>
<code>
declaration#name</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
The name of the declaration in string.</td>
</tr>


<tr>
<td>
<code>
declaration#default</code>
</td>
<td>
<code>
expr</code>
</td>
<td>
R</td>

<td>
The expression that provides a default value.</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.8.2</span><a name="caption-6-8-2"></a>Methods</h3>
<p>
<strong>declaration#istype</strong>
</p>
<p>
<code>declaration#istype(type+:expr):map</code>
</p>
<h2><span class="caption-index-2">6.9</span><a name="caption-6-9"></a>dict Class</h2>
<h3><span class="caption-index-3">6.9.1</span><a name="caption-6-9-1"></a>Methods</h3>
<p>
<strong>dict</strong>
</p>
<p>
<code>dict(elem[]?):[icase] {block?}</code>
</p>
<p>
<strong>dict#clear</strong>
</p>
<p>
<code>dict#clear()</code>
</p>
<p>
<strong>dict#erase</strong>
</p>
<p>
<code>dict#erase(key):map</code>
</p>
<p>
<strong>dict#get</strong>
</p>
<p>
<code>dict#get(key, default?:nomap):map:[raise]</code>
</p>
<p>
<strong>dict#gets</strong>
</p>
<p>
<code>dict#gets(key, default?):map:[raise]</code>
</p>
<p>
<strong>dict#haskey</strong>
</p>
<p>
<code>dict#haskey(key):map</code>
</p>
<p>
<strong>dict#items</strong>
</p>
<p>
<code>dict#items() {block?}</code>
</p>
<p>
<strong>dict#keys</strong>
</p>
<p>
<code>dict#keys() {block?}</code>
</p>
<p>
<strong>dict#len</strong>
</p>
<p>
<code>dict#len()</code>
</p>
<p>
<strong>dict#set</strong>
</p>
<p>
<code>dict#set(key, value:nomap):map:reduce</code>
</p>
<p>
<strong>dict#setdefault</strong>
</p>
<p>
<code>dict#setdefault(key, value:nomap):map:reduce</code>
</p>
<p>
<strong>dict#sets</strong>
</p>
<p>
<code>dict#sets(key, value):map:void</code>
</p>
<p>
<strong>dict#store</strong>
</p>
<p>
<code>dict#store(elems?):reduce:[default] {block?}</code>
</p>
<p>
<strong>dict#values</strong>
</p>
<p>
<code>dict#values() {block?}</code>
</p>
<h2><span class="caption-index-2">6.10</span><a name="caption-6-10"></a>directory Class</h2>
<h3><span class="caption-index-3">6.10.1</span><a name="caption-6-10-1"></a>Methods</h3>
<p>
<strong>directory</strong>
</p>
<p>
<code>directory(pathname:string):map {block?}</code>
</p>
<h2><span class="caption-index-2">6.11</span><a name="caption-6-11"></a>environment Class</h2>
<h3><span class="caption-index-3">6.11.1</span><a name="caption-6-11-1"></a>Methods</h3>
<p>
<strong>environment#getprop!</strong>
</p>
<p>
<code>environment#getprop!(symbol:symbol):map</code>
</p>
<p>
<strong>environment#lookup</strong>
</p>
<p>
<code>environment#lookup(symbol:symbol, escalate:boolean =&gt; true):map</code>
</p>
<p>
Looks up a specified symbol in the environment and returns the associated value. In default, if the symbol is not defined in the environment, it will be searched in environments outside of the current one. Set escalate flag to false in order to disable such an escalation behaviour. Returns false when the symbol could not be found.
</p>
<p>
<strong>environment#setprop!</strong>
</p>
<p>
<code>environment#setprop!(symbol:symbol, value):map</code>
</p>
<h2><span class="caption-index-2">6.12</span><a name="caption-6-12"></a>error Class</h2>
<h3><span class="caption-index-3">6.12.1</span><a name="caption-6-12-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
error#source</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
The name of the file that causes this error.</td>
</tr>


<tr>
<td>
<code>
error#lineno</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
The number of line where the expression that causes this error starts.</td>
</tr>


<tr>
<td>
<code>
error#linenobtm</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
The number of line where the expression that causes this error ends.</td>
</tr>


<tr>
<td>
<code>
error#postext</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
A text that consists of a source name and a line number.</td>
</tr>


<tr>
<td>
<code>
error#text</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
An error message.
If an attribute `:lineno` is specified, it would contain a line number.</td>
</tr>


<tr>
<td>
<code>
error#trace</code>
</td>
<td>
<code>
expr[]</code>
</td>
<td>
R</td>

<td>
Stack trace.</td>
</tr>


</table>

</p>
<h2><span class="caption-index-2">6.13</span><a name="caption-6-13"></a>expr Class</h2>
<h3><span class="caption-index-3">6.13.1</span><a name="caption-6-13-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
expr#attrs</code>
</td>
<td>
<code>
symbol[]</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#attrsopt</code>
</td>
<td>
<code>
symbol[]</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#block</code>
</td>
<td>
<code>
expr</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#blockparam</code>
</td>
<td>
<code>
iterator</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#body</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#car</code>
</td>
<td>
<code>
expr</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#cdr</code>
</td>
<td>
<code>
iterator</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#child</code>
</td>
<td>
<code>
expr</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#children</code>
</td>
<td>
<code>
iterator</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#left</code>
</td>
<td>
<code>
expr</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#lineno</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#linenobtm</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#operator</code>
</td>
<td>
<code>
operator</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#postext</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#right</code>
</td>
<td>
<code>
expr</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#source</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#suffix</code>
</td>
<td>
<code>
symbol</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#symbol</code>
</td>
<td>
<code>
symbol</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#trailer</code>
</td>
<td>
<code>
expr</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#typename</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#typesym</code>
</td>
<td>
<code>
symbol</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
expr#value</code>
</td>
<td>
<code>
any</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.13.2</span><a name="caption-6-13-2"></a>Methods</h3>
<p>
<strong>expr</strong>
</p>
<p>
<code>expr(src:stream:r):map {block?}</code>
</p>
<p>
Parses a content of a script stream and returns an expr object.
</p>
<p>
<strong>expr#eval</strong>
</p>
<p>
<code>expr#eval(env?:environment)</code>
</p>
<p>
Evaluates an expr object. If argument <code>env</code> is specified, that environment is used for evaluation. Otherwise, environment of the current scope is used.
</p>
<p>
<strong>expr.parse</strong>
</p>
<p>
<code>expr.parse(script:string):static:map {block?}</code>
</p>
<p>
Parses a string and returns an expr object. If <code>block</code> is specified, it will be evaluated with block parameter in a format of <code>|expr:expr|</code> where <code>expr</code> is the created object.
</p>
<p>
<strong>expr#textize</strong>
</p>
<p>
<code>expr#textize(style?:symbol, indent?:string)</code>
</p>
<p>
Composes a script text from a content of expr.
</p>
<p>
Argument <code>style</code> specifies the text style output, which takes the following symbols. Default is <code>fancy</code>.
</p>
<ul>
<li><code>`crammed</code> .. puts all the text in one line and removes volatile spaces</li>
<li><code>`oneline</code> .. puts all the text in one line</li>
<li><code>`brief</code> .. omits content of blocks and long strings with ".."</li>
<li><code>`fancy</code> .. the most readable style</li>
</ul>
<p>
Argument <code>indent</code> specifies a string for indentation. Default is a sequence of four spaces.
</p>
<p>
<strong>expr#tofunction</strong>
</p>
<p>
<code>expr#tofunction(`args*)</code>
</p>
<p>
Creates a function with specified arguments and a body of expr.
</p>
<p>
<strong>expr#unquote</strong>
</p>
<p>
<code>expr#unquote()</code>
</p>
<p>
<strong>expr#write</strong>
</p>
<p>
<code>expr#write(dst:stream:w, style?:symbol, indent?:string)</code>
</p>
<p>
Outputs a script that describes the expression to the specified <code>stream</code>.
</p>
<p>
Argument <code>style</code> specifies the text style output, which takes the following symbols. Default is <code>fancy</code>.
</p>
<ul>
<li><code>`crammed</code> .. puts all the text in one line and removes volatile spaces</li>
<li><code>`oneline</code> .. puts all the text in one line</li>
<li><code>`brief</code> .. omits content of blocks and long strings with ".."</li>
<li><code>`fancy</code> .. the most readable style</li>
</ul>
<p>
Argument <code>indent</code> specifies a string for indentation. Default is a sequence of four spaces.
</p>
<p>
<strong>expr#isunary</strong>
</p>
<p>
<code>expr#isunary()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of unary.
</p>
<p>
<strong>expr#isunaryop</strong>
</p>
<p>
<code>expr#isunaryop()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of unaryop.
</p>
<p>
<strong>expr#isquote</strong>
</p>
<p>
<code>expr#isquote()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of quote.
</p>
<p>
<strong>expr#isbinary</strong>
</p>
<p>
<code>expr#isbinary()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of binary.
</p>
<p>
<strong>expr#isbinaryop</strong>
</p>
<p>
<code>expr#isbinaryop()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of binaryop.
</p>
<p>
<strong>expr#isassign</strong>
</p>
<p>
<code>expr#isassign()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of assign.
</p>
<p>
<strong>expr#ismember</strong>
</p>
<p>
<code>expr#ismember()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of member.
</p>
<p>
<strong>expr#iscollector</strong>
</p>
<p>
<code>expr#iscollector()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of collector.
</p>
<p>
<strong>expr#isroot</strong>
</p>
<p>
<code>expr#isroot()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of root.
</p>
<p>
<strong>expr#isblock</strong>
</p>
<p>
<code>expr#isblock()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of block.
</p>
<p>
<strong>expr#islister</strong>
</p>
<p>
<code>expr#islister()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of lister.
</p>
<p>
<strong>expr#isiterer</strong>
</p>
<p>
<code>expr#isiterer()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of iterer.
</p>
<p>
<strong>expr#iscompound</strong>
</p>
<p>
<code>expr#iscompound()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of compound.
</p>
<p>
<strong>expr#isindexer</strong>
</p>
<p>
<code>expr#isindexer()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of indexer.
</p>
<p>
<strong>expr#iscaller</strong>
</p>
<p>
<code>expr#iscaller()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of caller.
</p>
<p>
<strong>expr#isvalue</strong>
</p>
<p>
<code>expr#isvalue()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of value.
</p>
<p>
<strong>expr#isidentifier</strong>
</p>
<p>
<code>expr#isidentifier()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of identifier.
</p>
<p>
<strong>expr#issuffixed</strong>
</p>
<p>
<code>expr#issuffixed()</code>
</p>
<p>
Returns <code>true</code> if expr is an expression of suffixed.
</p>
<h2><span class="caption-index-2">6.14</span><a name="caption-6-14"></a>formatter Class</h2>
<h3><span class="caption-index-3">6.14.1</span><a name="caption-6-14-1"></a>Methods</h3>
<p>
<strong>formatter#getfieldminwidth</strong>
</p>
<p>
<code>formatter#getfieldminwidth()</code>
</p>
<p>
<strong>formatter#getpadding</strong>
</p>
<p>
<code>formatter#getpadding()</code>
</p>
<p>
<strong>formatter#getplusmode</strong>
</p>
<p>
<code>formatter#getplusmode()</code>
</p>
<p>
<strong>formatter#getprecision</strong>
</p>
<p>
<code>formatter#getprecision()</code>
</p>
<p>
<strong>formatter#isleftalign</strong>
</p>
<p>
<code>formatter#isleftalign()</code>
</p>
<p>
<strong>formatter#issharp</strong>
</p>
<p>
<code>formatter#issharp()</code>
</p>
<p>
<strong>formatter#isuppercase</strong>
</p>
<p>
<code>formatter#isuppercase()</code>
</p>
<h2><span class="caption-index-2">6.15</span><a name="caption-6-15"></a>function Class</h2>
<h3><span class="caption-index-3">6.15.1</span><a name="caption-6-15-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
function#decls</code>
</td>
<td>
<code>
iterator</code>
</td>
<td>
R</td>

<td>
iterator of <code>
declaration</code>
 instances that provide information about argument declaration the function defines.</td>
</tr>


<tr>
<td>
<code>
function#expr</code>
</td>
<td>
<code>
expr</code>
</td>
<td>
R/W</td>

<td>
an expression of the function.</td>
</tr>


<tr>
<td>
<code>
function#format</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
a string showing a declared format of the function.</td>
</tr>


<tr>
<td>
<code>
function#fullname</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
a full name of the function that is prefixed by a name of the module or the class it belongs to. </td>
</tr>


<tr>
<td>
<code>
function#name</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
a name of the function in <code>
string</code>
.</td>
</tr>


<tr>
<td>
<code>
function#symbol</code>
</td>
<td>
<code>
symbol</code>
</td>
<td>
R/W</td>

<td>
a name of the function in <code>
symbol</code>
. </td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.15.2</span><a name="caption-6-15-2"></a>Methods</h3>
<p>
<strong>function</strong>
</p>
<p>
<code>function(`args*) {block}</code>
</p>
<p>
Creates a <code>function</code> instance with an argument list of <code>args</code> and a procedure body provided by <code>block</code>.
</p>
<p>
Following two codes have the same effect with each other.
</p>
<pre><code>f = function(a, b, c) { /* any job */ }
</code></pre>
<pre><code>f(a, b, c) = { /* any job */ }
</code></pre>
<p>
<strong>function.addhelp</strong>
</p>
<p>
<code>function.addhelp(func:function, lang:symbol, format:string, help:string):static:map:void</code>
</p>
<p>
Adds help information to a <code>function</code> instance taking the following arguments:
</p>
<ul>
<li><code>func</code> .. <code>function</code> instance to which the help is added.</li>
<li><code>lang</code> .. a symbol of the language in which the help text is described, <code>`en</code> for English, <code>`ja</code> for Japanese and so on.</li>
<li><code>format</code> .. a name of the syntax format in which the help text is described. Currently, only <code>'markdown'</code> is available.</li>
<li><code>help</code>.. the help text.</li>
</ul>
<p>
You can add multiple help information with different <code>lang</code>.
</p>
<p>
Following two codes have the same effect with each other.
</p>
<pre><code>f(a, b, c) = {
    (a + b + c) / 3
}
function.addhelp(
    f, `en, 'markdown'
    R'''
    Computes a mean value of the provided three numbers.
    ''')
</code></pre>
<pre><code>f(a, b, c) = {
    (a + b + c) / 3
} % {
    `en, 'markdown'
    R'''
    Computes a mean value of the provided three numbers.
    '''
}
</code></pre>
<p>
<strong>function.getdecls</strong>
</p>
<p>
<code>function.getdecls(func:function):static:map</code>
</p>
<p>
Creates an iterator of <code>declaration</code> instances that provide information about argument declaration the <code>function</code> defines.
</p>
<p>
This class method returns the same information as the property <code>function#decls</code>.
</p>
<p>
<strong>function.getexpr</strong>
</p>
<p>
<code>function.getexpr(func:function):static:map</code>
</p>
<p>
Returns an expression of the function.
</p>
<p>
It would return <code>nil</code> if the function is implemented with binary programs, not scripts.
</p>
<p>
This class method returns the same information as the property <code>function#expr</code>.
</p>
<p>
<strong>function.getformat</strong>
</p>
<p>
<code>function.getformat(func:function):static:map</code>
</p>
<p>
Returns a string showing a declared format of the function.
</p>
<p>
This class method returns the same information as the property <code>function#format</code>.
</p>
<p>
<strong>function.getfullname</strong>
</p>
<p>
<code>function.getfullname(func:function):static:map</code>
</p>
<p>
Returns a full name of the function that is prefixed by a name of the module or the class it belongs to.
</p>
<p>
This class method returns the same information as the property <code>function#fullname</code>.
</p>
<p>
<strong>function.gethelp</strong>
</p>
<p>
<code>function.gethelp(func:function, lang?:symbol):static:map</code>
</p>
<p>
Returns a <code>help</code> instance of the specified function. If no help has been registred, it would return <code>nil</code>.
</p>
<p>
The argument <code>lang</code> is a symbol that indicates a language in which the help is written. If this argument is omitted or the specified language doesn't exist, help information that has been registered at first would be returned as a default.
</p>
<p>
<strong>function.getname</strong>
</p>
<p>
<code>function.getname(func:function):static:map</code>
</p>
<p>
Returns a name of the function in <code>string</code>.
</p>
<p>
This class method returns the same information as the property <code>function#name</code>.
</p>
<p>
<strong>function.getsymbol</strong>
</p>
<p>
<code>function.getsymbol(func:function):static:map</code>
</p>
<p>
Returns a name of the function in <code>symbol</code>.
</p>
<p>
This class method returns the same information as the property <code>function#symbol</code>.
</p>
<p>
<strong>function#mathdiff</strong>
</p>
<p>
<code>function#mathdiff(var?:symbol):reduce</code>
</p>
<p>
Returns a <code>function</code> instance that computes derivation of the target function, which is expected to contain only mathematical procedures. An error occurs if the target function has any elements that have nothing to do with mathematics.
</p>
<p>
In default, it differentiates the target function with respect to its first argument. Below is an example:
</p>
<pre><code>&gt;&gt;&gt; f(x) = math.sin(x)
&gt;&gt;&gt; g = f.mathdiff()    // g is a function to compute math.cos(x)
</code></pre>
<p>
Specify a symbol to argument <code>var</code> when you want to differentiate with respect to another variable.
</p>
<p>
You can check the result of derivation by seeing property <code>function#expr</code> like below:
</p>
<pre><code>&gt;&gt;&gt; g.expr
`math.cos(x)
</code></pre>
<h2><span class="caption-index-2">6.16</span><a name="caption-6-16"></a>help Class</h2>
<h3><span class="caption-index-3">6.16.1</span><a name="caption-6-16-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
help#format</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
help#lang</code>
</td>
<td>
<code>
symbol</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
help#text</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


</table>

</p>
<h2><span class="caption-index-2">6.17</span><a name="caption-6-17"></a>image Class</h2>
<h3><span class="caption-index-3">6.17.1</span><a name="caption-6-17-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
image#format</code>
</td>
<td>
<code>
symbol</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
image#height</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
image#palette</code>
</td>
<td>
<code>
palette</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
image#width</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R</td>

<td>
</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.17.2</span><a name="caption-6-17-2"></a>Methods</h3>
<p>
<strong>image</strong>
</p>
<p>
<code>image(args+):map {block?}</code>
</p>
<p>
Returns an image object with specified characteristics. There are three patterns to call the function as following:
</p>
<ul>
<li><code>image(stream:stream, format?:symbol, imagetype?:string)</code></li>
<li><code>image(format:symbol)</code></li>
<li><code>image(format:symbol, width:number, height:number, color?:color)</code></li>
</ul>
<p>
In the first pattern, it creates an empty image with a specified format. The second reads image data from the stream and expand it in the buffer. The last allocates an image buffer of specified size and fills it with the color. Parameter format specifies the internal format. Available formats are <code>rgb</code> and <code>rgba</code>.
</p>
<p>
<strong>image#allocbuff</strong>
</p>
<p>
<code>image#allocbuff(width:number, height:number, color?:color):reduce</code>
</p>
<p>
Allocates a buffer of the specified size to an image instance that doesn't have buffer yet. The buffer will be filled with zero or a color of <code>color</code> argument if specified.
</p>
<p>
<strong>image#blur</strong>
</p>
<p>
<code>image#blur(radius:number, sigma?:number) {block?}</code>
</p>
<p>
<strong>image#clear</strong>
</p>
<p>
<code>image#clear():reduce</code>
</p>
<p>
Fills the buffer with zero value. This has the same effect with calling <code>image#fill</code> with <code>color.Zero</code>.
</p>
<p>
<strong>image#crop</strong>
</p>
<p>
<code>image#crop(x:number, y:number, width?:number, height?:number):map {block?}</code>
</p>
<p>
Returns a new image instance after extracting part of the source image. You can specify the left-top position of the extracted area with arguments <code>x</code> and <code>y</code>. You can specify the extracted size with <code>width</code> and <code>height</code>. If they're omitted, extraction will be done up to the right-bottom position of the source image.
</p>
<p>
<strong>image#delpalette</strong>
</p>
<p>
<code>image#delpalette():reduce</code>
</p>
<p>
Deletes the palette instance associated with the image.
</p>
<p>
<strong>image#extract</strong>
</p>
<p>
<code>image#extract(x:number, y:number, width:number, height:number, element:symbol, dst):reduce</code>
</p>
<p>
<strong>image#fill</strong>
</p>
<p>
<code>image#fill(color:color):reduce</code>
</p>
<p>
Fills the whole image with the specified color.
</p>
<p>
<strong>image#fillrect</strong>
</p>
<p>
<code>image#fillrect(x:number, y:number, width:number, height:number, color:color):map:reduce</code>
</p>
<p>
Fills the specified arew with the specified color.
</p>
<p>
<strong>image#flip</strong>
</p>
<p>
<code>image#flip(orient:symbol):map {block?}</code>
</p>
<p>
Returns a new <code>image</code> instance that flips the source image horizontally or vertically. You can specify the following symbol to the <code>orient</code> argument.
</p>
<ul>
<li><code>horz</code> .. flips horizontally.</li>
<li><code>vert</code> .. flips vertically.</li>
<li><code>both</code> .. flips both horizontally and vertically. This has the same effect with rotating the image 180 degrees.</li>
</ul>
<p>
<strong>image#getpixel</strong>
</p>
<p>
<code>image#getpixel(x:number, y:number):map {block?}</code>
</p>
<p>
Returns <code>color</code> instance of a color data at the specified position.
</p>
<p>
<strong>image#grayscale</strong>
</p>
<p>
<code>image#grayscale() {block?}</code>
</p>
<p>
Returns a new image instance that converts the source image into gray scale.
</p>
<p>
<strong>image#mapcolorlevel</strong>
</p>
<p>
<code>image#mapcolorlevel(map_r[]:number, map_g[]?:number, map_b[]?:number) {block?}</code>
</p>
<p>
<strong>image#paste</strong>
</p>
<p>
<code>image#paste(x:number, y:number, src:image, width?:number, height?:number, xoffset:number =&gt; 0, yoffset:number =&gt; 0, a:number =&gt; 255):map:reduce</code>
</p>
<p>
<strong>image#putpixel</strong>
</p>
<p>
<code>image#putpixel(x:number, y:number, color:color):map:reduce</code>
</p>
<p>
<strong>image#size</strong>
</p>
<p>
<code>image#size()</code>
</p>
<p>
<strong>image#store</strong>
</p>
<p>
<code>image#store(x:number, y:number, width:number, height:number, element:symbol, src):reduce</code>
</p>
<p>
<strong>image#read</strong>
</p>
<p>
<code>image#read(stream:stream:r, imagetype?:string):map:reduce</code>
</p>
<p>
Reads image data from a stream.
</p>
<p>
<strong>image#reducecolor</strong>
</p>
<p>
<code>image#reducecolor(palette?:palette) {block?}</code>
</p>
<p>
<strong>image#replacecolor</strong>
</p>
<p>
<code>image#replacecolor(colorOrg:color, color:color, tolerance?:number):reduce</code>
</p>
<p>
<strong>image#resize</strong>
</p>
<p>
<code>image#resize(width?:number, height?:number):map:[box,ratio] {block?}</code>
</p>
<p>
<strong>image#rotate</strong>
</p>
<p>
<code>image#rotate(rotate:number, background?:color):map {block?}</code>
</p>
<p>
<strong>image#scan</strong>
</p>
<p>
<code>image#scan(x?:number, y?:number, width?:number, height?:number, scandir?:symbol) {block?}</code>
</p>
<p>
Returns an iterator that scans pixels in the image.
</p>
<p>
<strong>image#setalpha</strong>
</p>
<p>
<code>image#setalpha(a:number, color?:color, tolerance?:number):reduce</code>
</p>
<p>
<strong>image#thumbnail</strong>
</p>
<p>
<code>image#thumbnail(width?:number, height?:number):map:[box] {block?}</code>
</p>
<p>
<strong>image#write</strong>
</p>
<p>
<code>image#write(stream:stream:w, imagetype?:string):map:reduce</code>
</p>
<p>
Writes image data to a stream.
</p>
<h2><span class="caption-index-2">6.18</span><a name="caption-6-18"></a>iterator Class</h2>
<h3><span class="caption-index-3">6.18.1</span><a name="caption-6-18-1"></a>Methods</h3>
<p>
<strong>iterator</strong>
</p>
<p>
<code>iterator(value+) {block?}</code>
</p>
<p>
<strong>range</strong>
</p>
<p>
<code>range(num:number, num_end?:number, step?:number):map {block?}</code>
</p>
<p>
<strong>interval</strong>
</p>
<p>
<code>interval(a:number, b:number, samples:number):map:[open,open_l,open_r] {block?}</code>
</p>
<p>
<strong>consts</strong>
</p>
<p>
<code>consts(value, num?:number) {block?}</code>
</p>
<p>
<strong>rands</strong>
</p>
<p>
<code>rands(range?:number, num?:number) {block?}</code>
</p>
<p>
Creates an iterator that returns random numbers between <code>0</code> and <code>range - 1</code>. If argument <code>range</code> is not specified, it generates random numbers in a range of [0, 1).
</p>
<p>
In default, the created iterator infinitely generates random numbers. The argument <code>num</code> specifies how many numbers should be generated.
</p>
<p>
<strong>iterator#delay</strong>
</p>
<p>
<code>iterator#delay(delay:number) {block?}</code>
</p>
<p>
<strong>iterator#isinfinite</strong>
</p>
<p>
<code>iterator#isinfinite()</code>
</p>
<p>
<strong>iterator#next</strong>
</p>
<p>
<code>iterator#next()</code>
</p>
<p>
<strong>iterator#print</strong>
</p>
<p>
<code>iterator#print(stream?:stream:w)</code>
</p>
<p>
<strong>iterator#println</strong>
</p>
<p>
<code>iterator#println(stream?:stream:w)</code>
</p>
<p>
<strong>iterator#printf</strong>
</p>
<p>
<code>iterator#printf(format:string, stream?:stream:w)</code>
</p>
<p>
<strong>iterator#repeater</strong>
</p>
<p>
<code>iterator#repeater()</code>
</p>
<p>
<strong>iterator#after</strong>
</p>
<p>
<code>iterator#after(criteria) {block?}</code>
</p>
<p>
<strong>iterator#align</strong>
</p>
<p>
<code>iterator#align(n:number, value?) {block?}</code>
</p>
<p>
<strong>iterator#and</strong>
</p>
<p>
<code>iterator#and()</code>
</p>
<p>
<strong>iterator#average</strong>
</p>
<p>
<code>iterator#average()</code>
</p>
<p>
Returns an average of values in the iterator.
</p>
<p>
<strong>iterator#before</strong>
</p>
<p>
<code>iterator#before(criteria) {block?}</code>
</p>
<p>
<strong>iterator#contains</strong>
</p>
<p>
<code>iterator#contains(value)</code>
</p>
<p>
Returns true if a specified value exists in the iterated elements.
</p>
<p>
<strong>iterator#count</strong>
</p>
<p>
<code>iterator#count(criteria?)</code>
</p>
<p>
<strong>iterator#cycle</strong>
</p>
<p>
<code>iterator#cycle(n?:number) {block?}</code>
</p>
<p>
<strong>iterator#each</strong>
</p>
<p>
<code>iterator#each() {block?}</code>
</p>
<p>
<strong>iterator#filter</strong>
</p>
<p>
<code>iterator#filter(criteria?) {block?}</code>
</p>
<p>
<strong>iterator#find</strong>
</p>
<p>
<code>iterator#find(criteria?):[index]</code>
</p>
<p>
<strong>iterator#flat</strong>
</p>
<p>
<code>iterator#flat():[bfs,dfs] {block?}</code>
</p>
<p>
Returns an iterator that searches items recursively if they are lists or iterators. Searching is done in order of depth-first-search by default. Specifying attribute <code>:bfs</code> will process in breadth-first-search order. Unlike <code>iterator#walk</code>, this always returns an iterator without an infinite flag.
</p>
<p>
<strong>iterator#fold</strong>
</p>
<p>
<code>iterator#fold(n:number, nstep?:number):map:[iteritem,neat] {block?}</code>
</p>
<p>
<strong>iterator#format</strong>
</p>
<p>
<code>iterator#format(format:string):map {block?}</code>
</p>
<p>
<strong>iterator#head</strong>
</p>
<p>
<code>iterator#head(n:number):map {block?}</code>
</p>
<p>
<strong>iterator#join</strong>
</p>
<p>
<code>iterator#join(sep?:string):map</code>
</p>
<p>
<strong>iterator#joinb</strong>
</p>
<p>
<code>iterator#joinb()</code>
</p>
<p>
<strong>iterator#len</strong>
</p>
<p>
<code>iterator#len()</code>
</p>
<p>
Returns the length of the iterator.
</p>
<p>
<strong>iterator#map</strong>
</p>
<p>
<code>iterator#map(func:function) {block?}</code>
</p>
<p>
<strong>iterator#max</strong>
</p>
<p>
<code>iterator#max():[index,indices,last_index]</code>
</p>
<p>
Returns the maximum value in the iterator.
</p>
<p>
It would return a position index where the maximum value is found when one of the following attribute is specified:
</p>
<ul>
<li><code>:index</code> .. an index of the maximum value.</li>
<li><code>:indices</code> .. a list of indices where the maximum value is found.</li>
<li><code>:last_index</code> .. the last index of the maximum value when the value exists at multiple positions.</li>
</ul>
<p>
<strong>iterator#min</strong>
</p>
<p>
<code>iterator#min():[index,indices,last_index]</code>
</p>
<p>
Returns the minimum value in the iterator.
</p>
<p>
It would return a position index where the minimum value is found when one of the following attribute is specified:
</p>
<ul>
<li><code>:index</code> .. an index of the minimum value.</li>
<li><code>:indices</code> .. a list of indices where the minimum value is found.</li>
<li><code>:last_index</code> .. the last index of the minimum value when the value exists at multiple positions.</li>
</ul>
<p>
<strong>iterator#nilto</strong>
</p>
<p>
<code>iterator#nilto(replace) {block?}</code>
</p>
<p>
<strong>iterator#offset</strong>
</p>
<p>
<code>iterator#offset(n:number) {block?}</code>
</p>
<p>
<strong>iterator#or</strong>
</p>
<p>
<code>iterator#or()</code>
</p>
<p>
<strong>iterator#pack</strong>
</p>
<p>
<code>iterator#pack(format:string) {block?}</code>
</p>
<p>
<strong>iterator#pingpong</strong>
</p>
<p>
<code>iterator#pingpong(n?:number):[sticky,sticky_l,sticky_r] {block?}</code>
</p>
<p>
<strong>iterator#rank</strong>
</p>
<p>
<code>iterator#rank(directive?) {block?}</code>
</p>
<p>
<strong>iterator#reduce</strong>
</p>
<p>
<code>iterator#reduce(accum) {block}</code>
</p>
<p>
<strong>iterator#replace</strong>
</p>
<p>
<code>iterator#replace(value, replace) {block?}</code>
</p>
<p>
<strong>iterator#reverse</strong>
</p>
<p>
<code>iterator#reverse() {block?}</code>
</p>
<p>
<strong>iterator#roundoff</strong>
</p>
<p>
<code>iterator#roundoff(threshold:number =&gt; 1e-10) {block?}</code>
</p>
<p>
<strong>iterator#runlength</strong>
</p>
<p>
<code>iterator#runlength() {block?}</code>
</p>
<p>
<strong>iterator#since</strong>
</p>
<p>
<code>iterator#since(criteria) {block?}</code>
</p>
<p>
<strong>iterator#skip</strong>
</p>
<p>
<code>iterator#skip(n:number) {block?}</code>
</p>
<p>
<strong>iterator#skipnil</strong>
</p>
<p>
<code>iterator#skipnil() {block?}</code>
</p>
<p>
<strong>iterator#sort</strong>
</p>
<p>
<code>iterator#sort(directive?, keys[]?):[stable] {block?}</code>
</p>
<p>
<strong>iterator#stddev</strong>
</p>
<p>
<code>iterator#stddev()</code>
</p>
<p>
Returns a standard deviation of values in the iterator.
</p>
<p>
<strong>iterator#sum</strong>
</p>
<p>
<code>iterator#sum()</code>
</p>
<p>
Returns a sum of values in the iterator.
</p>
<p>
<strong>iterator#tail</strong>
</p>
<p>
<code>iterator#tail(n:number) {block?}</code>
</p>
<p>
<strong>iterator#until</strong>
</p>
<p>
<code>iterator#until(criteria) {block?}</code>
</p>
<p>
<strong>iterator#variance</strong>
</p>
<p>
<code>iterator#variance()</code>
</p>
<p>
Returns a variance of values in the iterator.
</p>
<p>
<strong>iterator#walk</strong>
</p>
<p>
<code>iterator#walk():[bfs,dfs] {block?}</code>
</p>
<p>
Returns an iterator that searches items recursively if they are lists or iterators. Searching is done in order of depth-first-search by default. Specifying attribute <code>:bfs</code> will process in breadth-first-search order.
</p>
<p>
<strong>iterator#while</strong>
</p>
<p>
<code>iterator#while (criteria) {block?}</code>
</p>
<h2><span class="caption-index-2">6.19</span><a name="caption-6-19"></a>list Class</h2>
<h3><span class="caption-index-3">6.19.1</span><a name="caption-6-19-1"></a>Methods</h3>
<p>
<strong>list</strong>
</p>
<p>
<code>list(value+)</code>
</p>
<p>
Creates a new list from given values in its argument list. If the value is a list or an iteartor, its elements are added to the created list.
</p>
<p>
<strong>xlist</strong>
</p>
<p>
<code>xlist(value+)</code>
</p>
<p>
Creates a new list from given values except for <code>nil</code> in its argument list. If the value is a list or an iteartor, its elements are added to the created list.
</p>
<p>
<strong>set</strong>
</p>
<p>
<code>set(iter+:iterator):[and,or,xor]</code>
</p>
<p>
Creates a new list that contains unique values from given iterators in its argument list.
</p>
<p>
In default, all the elements in each iterators are added to the created list. Specifying the following attributes would apply a filtering condition.
</p>
<ul>
<li><code>:and</code> .. Elements that exist in all the iterators are added.</li>
<li><code>:or</code> .. All the elements are added. This is the default behavior.</li>
<li><code>:xor</code> .. Elements that exist in only one iterator are added.</li>
</ul>
<p>
<strong>xset</strong>
</p>
<p>
<code>xset(iter+:iterator):[and,or,xor]</code>
</p>
<p>
Creates a new list that contains unique values except for <code>nil</code> from given iterators in its argument list.
</p>
<p>
In default, all the elements in each iterators are added to the created list. Specifying the following attributes would apply a filtering condition.
</p>
<ul>
<li><code>:and</code> .. Elements that exist in all the iterators are added.</li>
<li><code>:or</code> .. All the elements are added. This is the default behavior.</li>
<li><code>:xor</code> .. Elements that exist in only one iterator are added.</li>
</ul>
<p>
<strong>list.zip</strong>
</p>
<p>
<code>list.zip(values+):static {block?}</code>
</p>
<p>
Creates an iterator generating lists that bind given argument values. When the value is a list or an iterator, each item in it would be zipped.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
<strong>list#add</strong>
</p>
<p>
<code>list#add(elem+):reduce</code>
</p>
<p>
Add specified items to the list.
</p>
<p>
<strong>list#append</strong>
</p>
<p>
<code>list#append(elem+):reduce</code>
</p>
<p>
Adds specified items to the list. If the item is a list or an iterator, each element in such an item is added to the list.
</p>
<p>
<strong>list#clear</strong>
</p>
<p>
<code>list#clear():reduce</code>
</p>
<p>
Clear the content of the list.
</p>
<p>
<strong>list#combination</strong>
</p>
<p>
<code>list#combination(n:number) {block?}</code>
</p>
<p>
Creates an iterator that generates lists that contain elements picked up from the original list in a combination manner.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value:list, idx:number|</code>
</p>
<p>
<strong>list#erase</strong>
</p>
<p>
<code>list#erase(idx*:number):reduce</code>
</p>
<p>
Erases elements at the specified indices.
</p>
<p>
<strong>list#first</strong>
</p>
<p>
<code>list#first()</code>
</p>
<p>
Returns a first value in the list. An error occurs when the list is empty.
</p>
<p>
<strong>list#flat</strong>
</p>
<p>
<code>list#flat():[bfs,dfs]</code>
</p>
<p>
Creates a flattened list by searching items recursively if they are lists or iterators. Searching is done in order of depth-first-search by default. Specifying attribute <code>:bfs</code> will process in breadth-first-search order.
</p>
<p>
<strong>list#get</strong>
</p>
<p>
<code>list#get(index:number):map:flat</code>
</p>
<p>
Returns a value stored at the specified index in the list. An error occurs when the index is out of range.
</p>
<p>
<strong>list#insert</strong>
</p>
<p>
<code>list#insert(idx:number, elem+):reduce</code>
</p>
<p>
Insert specified items to the list from the selected index.
</p>
<p>
<strong>list#isempty</strong>
</p>
<p>
<code>list#isempty()</code>
</p>
<p>
Return true if the list is empty.
</p>
<p>
<strong>list#last</strong>
</p>
<p>
<code>list#last()</code>
</p>
<p>
Returns a last value in the list. An error occurs when the list is empty.
</p>
<p>
<strong>list#permutation</strong>
</p>
<p>
<code>list#permutation(n?:number) {block?}</code>
</p>
<p>
Creates an iterator that generates lists that contain elements picked up from the original list in a permutation manner.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value:list, idx:number|</code>
</p>
<p>
<strong>list#printf</strong>
</p>
<p>
<code>list#printf(format:string, stream?:stream:w):void</code>
</p>
<p>
Prints items in the list by using the format.
</p>
<p>
<strong>list#put</strong>
</p>
<p>
<code>list#put(index:number, value:nomap):map:reduce</code>
</p>
<p>
Stores a value at the specified index in the list. An error occurs when the index is out of range.
</p>
<p>
<strong>list#shift</strong>
</p>
<p>
<code>list#shift():[raise]</code>
</p>
<p>
Shifts the elements of the list. If the content of the list is [1, 2, 3, 4], it becomes [2, 3, 4] after calling this method. In default, no error occurs even when the list is empty. To raise an error for executing this method on an empty list, specify :raise attribute.
</p>
<p>
<strong>list#shuffle</strong>
</p>
<p>
<code>list#shuffle():reduce</code>
</p>
<p>
Shuffle the order of the list content based on random numbers.
</p>
<p>
<strong>list#after</strong>
</p>
<p>
<code>list#after(criteria) {block?}</code>
</p>
<p>
Creates an iterator that picks up each element in the list after criteria is evaluated as true. You can specify a function object, a list or an iterator as the criteria.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value:list, idx:number|</code>
</p>
<p>
<strong>list#align</strong>
</p>
<p>
<code>list#align(n:number, value?):map {block?}</code>
</p>
<p>
<strong>list#and</strong>
</p>
<p>
<code>list#and()</code>
</p>
<p>
Calculates a logical AND result of all the values in the list. Values of boolean type's false and nil are recognized as false while others are true.
</p>
<p>
<strong>list#average</strong>
</p>
<p>
<code>list#average()</code>
</p>
<p>
Returns an average of values in the list.
</p>
<p>
<strong>list#before</strong>
</p>
<p>
<code>list#before(criteria) {block?}</code>
</p>
<p>
Creates an iterator that picks up each element in the list before criteria is evaluated as true. You can specify a function object, a list or an iterator as the criteria.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value:list, idx:number|</code>
</p>
<p>
<strong>list#contains</strong>
</p>
<p>
<code>list#contains(value)</code>
</p>
<p>
Returns true if a specified value exists in the list.
</p>
<p>
<strong>list#count</strong>
</p>
<p>
<code>list#count(criteria?)</code>
</p>
<p>
Returns a number of elements that matches the given criteria which is a single-argument function or a value. When a function is applied, it counts the number of true after evaluating element value with the function. If a value is applied, it counts the number of elements that are equal to the value.
</p>
<p>
<strong>list#cycle</strong>
</p>
<p>
<code>list#cycle(n?:number) {block?}</code>
</p>
<p>
<strong>list#each</strong>
</p>
<p>
<code>list#each() {block?}</code>
</p>
<p>
Creates an iterator that iterates each element in the list.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value, idx:number|</code>
</p>
<p>
<strong>list#filter</strong>
</p>
<p>
<code>list#filter(criteria?) {block?}</code>
</p>
<p>
Returns a list that consists of elements of the original list after filtering by a criteria. A criteria can be an iterator or a function object. When an iterator is supplied as a criteria, it picks up true value in the iterator and creates a list that contains elements at corresponding position in the original list When a function object is applied, each element is passed to the function as an argument, and it collects values with evaluated results being true.
</p>
<p>
<strong>list#find</strong>
</p>
<p>
<code>list#find(criteria?):[index]</code>
</p>
<p>
<strong>list#fold</strong>
</p>
<p>
<code>list#fold(n:number, nstep?:number):map:[iteritem,neat] {block?}</code>
</p>
<p>
<strong>list#format</strong>
</p>
<p>
<code>list#format(format:string):map {block?}</code>
</p>
<p>
Applies element values in the list to format string that contains C printfspecifiers	and returns a formatted string.
</p>
<p>
<strong>list#head</strong>
</p>
<p>
<code>list#head(n:number):map {block?}</code>
</p>
<p>
<strong>list#join</strong>
</p>
<p>
<code>list#join(sep?:string):map</code>
</p>
<p>
Returns a string that joins strings of elements with the specified separator.
</p>
<p>
<strong>list#len</strong>
</p>
<p>
<code>list#len()</code>
</p>
<p>
Returns the length of the list.
</p>
<p>
<strong>list#map</strong>
</p>
<p>
<code>list#map(func:function) {block?}</code>
</p>
<p>
Creates an iterator that generates element values after applying the specfied function on them. The function must take one argument.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value, idx:number|</code>
</p>
<p>
<strong>list#max</strong>
</p>
<p>
<code>list#max():[index,indices,last_index]</code>
</p>
<p>
Returns the maximum value in the list.
</p>
<p>
It would return a position index where the maximum value is found when one of the following attribute is specified:
</p>
<ul>
<li><code>:index</code> .. an index of the maximum value.</li>
<li><code>:indices</code> .. a list of indices where the maximum value is found.</li>
<li><code>:last_index</code> .. the last index of the maximum value when the value exists at multiple positions.</li>
</ul>
<p>
<strong>list#min</strong>
</p>
<p>
<code>list#min():[index,indices,last_index]</code>
</p>
<p>
Returns the minimum value in the list.
</p>
<p>
It would return a position index where the minimum value is found when one of the following attribute is specified:
</p>
<ul>
<li><code>:index</code> .. an index of the minimum value.</li>
<li><code>:indices</code> .. a list of indices where the minimum value is found.</li>
<li><code>:last_index</code> .. the last index of the minimum value when the value exists at multiple positions.</li>
</ul>
<p>
<strong>list#nilto</strong>
</p>
<p>
<code>list#nilto(replace) {block?}</code>
</p>
<p>
<strong>list#offset</strong>
</p>
<p>
<code>list#offset(n:number):map {block?}</code>
</p>
<p>
<strong>list#or</strong>
</p>
<p>
<code>list#or()</code>
</p>
<p>
Calculates a logical OR result of all the values in the list. Values of boolean type's false and nil are recognized as false while others are true.
</p>
<p>
<strong>list#pack</strong>
</p>
<p>
<code>list#pack(format:string)</code>
</p>
<p>
Returns a binary object packing elements values according to a format string. Following markers specify the order of how a multi-byte number is stored.
</p>
<ul>
<li><code>@</code> .. sets as a native order for the current platform</li>
<li><code>=</code> .. sets as a native order for the current platform</li>
<li><code>&lt;</code> .. sets as a little-endian order</li>
<li><code>&gt;</code> .. sets as a big-endian order</li>
<li><code>!</code> .. sets as a big-endian order</li>
</ul>
<p>
Following markers specify a storing format. They can be preceded by a number that specifies the number of values.
</p>
<ul>
<li><code>x</code> .. just skips one byte</li>
<li><code>c</code> .. takes a string that contains one character and stores it as a byte value</li>
<li><code>b</code> .. stores a number as a signed byte value</li>
<li><code>B</code> .. stores a number as an unsigned byte value</li>
<li><code>h</code> .. stores a number as a signed half-word (2 bytes) value</li>
<li><code>H</code> .. stores a number as an unsigned half-word (2 bytes) value</li>
<li><code>i</code> .. stores a number as a signed integer (4 bytes) value</li>
<li><code>I</code> .. stores a number as an unsigned integer (4 bytes) value</li>
<li><code>l</code> .. stores a number as a signed integer (4 bytes) value</li>
<li><code>L</code> .. stores a number as an unsigned integer (4 bytes) value</li>
<li><code>q</code> .. stores a number as a signed long integer (8 bytes) value</li>
<li><code>Q</code> .. stores a number as an unsigned long integer (8 bytes) value</li>
<li><code>f</code> .. stores a number as a float (4 bytes) value</li>
<li><code>d</code> .. stores a number as a double (8 bytes) value</li>
<li><code>s</code> .. stores a string after character encoding</li>
</ul>
<p>
<strong>list#pingpong</strong>
</p>
<p>
<code>list#pingpong(n?:number):[sticky,sticky_l,sticky_r] {block?}</code>
</p>
<p>
<strong>list#rank</strong>
</p>
<p>
<code>list#rank(directive?):[stable] {block?}</code>
</p>
<p>
Returns a list of rank numbers for elements after sorting them. In default, they are sorted in an ascending order. You can specify the following directives for sorting.
</p>
<ul>
<li><code>`ascend</code> .. ascending order</li>
<li><code>`descend</code> .. descending order</li>
<li>function .. it takes two element values x and y and returns zero for x == y, plus value for x &lt; y and minus value for x &gt; y.</li>
</ul>
<p>
When an attribute :stable is specified, the original order shall be kept for elements that are determined as the same.
</p>
<p>
<strong>list#reduce</strong>
</p>
<p>
<code>list#reduce(accum) {block}</code>
</p>
<p>
Evaluates a block with a parameter format <code>|value, accum|</code> and leaves the result as the next <code>accum</code> value. It returns the final <code>accum</code> value as its result.
</p>
<p>
<strong>list#replace</strong>
</p>
<p>
<code>list#replace(value, replace) {block?}</code>
</p>
<p>
<strong>list#reverse</strong>
</p>
<p>
<code>list#reverse() {block?}</code>
</p>
<p>
<strong>list#roundoff</strong>
</p>
<p>
<code>list#roundoff(threshold:number =&gt; 1e-10) {block?}</code>
</p>
<p>
<strong>list#runlength</strong>
</p>
<p>
<code>list#runlength() {block?}</code>
</p>
<p>
<strong>list#since</strong>
</p>
<p>
<code>list#since(criteria) {block?}</code>
</p>
<p>
Creates an iterator that picks up each element in the list since criteria is evaluated as true. You can specify a function object, a list or an iterator as the criteria.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value:list, idx:number|</code>
</p>
<p>
<strong>list#skip</strong>
</p>
<p>
<code>list#skip(n:number):map {block?}</code>
</p>
<p>
<strong>list#skipnil</strong>
</p>
<p>
<code>list#skipnil() {block?}</code>
</p>
<p>
<strong>list#sort</strong>
</p>
<p>
<code>list#sort(directive?, keys[]?):[stable] {block?}</code>
</p>
<p>
Returns an iterator of elements after sorting them. In default, they are sorted in an ascending order. You can specify the following directives for sorting.
</p>
<ul>
<li><code>`ascend</code> .. ascending order</li>
<li><code>`descend</code> .. descending order</li>
<li>function .. it takes two element values x and y and returns zero for x == y, plus value for x &lt; y and minus value for x &gt; y.</li>
</ul>
<p>
If keys is specified, it shall be used as a key instead of element values. When an attribute :stable is specified, the original order shall be kept for elements that are determined as the same.
</p>
<p>
<strong>list#stddev</strong>
</p>
<p>
<code>list#stddev()</code>
</p>
<p>
Returns a standard deviation of values in the list.
</p>
<p>
<strong>list#sum</strong>
</p>
<p>
<code>list#sum()</code>
</p>
<p>
Returns a sum of values in the list.
</p>
<p>
<strong>list#tail</strong>
</p>
<p>
<code>list#tail(n:number):map {block?}</code>
</p>
<p>
<strong>list#until</strong>
</p>
<p>
<code>list#until(criteria) {block?}</code>
</p>
<p>
Creates an iterator that picks up each element in the list until criteria is evaluated as true. You can specify a function object, a list or an iterator as the criteria.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value:list, idx:number|</code>
</p>
<p>
<strong>list#variance</strong>
</p>
<p>
<code>list#variance()</code>
</p>
<p>
Returns a variance of values in the list.
</p>
<p>
<strong>list#walk</strong>
</p>
<p>
<code>list#walk():[bfs,dfs] {block?}</code>
</p>
<p>
Returns an iterator that searches items recursively if they are lists or iterators. Searching is done in order of depth-first-search by default. Specifying attribute <code>:bfs</code> will process in breadth-first-search order.
</p>
<p>
<strong>list#while</strong>
</p>
<p>
<code>list#while (criteria) {block?}</code>
</p>
<p>
Creates an iterator that picks up each element in the list while criteria is evaluated as true. You can specify a function object, a list or an iterator as the criteria.
</p>
<p>
If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
Block parameter format: <code>|value:list, idx:number|</code>
</p>
<h2><span class="caption-index-2">6.20</span><a name="caption-6-20"></a>matrix Class</h2>
<h3><span class="caption-index-3">6.20.1</span><a name="caption-6-20-1"></a>Methods</h3>
<p>
<strong>matrix</strong>
</p>
<p>
<code>matrix(nrows:number, ncols:number, value?) {block?}</code>
</p>
<p>
<strong>matrix#col</strong>
</p>
<p>
<code>matrix#col(col:number):map</code>
</p>
<p>
Returns a list of values copied from a specified column of the matrix. Modification on the returned sub matrix will affect on the original one.
</p>
<p>
<strong>matrix#colsize</strong>
</p>
<p>
<code>matrix#colsize()</code>
</p>
<p>
Returns the matrix column size.
</p>
<p>
<strong>matrix#each</strong>
</p>
<p>
<code>matrix#each():[transpose]</code>
</p>
<p>
Returns an iterator that picks up each cell by scanning the matrix. In default, that scan is done in a horizontal direction. When an attribute :transpose is specified, it's done in a vertical direction.
</p>
<p>
<strong>matrix#eachcol</strong>
</p>
<p>
<code>matrix#eachcol()</code>
</p>
<p>
Returns an iterator that generates lists of values copied from each column of the matrix.
</p>
<p>
<strong>matrix#eachrow</strong>
</p>
<p>
<code>matrix#eachrow()</code>
</p>
<p>
Returns an iterator that generates lists of values copied from each row of the matrix.
</p>
<p>
<strong>matrix.identity</strong>
</p>
<p>
<code>matrix.identity(n:number):static:map {block?}</code>
</p>
<p>
<strong>matrix#invert</strong>
</p>
<p>
<code>matrix#invert()</code>
</p>
<p>
Returns an inverted matrix.
</p>
<p>
<strong>matrix#issquare</strong>
</p>
<p>
<code>matrix#issquare()</code>
</p>
<p>
Returns true if the matrix is a square one.
</p>
<p>
<strong>matrix.rotation</strong>
</p>
<p>
<code>matrix.rotation(angle:number, tx?:number, ty?:number):static:map:[deg] {block?}</code>
</p>
<p>
<strong>matrix.rotation_x</strong>
</p>
<p>
<code>matrix.rotation_x(angle:number, tx?:number, ty?:number, tz?:number):static:map:[deg] {block?}</code>
</p>
<p>
<strong>matrix.rotation_y</strong>
</p>
<p>
<code>matrix.rotation_y(angle:number, tx?:number, ty?:number, tz?:number):static:map:[deg] {block?}</code>
</p>
<p>
<strong>matrix.rotation_z</strong>
</p>
<p>
<code>matrix.rotation_z(angle:number, tx?:number, ty?:number, tz?:number):static:map:[deg] {block?}</code>
</p>
<p>
<strong>matrix#roundoff</strong>
</p>
<p>
<code>matrix#roundoff(threshold:number =&gt; 1e-10)</code>
</p>
<p>
Returns a matrix with values that have been rounded off.
</p>
<p>
<strong>matrix#row</strong>
</p>
<p>
<code>matrix#row(row:number):map</code>
</p>
<p>
Returns a list of values copied from a specified row of the matrix. Modification on the returned sub matrix will affect on the original one.
</p>
<p>
<strong>matrix#rowsize</strong>
</p>
<p>
<code>matrix#rowsize()</code>
</p>
<p>
Returns the matrix row size.
</p>
<p>
<strong>matrix#set</strong>
</p>
<p>
<code>matrix#set(value)</code>
</p>
<p>
Sets all the cells of the matrix with a specified value.
</p>
<p>
<strong>matrix#setcol</strong>
</p>
<p>
<code>matrix#setcol(col:number, value)</code>
</p>
<p>
Sets cells in a selected column of the matrix with a specified value.
</p>
<p>
<strong>matrix#setrow</strong>
</p>
<p>
<code>matrix#setrow(row:number, value)</code>
</p>
<p>
Sets cells in a selected row of the matrix with a specified value.
</p>
<p>
<strong>matrix#submat</strong>
</p>
<p>
<code>matrix#submat(row:number, col:number, nrows:number, ncols:number):map</code>
</p>
<p>
Returns a sub matrix that refers to cells in a specified area of the matrix. Modification on the returned sub matrix will affect on the original one.
</p>
<p>
<strong>matrix#tolist</strong>
</p>
<p>
<code>matrix#tolist():[flat,transpose]</code>
</p>
<p>
Converts the matrix into a list containing sub-lists that represents its rows. If :transpose attribute is specified, each sub-list contains values of corresponding column. If :flat attribute is specified, it generates one-dimentional list. Example:
</p>
<pre><code>@@{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}.tolist()
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
@@{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}.tolist():transpose
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
</code></pre>
<p>
<strong>matrix#transpose</strong>
</p>
<p>
<code>matrix#transpose()</code>
</p>
<p>
Returns a transpose matrix.
</p>
<h2><span class="caption-index-2">6.21</span><a name="caption-6-21"></a>operator Class</h2>
<h3><span class="caption-index-3">6.21.1</span><a name="caption-6-21-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
operator#symbol</code>
</td>
<td>
<code>
symbol</code>
</td>
<td>
R</td>

<td>
Operator symbol.</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.21.2</span><a name="caption-6-21-2"></a>Methods</h3>
<p>
<strong>operator</strong>
</p>
<p>
<code>operator(op:symbol):map {block?}</code>
</p>
<p>
Returns an operator object
</p>
<p>
<strong>operator#assign</strong>
</p>
<p>
<code>operator#assign(type_l:expr, type_r?:expr):map:void {block}</code>
</p>
<p>
<strong>operator#entries</strong>
</p>
<p>
<code>operator#entries(type?:symbol)</code>
</p>
<h2><span class="caption-index-2">6.22</span><a name="caption-6-22"></a>palette Class</h2>
<h3><span class="caption-index-3">6.22.1</span><a name="caption-6-22-1"></a>Methods</h3>
<p>
<strong>palette</strong>
</p>
<p>
<code>palette(type) {block?}</code>
</p>
<p>
Creates a palette of the specified type. type is a number of palette size or one of symbols: <code>basic,</code>win256 and <code>websafe.</code>
</p>
<p>
<strong>palette#each</strong>
</p>
<p>
<code>palette#each() {block?}</code>
</p>
<p>
Creates an iterator that iterates each element in the palette. If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code> Block parameter format: <code>|value, idx:number|</code></li>
</ul>
<p>
<strong>palette#nearest</strong>
</p>
<p>
<code>palette#nearest(color:color):map:[index]</code>
</p>
<p>
Returns an index of the nearest entry with the specified color.
</p>
<p>
<strong>palette#shrink</strong>
</p>
<p>
<code>palette#shrink():reduce:[align]</code>
</p>
<p>
Shrinks the size of the palette to a number powered by two that is enough to contain unique entries. The ordef of existing entries will be kept intact.
</p>
<p>
<strong>palette#updateby</strong>
</p>
<p>
<code>palette#updateby(image_or_palette):reduce:[align,shrink]</code>
</p>
<p>
Updates palette entries according to color data in an image or a palette. The order of existing entries will be kept intact. If attribute shrink is specified, the whole size will be shrinked to a number powered by two that is enough to contain unique entries.
</p>
<h2><span class="caption-index-2">6.23</span><a name="caption-6-23"></a>pointer Class</h2>
<h3><span class="caption-index-3">6.23.1</span><a name="caption-6-23-1"></a>Methods</h3>
<p>
<strong>pointer#forward</strong>
</p>
<p>
<code>pointer#forward(distance:number):reduce</code>
</p>
<p>
<strong>pointer#pack</strong>
</p>
<p>
<code>pointer#pack(format:string, value+):reduce:[stay]</code>
</p>
<p>
<strong>pointer#reset</strong>
</p>
<p>
<code>pointer#reset()</code>
</p>
<p>
<strong>pointer#unpack</strong>
</p>
<p>
<code>pointer#unpack(format:string, values*:number):[nil,stay]</code>
</p>
<p>
<strong>pointer#unpacks</strong>
</p>
<p>
<code>pointer#unpacks(format:string, values*:number)</code>
</p>
<h2><span class="caption-index-2">6.24</span><a name="caption-6-24"></a>semaphore Class</h2>
<h3><span class="caption-index-3">6.24.1</span><a name="caption-6-24-1"></a>Methods</h3>
<p>
<strong>semaphore</strong>
</p>
<p>
<code>semaphore()</code>
</p>
<p>
<strong>semaphore#release</strong>
</p>
<p>
<code>semaphore#release()</code>
</p>
<p>
Releases the owership of the semaphore that is grabbed by semaphore#wait().
</p>
<p>
<strong>semaphore#session</strong>
</p>
<p>
<code>semaphore#session() {block}</code>
</p>
<p>
Forms a critical session by grabbing the semaphore's ownership, executing the block and releasing that ownership. It internally proccesses the same job as semaphore#wait() and semaphore#release() before and after the block execution
</p>
<p>
<strong>semaphore#wait</strong>
</p>
<p>
<code>semaphore#wait()</code>
</p>
<p>
Watis for the semaphore being released by other threads, and ghen grabs that ownership.
</p>
<h2><span class="caption-index-2">6.25</span><a name="caption-6-25"></a>stream Class</h2>
<h3><span class="caption-index-3">6.25.1</span><a name="caption-6-25-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
stream#stat</code>
</td>
<td>
<code>
object</code>
</td>
<td>
R</td>

<td>
Status of the stream.</td>
</tr>


<tr>
<td>
<code>
stream#name</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
Name of the stream.</td>
</tr>


<tr>
<td>
<code>
stream#identifier</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R</td>

<td>
Identifier of the stream.</td>
</tr>


<tr>
<td>
<code>
stream#readable</code>
</td>
<td>
<code>
boolean</code>
</td>
<td>
R</td>

<td>
Indicates whether the stream is readable.</td>
</tr>


<tr>
<td>
<code>
stream#writable</code>
</td>
<td>
<code>
boolean</code>
</td>
<td>
R</td>

<td>
Indicates whether the stream is writable.</td>
</tr>


<tr>
<td>
<code>
stream#codec</code>
</td>
<td>
<code>
codec</code>
</td>
<td>
R</td>

<td>
`codec` instance associated with the stream.</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.25.2</span><a name="caption-6-25-2"></a>Methods</h3>
<p>
<strong>open</strong>
</p>
<p>
<code>open(pathname:string, mode?:string, codec?:codec):map {block?}</code>
</p>
<p>
<strong>stream</strong>
</p>
<p>
<code>stream(pathname:string, mode?:string, codec?:codec):map {block?}</code>
</p>
<p>
<strong>readlines</strong>
</p>
<p>
<code>readlines(stream?:stream:r):[chop] {block?}</code>
</p>
<p>
<strong>stream#addcr</strong>
</p>
<p>
<code>stream#addcr(flag?:boolean):reduce</code>
</p>
<p>
<strong>stream#close</strong>
</p>
<p>
<code>stream#close():void</code>
</p>
<p>
<strong>stream#compare</strong>
</p>
<p>
<code>stream#compare(stream:stream:r):map</code>
</p>
<p>
<strong>stream.copy</strong>
</p>
<p>
<code>stream.copy(src:stream:r, dst:stream:w, bytesunit:number =&gt; 65536):static:map:void:[finalize] {block?}</code>
</p>
<p>
<strong>stream#copyfrom</strong>
</p>
<p>
<code>stream#copyfrom(stream:stream:r, bytesunit:number =&gt; 65536):map:reduce:[finalize] {block?}</code>
</p>
<p>
<strong>stream#copyto</strong>
</p>
<p>
<code>stream#copyto(stream:stream:w, bytesunit:number =&gt; 65536):map:reduce:[finalize] {block?}</code>
</p>
<p>
<strong>stream#delcr</strong>
</p>
<p>
<code>stream#delcr(flag?:boolean):reduce</code>
</p>
<p>
<strong>stream#deserialize</strong>
</p>
<p>
<code>stream#deserialize()</code>
</p>
<p>
<strong>stream#flush</strong>
</p>
<p>
<code>stream#flush():void</code>
</p>
<p>
<strong>stream#peek</strong>
</p>
<p>
<code>stream#peek(len?:number)</code>
</p>
<p>
<strong>stream#print</strong>
</p>
<p>
<code>stream#print(values*):map:void</code>
</p>
<p>
<strong>stream#printf</strong>
</p>
<p>
<code>stream#printf(format:string, values*):map:void</code>
</p>
<p>
<strong>stream#println</strong>
</p>
<p>
<code>stream#println(values*):map:void</code>
</p>
<p>
<strong>stream#read</strong>
</p>
<p>
<code>stream#read(len?:number)</code>
</p>
<p>
<strong>stream#readchar</strong>
</p>
<p>
<code>stream#readchar()</code>
</p>
<p>
<strong>stream#readline</strong>
</p>
<p>
<code>stream#readline():[chop]</code>
</p>
<p>
<strong>stream#readlines</strong>
</p>
<p>
<code>stream#readlines(nlines?:number):[chop] {block?}</code>
</p>
<p>
<strong>stream#readtext</strong>
</p>
<p>
<code>stream#readtext()</code>
</p>
<p>
<strong>stream#seek</strong>
</p>
<p>
<code>stream#seek(offset:number, origin?:symbol):reduce</code>
</p>
<p>
<strong>stream#serialize</strong>
</p>
<p>
<code>stream#serialize(value):void</code>
</p>
<p>
<strong>stream#setcodec</strong>
</p>
<p>
<code>stream#setcodec(codec:codec:nil):reduce</code>
</p>
<p>
<strong>stream#tell</strong>
</p>
<p>
<code>stream#tell()</code>
</p>
<p>
<strong>stream#write</strong>
</p>
<p>
<code>stream#write(buff:binary, len?:number):reduce</code>
</p>
<h2><span class="caption-index-2">6.26</span><a name="caption-6-26"></a>suffixmgr Class</h2>
<p>
The <code>suffixmgr</code> class provides measures to access suffix managers that are responsible to handle suffix symbols appended to number or string literals.
</p>
<p>
Below is an example to register a suffix <code>X</code> that converts a string into upper case after being appended to a string literal:
</p>
<pre><code>suffixmgr(`string).assign(`X) {|body| body.upper()}
</code></pre>
<p>
You can use that suffix like below:
</p>
<pre><code>'hello world'X
</code></pre>
<h3><span class="caption-index-3">6.26.1</span><a name="caption-6-26-1"></a>Methods</h3>
<p>
<strong>suffixmgr</strong>
</p>
<p>
<code>suffixmgr(type:symbol) {block?}</code>
</p>
<p>
Creates a reference to one of two suffix managers, number and string.
</p>
<ul>
<li>The number suffix manager works with number literals.</li>
<li>The string suffix manager works with string literals.</li>
</ul>
<p>
Specify the argument <code>type</code> with a symbol <code>`number</code> for a number suffix manager and <code>`string</code> for a string suffix manager.
</p>
<p>
<strong>suffixmgr#assign</strong>
</p>
<p>
<code>suffixmgr#assign(suffix:symbol):void:[overwrite] {block}</code>
</p>
<p>
Assigns a procedure to a specified symbol in the suffix manager. The procedure is provided by the <code>block</code> that takes a block parameter <code>|value|</code> where <code>value</code> comes from the preceded literal.
</p>
<p>
An error occurs if the same suffix symbol has already been assigned. Specifying <code>:overwrite</code> attribute will forcibly overwrite an existing assignment.
</p>
<h2><span class="caption-index-2">6.27</span><a name="caption-6-27"></a>template Class</h2>
<h3><span class="caption-index-3">6.27.1</span><a name="caption-6-27-1"></a>Methods</h3>
<p>
<strong>template</strong>
</p>
<p>
<code>template(src?:stream:r):map:[lasteol,noindent] {block?}</code>
</p>
<p>
<strong>template#block</strong>
</p>
<p>
<code>template#block(symbol:symbol):void {block}</code>
</p>
<p>
<strong>template#call</strong>
</p>
<p>
<code>template#call(symbol:symbol, args*):void</code>
</p>
<p>
<strong>template#def</strong>
</p>
<p>
<code>template#def(symbol:symbol, `args*):void {block}</code>
</p>
<p>
<strong>template#embed</strong>
</p>
<p>
<code>template#embed(template):void</code>
</p>
<p>
<strong>template#extends</strong>
</p>
<p>
<code>template#extends(super:template):void</code>
</p>
<p>
<strong>template#parse</strong>
</p>
<p>
<code>template#parse(str:string):void:[lasteol,noindent]</code>
</p>
<p>
<strong>template#read</strong>
</p>
<p>
<code>template#read(src:stream:r):void:[lasteol,noindent]</code>
</p>
<p>
<strong>template#render</strong>
</p>
<p>
<code>template#render(dst?:stream:w)</code>
</p>
<p>
<strong>template#super</strong>
</p>
<p>
<code>template#super(super):void</code>
</p>
<p>
<strong>template#_R_block</strong>
</p>
<p>
<code>template#_R_block(symbol:symbol):void</code>
</p>
<p>
<strong>template#_R_call</strong>
</p>
<p>
<code>template#_R_call(symbol:symbol, args*):void</code>
</p>
<p>
<strong>template#_R_def</strong>
</p>
<p>
<code>template#_R_def(symbol:symbol, `args*):void</code>
</p>
<p>
<strong>template#_R_embed</strong>
</p>
<p>
<code>template#_R_embed(template:template):void</code>
</p>
<p>
<strong>template#_R_extends</strong>
</p>
<p>
<code>template#_R_extends(super):void:[lasteol,noindent]</code>
</p>
<p>
<strong>template#_R_super</strong>
</p>
<p>
<code>template#_R_super(symbol:symbol):void</code>
</p>
<h2><span class="caption-index-2">6.28</span><a name="caption-6-28"></a>timedelta Class</h2>
<h3><span class="caption-index-3">6.28.1</span><a name="caption-6-28-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
timedelta#days</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
timedelta#secs</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
timedelta#usec</code>
</td>
<td>
<code>
number</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.28.2</span><a name="caption-6-28-2"></a>Methods</h3>
<p>
<strong>timedelta</strong>
</p>
<p>
<code>timedelta(days:number =&gt; 0, secs:number =&gt; 0, usecs:number =&gt; 0):map {block?}</code>
</p>
<p>
Returns a timedelta instance with specified values. The instance actually holds properties of days, secs and usecs.
</p>
<h2><span class="caption-index-2">6.29</span><a name="caption-6-29"></a>uri Class</h2>
<h3><span class="caption-index-3">6.29.1</span><a name="caption-6-29-1"></a>Properties</h3>
<p>
<table>

<tr>
<th>
Property</th>
<th>
Type</th>
<th>
R/W</th>
<th>
Explanation</th>
</tr>


<tr>
<td>
<code>
uri#scheme</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
uri#user</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
uri#password</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
uri#host</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
uri#port</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
uri#urlpath</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


<tr>
<td>
<code>
uri#misc</code>
</td>
<td>
<code>
string</code>
</td>
<td>
R/W</td>

<td>
</td>
</tr>


</table>

</p>
<h3><span class="caption-index-3">6.29.2</span><a name="caption-6-29-2"></a>Methods</h3>
<p>
<strong>uri</strong>
</p>
<p>
<code>uri(str?:string):map {block?}</code>
</p>
<p>
<strong>uri#getfragment</strong>
</p>
<p>
<code>uri#getfragment()</code>
</p>
<p>
<strong>uri#getpath</strong>
</p>
<p>
<code>uri#getpath()</code>
</p>
<p>
<strong>uri#getquery</strong>
</p>
<p>
<code>uri#getquery()</code>
</p>
<p>
<strong>uri.parsequery</strong>
</p>
<p>
<code>uri.parsequery(query:string):static:map</code>
</p>
<h1><span class="caption-index-1">7</span><a name="caption-7"></a>base64 Module</h1>
<p>
The <code>base64</code> module provides measures to read/write text stream that is formatted in base64 format.
</p>
<h2><span class="caption-index-2">7.1</span><a name="caption-7-1"></a>Module Functions</h2>
<p>
<strong>base64.decode</strong>
</p>
<p>
<code>base64.decode(stream:stream:r) {block?}</code>
</p>
<p>
Reads text stream that is formatted in base64 and returns the decoded result in binary.
</p>
<p>
If <code>block</code> is specified, it would be evaluated with block parameter <code>|data:binary|</code>, where <code>data</code> is the created binary instance.
</p>
<p>
<strong>base64.encode</strong>
</p>
<p>
<code>base64.encode(stream:stream:r, linelen:number:nil =&gt; 76) {block?}</code>
</p>
<p>
Encodes content of the stream into base64 format and returns the result in binary.
</p>
<p>
If <code>block</code> is specified, it would be evaluated with block parameter <code>|data:binary|</code>, where <code>data</code> is the created binary instance.
</p>
<p>
<strong>base64.reader</strong>
</p>
<p>
<code>base64.reader(stream:stream:r) {block?}</code>
</p>
<p>
Creates a stream instance that reads data formatted in base64 from <code>stream</code>.
</p>
<p>
If <code>block</code> is specified, it would be evaluated with block parameter <code>|s:stream|</code>, where <code>s</code> is the created stream instance.
</p>
<p>
<strong>base64.writer</strong>
</p>
<p>
<code>base64.writer(stream:stream:w, linelen:number:nil =&gt; 76) {block?}</code>
</p>
<p>
Creates a stream instance that encodes data to base64 format and writes it to the <code>stream</code>.
</p>
<p>
The number of characters per line is specified by an argument <code>linelen</code>. If omitted, that is 76.
</p>
<p>
If <code>block</code> is specified, it would be evaluated with block parameter <code>|s:stream|</code>, where <code>s</code> is the created stream instance.
</p>
<h2><span class="caption-index-2">7.2</span><a name="caption-7-2"></a>Methods Added to stream Class</h2>
<p>
After importing <code>base64</code> module, <code>stream</code> class is extended with methods that are described here.
</p>
<p>
<strong>stream#reader@base64</strong>
</p>
<p>
<code>stream#reader@base64() {block?}</code>
</p>
<p>
Creates a stream instance that reads data formatted in base64 from the target stream instance.
</p>
<p>
If <code>block</code> is specified, it would be evaluated with block parameter <code>|s:stream|</code>, where <code>s</code> is the created stream instance.
</p>
<p>
<strong>stream#writer@base64</strong>
</p>
<p>
<code>stream#writer@base64(linelen:number:nil =&gt; 76) {block?}</code>
</p>
<p>
Creates a stream instance that encodes data to base64 format and writes it to the target stream instance.
</p>
<p>
The number of characters per line is specified by an argument <code>linelen</code>. If omitted, that is 76.
</p>
<p>
If <code>block</code> is specified, it would be evaluated with block parameter <code>|s:stream|</code>, where <code>s</code> is the created stream instance.
</p>
<h1><span class="caption-index-1">8</span><a name="caption-8"></a>bmp Module</h1>
<p>
The <code>bmp</code> module provides measures to read/write image data in Microsoft BMP format. To utilize it, import the <code>bmp</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read a BMP file:
</p>
<pre><code>import(bmp)
img = image('foo.bmp')
</code></pre>
<h2><span class="caption-index-2">8.1</span><a name="caption-8-1"></a>Exntension of Function's Capability</h2>
<p>
This module extends the capability of function <code>image()</code> and instance method <code>image#write()</code> so that they can read/write BMP files.
</p>
<p>
When function <code>image()</code> is provided with a stream that satisfies the following conditions, it would recognize the stream as a BMP file.
</p>
<ul>
<li>The identifier of the stream ends with a suffix <code>.bmp</code>.</li>
<li>The stream data begins with a byte sequence "<code>BM</code>".</li>
</ul>
<p>
When instance method <code>image#write()</code> is provided with a stream that satisfies the following condition, it would write image data in BMP format.
</p>
<ul>
<li>The identifier of the stream ends with a suffix <code>.bmp</code>.</li>
</ul>
<h2><span class="caption-index-2">8.2</span><a name="caption-8-2"></a>Methods Added to image Class</h2>
<p>
<strong>image#read@bmp</strong>
</p>
<p>
<code>image#read@bmp(stream:stream:r):reduce</code>
</p>
<p>
Reads an BMP image from a stream.
</p>
<p>
<strong>image#write@bmp</strong>
</p>
<p>
<code>image#write@bmp(stream:stream:w):reduce</code>
</p>
<p>
Writes a BMP image to a stream.
</p>
<h1><span class="caption-index-1">9</span><a name="caption-9"></a>bzip2 Module</h1>
<p>
The <code>bzip2</code> module provices measures to read/write BZIP2 files. To utilize it, import the <code>bzip2</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read data from a BZIP2 file and write its uncompressed data to another file.
</p>
<pre><code>import(bzip2)
bzip2.reader('foo.dat.bz2').copyto('foo.dat')
</code></pre>
<p>
Below is an example to read data from a file and write its compressed data to a BZIP2 file.
</p>
<pre><code>import(bzip2)
bzip2.writer('foo.dat.bz2').copyfrom('foo.dat')
</code></pre>
<h2><span class="caption-index-2">9.1</span><a name="caption-9-1"></a>Module Functions</h2>
<p>
<strong>bzip2.reader</strong>
</p>
<p>
<code>bzip2.reader(stream:stream:r) {block?}</code>
</p>
<p>
<strong>bzip2.writer</strong>
</p>
<p>
<code>bzip2.writer(stream:stream:w, blockSize100k?:number) {block?}</code>
</p>
<h2><span class="caption-index-2">9.2</span><a name="caption-9-2"></a>Methods Added to stream Class</h2>
<p>
<strong>stream#reader@bzip2</strong>
</p>
<p>
<code>stream#reader@bzip2() {block?}</code>
</p>
<p>
<strong>stream#writer@bzip2</strong>
</p>
<p>
<code>stream#writer@bzip2(blockSize100k?:number) {block?}</code>
</p>
<h1><span class="caption-index-1">10</span><a name="caption-10"></a>cairo Module</h1>
<pre><code>
</code></pre>
<p>
The <code>cairo</code> module provides methods to draw 2-D graphics using Cairo library. Official site of Cairo is <a href="http://cairographics.org/">http://cairographics.org/</a>.
</p>
<h2><span class="caption-index-2">10.1</span><a name="caption-10-1"></a>Drawing</h2>
<h3><span class="caption-index-3">10.1.1</span><a name="caption-10-1-1"></a>cairo_t - The cairo drawing context</h3>
<p>
<strong>cairo.context#status</strong>
</p>
<p>
<code>cairo.context#status()</code>
</p>
<p>
Checks whether an error has previously occurred for this context.
</p>
<p>
<strong>cairo.context#save</strong>
</p>
<p>
<code>cairo.context#save():reduce {block?}</code>
</p>
<p>
Makes a copy of the current state of cr and saves it on an internal stack of saved states for cr. When cairo.context#restore() is called, cr will be restored to the saved state. Multiple calls to cairo.context#save() and cairo.context#restore() can be nested; each call to cairo.context#restore() restores the state from the matching paired cairo.context#save().
</p>
<p>
It isn't necessary to clear all saved states before a cairo<em>t is freed.</em>If the reference count of a cairo<em>t drops to zero in response to a call to cairo.context#destroy(),</em>any saved states will be freed along with the cairo<em>t.</em>
</p>
<p>
<strong>cairo.context#restore</strong>
</p>
<p>
<code>cairo.context#restore():reduce</code>
</p>
<p>
Restores cr to the state saved by a preceding call to cairo.context#save() and removes that state from the stack of saved states.
</p>
<p>
<strong>cairo.context#get_target</strong>
</p>
<p>
<code>cairo.context#get_target()</code>
</p>
<p>
Gets the target surface for the cairo context as passed to cairo.context constructor.
</p>
<p>
<strong>cairo.context#push_group</strong>
</p>
<p>
<code>cairo.context#push_group():reduce</code>
</p>
<p>
Temporarily redirects drawing to an intermediate surface known as a group. The redirection lasts until the group is completed by a call to cairo.context#pop<em>group() or cairo.context#pop</em>group<em>to</em>source(). These calls provide the result of any drawing to the group as a pattern, (either as an explicit object, or set as the source pattern).
</p>
<p>
This group functionality can be convenient for performing intermediate compositing. One common use of a group is to render objects as opaque within the group, (so that they occlude each other), and then blend the result with translucence onto the destination.
</p>
<p>
Groups can be nested arbitrarily deep by making balanced calls to cairo.context#push<em>group()/cairo.context#pop</em>group(). Each call pushes/pops the new target group onto/from a stack.
</p>
<p>
The cairo.context#push<em>group() function calls cairo</em>save() so that any changes to the graphics state will not be visible outside the group, (the pop<em>group functions call cairo</em>restore()).
</p>
<p>
By default the intermediate group will have a content type of cairo.CONTENT<em>COLOR</em>ALPHA. Other content types can be chosen for the group by using cairo.context#push<em>group</em>with<em>content() instead.</em>
</p>
<p>
As an example, here is how one might fill and stroke a path with translucence, but without any portion of the fill being visible under the stroke:
</p>
<p>
<strong>cairo.context#push_group_with_content</strong>
</p>
<p>
<code>cairo.context#push_group_with_content(content:number):reduce</code>
</p>
<p>
Temporarily redirects drawing to an intermediate surface known as a group. The redirection lasts until the group is completed by a call to cairo.context#pop<em>group() or cairo.context#pop</em>group<em>to</em>source(). These calls provide the result of any drawing to the group as a pattern, (either as an explicit object, or set as the source pattern).
</p>
<p>
The group will have a content type of content. The ability to control this content type is the only distinction between this function and cairo.context#push<em>group()</em>which you should see for a more detailed description of group rendering.
</p>
<p>
<strong>cairo.context#pop_group</strong>
</p>
<p>
<code>cairo.context#pop_group()</code>
</p>
<p>
Terminates the redirection begun by a call to cairo.context#push<em>group() or cairo.context#push</em>group<em>with</em>content() and returns a new pattern containing the results of all drawing operations performed to the group.
</p>
<p>
The cairo.context#pop<em>group() function calls cairo</em>restore(), (balancing a call to cairo<em>save() by the push</em>group function), so that any changes to the graphics state will not be visible outside the group.
</p>
<p>
<strong>cairo.context#pop_group_to_source</strong>
</p>
<p>
<code>cairo.context#pop_group_to_source():reduce</code>
</p>
<p>
Terminates the redirection begun by a call to cairo.context#push<em>group() or cairo.context#push</em>group<em>with</em>content() and installs the resulting pattern as the source pattern in the given cairo context.
</p>
<p>
The cairo.context#pop<em>group() function calls cairo</em>restore(), (balancing a call to cairo<em>save() by the push</em>group function), so that any changes to the graphics state will not be visible outside the group.
</p>
<p>
<strong>cairo.context#get_group_target</strong>
</p>
<p>
<code>cairo.context#get_group_target()</code>
</p>
<p>
Gets the current destination surface for the context. This is either the original target surface as passed to cairo.context constructor or the target surface for the current group as started by the most recent call to cairo.context#push<em>group() or cairo.context#push</em>group<em>with</em>content().
</p>
<p>
<strong>cairo.context#set_source_rgb</strong>
</p>
<p>
<code>cairo.context#set_source_rgb(red:number, green:number, blue:number):reduce</code>
</p>
<p>
Sets the source pattern within cr to an opaque color. This opaque color will then be used for any subsequent drawing operation until a new source pattern is set.
</p>
<p>
The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.
</p>
<p>
The default source pattern is opaque black, (that is, it is equivalent to cr.set<em>source</em>rgb(0.0, 0.0, 0.0)).
</p>
<p>
<strong>cairo.context#set_source_rgba</strong>
</p>
<p>
<code>cairo.context#set_source_rgba(red:number, green:number, blue:number, alpha:number):reduce</code>
</p>
<p>
Sets the source pattern within cr to a translucent color. This color will then be used for any subsequent drawing operation until a new source pattern is set.
</p>
<p>
The color and alpha components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.
</p>
<p>
The default source pattern is opaque black, (that is, it is equivalent to cr.set<em>source</em>rgba(0.0, 0.0, 0.0, 1.0)).
</p>
<p>
<strong>cairo.context#set_source</strong>
</p>
<p>
<code>cairo.context#set_source(source:cairo.pattern):reduce</code>
</p>
<p>
Sets the source pattern within cr to source. This pattern will then be used for any subsequent drawing operation until a new source pattern is set.
</p>
<p>
Note: The pattern's transformation matrix will be locked to the user space in effect at the time of cairo.context#set<em>source().</em>This means that further modifications of the current transformation matrix will not affect the source pattern. See cairo.pattern#set<em>matrix().</em>
</p>
<p>
The default source pattern is a solid pattern that is opaque black, (that is, it is equivalent to cr.set<em>source</em>rgb(0.0, 0.0, 0.0)).
</p>
<p>
<strong>cairo.context#set_source_surface</strong>
</p>
<p>
<code>cairo.context#set_source_surface(surface:cairo.surface, x:number, y:number):reduce</code>
</p>
<p>
This is a convenience function for creating a pattern from surface and setting it as the source in cr with cairo.context#set<em>source().</em>
</p>
<p>
The x and y parameters give the user-space coordinate at which the surface origin should appear. (The surface origin is its upper-left corner before any transformation has been applied.) The x and y parameters are negated and then set as translation values in the pattern matrix.
</p>
<p>
Other than the initial translation pattern matrix, as described above, all other pattern attributes, (such as its extend mode), are set to the default values as in cairo.pattern.create<em>for</em>surface(). The resulting pattern can be queried with cairo.context#get<em>source() so that these attributes can be modified if desired,</em>(eg. to create a repeating pattern with cairo.pattern#set<em>extend()).</em>
</p>
<p>
<strong>cairo.context#get_source</strong>
</p>
<p>
<code>cairo.context#get_source()</code>
</p>
<p>
Gets the current source pattern for cr.
</p>
<p>
<strong>cairo.context#set_antialias</strong>
</p>
<p>
<code>cairo.context#set_antialias(antialias:number):reduce</code>
</p>
<p>
Set the antialiasing mode of the rasterizer used for drawing shapes. This value is a hint, and a particular backend may or may not support a particular value. At the current time, no backend supports cairo.ANTIALIAS<em>SUBPIXEL when drawing shapes.</em>
</p>
<p>
Note that this option does not affect text rendering, instead see cairo.font<em>options#set</em>antialias().
</p>
<p>
<strong>cairo.context#get_antialias</strong>
</p>
<p>
<code>cairo.context#get_antialias()</code>
</p>
<p>
Gets the current shape antialiasing mode, as set by cairo.context#set<em>antialias().</em>
</p>
<p>
<strong>cairo.context#set_dash</strong>
</p>
<p>
<code>cairo.context#set_dash(dashes[]:number, offset:number):reduce</code>
</p>
<p>
Sets the dash pattern to be used by cairo.context#stroke(). A dash pattern is specified by dashes, an array of positive values. Each value provides the length of alternate "on" and "off" portions of the stroke. The offset specifies an offset into the pattern at which the stroke begins.
</p>
<p>
Each "on" segment will have caps applied as if the segment were a separate sub-path. In particular, it is valid to use an "on" length of 0.0 with cairo.LINE<em>CAP</em>ROUND or cairo.LINE<em>CAP</em>SQUARE in order to distributed dots or squares along a path.
</p>
<p>
Note: The length values are in user-space units as evaluated at the time of stroking. This is not necessarily the same as the user space at the time of cairo.context#set<em>dash().</em>
</p>
<p>
If length of dashes is 0 dashing is disabled.
</p>
<p>
If length of dashes is 1 a symmetric pattern is assumed with alternating on and off portions of the size specified by the single value in dashes.
</p>
<p>
If any value in dashes is negative, or if all values are 0, then cr will be put into an error state with a status of cairo.STATUS<em>INVALID</em>DASH.
</p>
<p>
<strong>cairo.context#get_dash</strong>
</p>
<p>
<code>cairo.context#get_dash()</code>
</p>
<p>
Gets the current dash array.
</p>
<p>
<strong>cairo.context#set_fill_rule</strong>
</p>
<p>
<code>cairo.context#set_fill_rule(fill_rule:number):reduce</code>
</p>
<p>
Set the current fill rule within the cairo context. The fill rule is used to determine which regions are inside or outside a complex (potentially self-intersecting) path. The current fill rule affects both cairo.context#fill() and cairo.context#clip(). See cairo<em>fill</em>rule<em>t for details on the semantics of each available fill rule.</em>
</p>
<p>
The default fill rule is cairo.FILL<em>RULE</em>WINDING.
</p>
<p>
<strong>cairo.context#get_fill_rule</strong>
</p>
<p>
<code>cairo.context#get_fill_rule()</code>
</p>
<p>
Gets the current fill rule, as set by cairo.context#set<em>fill</em>rule().
</p>
<p>
<strong>cairo.context#set_line_cap</strong>
</p>
<p>
<code>cairo.context#set_line_cap(line_cap:number):reduce</code>
</p>
<p>
Sets the current line cap style within the cairo context. See cairo<em>line</em>cap<em>t for details about how the available line cap styles are drawn.</em>
</p>
<p>
As with the other stroke parameters, the current line cap style is examined by cairo.context#stroke(), cairo.context#stroke<em>extents(),</em>and cairo.context#stroke<em>to</em>path(), but does not have any effect during path construction.
</p>
<p>
The default line cap style is cairo.LINE<em>CAP</em>BUTT.
</p>
<p>
<strong>cairo.context#get_line_cap</strong>
</p>
<p>
<code>cairo.context#get_line_cap()</code>
</p>
<p>
Gets the current line cap style, as set by cairo.context#set<em>line</em>cap().
</p>
<p>
<strong>cairo.context#set_line_join</strong>
</p>
<p>
<code>cairo.context#set_line_join(line_join:number):reduce</code>
</p>
<p>
Sets the current line join style within the cairo context. See cairo<em>line</em>join<em>t for details about how the available line join styles are drawn.</em>
</p>
<p>
As with the other stroke parameters, the current line join style is examined by cairo.context#stroke(), cairo.context#stroke<em>extents(),</em>and cairo.context#stroke<em>to</em>path(), but does not have any effect during path construction.
</p>
<p>
The default line join style is cairo.LINE<em>JOIN</em>MITER.
</p>
<p>
<strong>cairo.context#get_line_join</strong>
</p>
<p>
<code>cairo.context#get_line_join()</code>
</p>
<p>
Gets the current line join style, as set by cairo.context#set<em>line</em>join().
</p>
<p>
<strong>cairo.context#set_line_width</strong>
</p>
<p>
<code>cairo.context#set_line_width(width:number):reduce</code>
</p>
<p>
Sets the current line width within the cairo context. The line width value specifies the diameter of a pen that is circular in user space, (though device-space pen may be an ellipse in general due to scaling/shear/rotation of the CTM).
</p>
<p>
Note: When the description above refers to user space and CTM it refers to the user space and CTM in effect at the time of the stroking operation, not the user space and CTM in effect at the time of the call to cairo.context#set<em>line</em>width(). The simplest usage makes both of these spaces identical. That is, if there is no change to the CTM between a call to cairo.context#set<em>line</em>width() and the stroking operation, then one can just pass user-space values to cairo.context#set<em>line</em>width() and ignore this note.
</p>
<p>
As with the other stroke parameters, the current line width is examined by cairo.context#stroke(), cairo.context#stroke<em>extents(),</em>and cairo.context#stroke<em>to</em>path(), but does not have any effect during path construction.
</p>
<p>
The default line width value is 2.0.
</p>
<p>
<strong>cairo.context#get_line_width</strong>
</p>
<p>
<code>cairo.context#get_line_width()</code>
</p>
<p>
This function returns the current line width value exactly as set by cairo.context#set<em>line</em>width(). Note that the value is unchanged even if the CTM has changed between the calls to cairo.context#set<em>line</em>width() and cairo.context#get<em>line</em>width().
</p>
<p>
<strong>cairo.context#set_miter_limit</strong>
</p>
<p>
<code>cairo.context#set_miter_limit(limit:number):reduce</code>
</p>
<p>
Sets the current miter limit within the cairo context.
</p>
<p>
If the current line join style is set to cairo.LINE<em>JOIN</em>MITER (see cairo<em>set</em>line<em>join()), the miter limit is used to determine whether the lines should be joined with a bevel instead of a miter.</em>Cairo divides the length of the miter by the line width. If the result is greater than the miter limit, the style is converted to a bevel.
</p>
<p>
As with the other stroke parameters, the current line miter limit is examined by cairo.context#stroke(), cairo.context#stroke<em>extents(),</em>and cairo.context#stroke<em>to</em>path(), but does not have any effect during path construction.
</p>
<p>
The default miter limit value is 10.0, which will convert joins with interior angles less than 11 degrees to bevels instead of miters. For reference, a miter limit of 2.0 makes the miter cutoff at 60 degrees, and a miter limit of 1.414 makes the cutoff at 90 degrees.
</p>
<p>
A miter limit for a desired angle can be computed as: miter limit = 1/sin(angle/2)
</p>
<p>
<strong>cairo.context#get_miter_limit</strong>
</p>
<p>
<code>cairo.context#get_miter_limit()</code>
</p>
<p>
Gets the current miter limit, as set by cairo.context#set<em>miter</em>limit().
</p>
<p>
<strong>cairo.context#set_operator</strong>
</p>
<p>
<code>cairo.context#set_operator(op:number):reduce</code>
</p>
<p>
Sets the compositing operator to be used for all drawing operations. See cairo<em>operator</em>t for details on the semantics of each available compositing operator.
</p>
<p>
The default operator is cairo.OPERATOR<em>OVER.</em>
</p>
<p>
<strong>cairo.context#get_operator</strong>
</p>
<p>
<code>cairo.context#get_operator()</code>
</p>
<p>
Gets the current compositing operator for a cairo context.
</p>
<p>
<strong>cairo.context#set_tolerance</strong>
</p>
<p>
<code>cairo.context#set_tolerance(tolerance:number):reduce</code>
</p>
<p>
Sets the tolerance used when converting paths into trapezoids. Curved segments of the path will be subdivided until the maximum deviation between the original path and the polygonal approximation is less than tolerance. The default value is 0.1. A larger value will give better performance, a smaller value, better appearance. (Reducing the value from the default value of 0.1 is unlikely to improve appearance significantly.) The accuracy of paths within Cairo is limited by the precision of its internal arithmetic, and the prescribed tolerance is restricted to the smallest representable internal value.
</p>
<p>
<strong>cairo.context#get_tolerance</strong>
</p>
<p>
<code>cairo.context#get_tolerance()</code>
</p>
<p>
Gets the current tolerance value, as set by cairo.context#set<em>tolerance().</em>
</p>
<p>
<strong>cairo.context#clip</strong>
</p>
<p>
<code>cairo.context#clip():reduce</code>
</p>
<p>
Establishes a new clip region by intersecting the current clip region with the current path as it would be filled by cairo.context#fill() and according to the current fill rule (see cairo.context#set<em>fill</em>rule()).
</p>
<p>
After cairo.context#clip(), the current path will be cleared from the cairo context.
</p>
<p>
The current clip region affects all drawing operations by effectively masking out any changes to the surface that are outside the current clip region.
</p>
<p>
Calling cairo.context#clip() can only make the clip region smaller, never larger. But the current clip is part of the graphics state, so a temporary restriction of the clip region can be achieved by calling cairo.context#clip() within a cairo.context#save()/cairo.context#restore() pair. The only other means of increasing the size of the clip region is cairo.context#reset<em>clip().</em>
</p>
<p>
<strong>cairo.context#clip_preserve</strong>
</p>
<p>
<code>cairo.context#clip_preserve():reduce</code>
</p>
<p>
Establishes a new clip region by intersecting the current clip region with the current path as it would be filled by cairo.context#fill() and according to the current fill rule (see cairo.context#set<em>fill</em>rule()). Unlike cairo.context#clip(), cairo.context#clip<em>preserve() preserves the path within the cairo context.</em>
</p>
<p>
The current clip region affects all drawing operations by effectively masking out any changes to the surface that are outside the current clip region.
</p>
<p>
Calling cairo.context#clip<em>preserve() can only make the clip region smaller, never larger.</em>But the current clip is part of the graphics state, so a temporary restriction of the clip region can be achieved by calling cairo.context#clip<em>preserve()</em>within a cairo.context#save()/cairo.context#restore() pair. The only other means of increasing the size of the clip region is cairo.context#reset<em>clip().</em>
</p>
<p>
<strong>cairo.context#clip_extents</strong>
</p>
<p>
<code>cairo.context#clip_extents()</code>
</p>
<p>
Computes a bounding box in user coordinates covering the area inside the current clip.
</p>
<p>
<strong>cairo.context#in_clip</strong>
</p>
<p>
<code>cairo.context#in_clip(x:number, y:number)</code>
</p>
<p>
Tests whether the given point is inside the area that would be visible through the current clip, i.e. the area that would be filled by a cairo.context#paint() operation.
</p>
<p>
See cairo.context#clip(), and cairo.context#clip<em>preserve().</em>
</p>
<p>
<strong>cairo.context#reset_clip</strong>
</p>
<p>
<code>cairo.context#reset_clip():reduce</code>
</p>
<p>
Reset the current clip region to its original, unrestricted state. That is, set the clip region to an infinitely large shape containing the target surface. Equivalently, if infinity is too hard to grasp, one can imagine the clip region being reset to the exact bounds of the target surface.
</p>
<p>
Note that code meant to be reusable should not call cairo<em>reset</em>clip() as it will cause results unexpected by higher-level code which calls cairo.context#clip(). Consider using cairo.context#save() and cairo.context#restore() around cairo.context#clip() as a more robust means of temporarily restricting the clip region.
</p>
<p>
<strong>cairo.context#copy_clip_rectangle_list</strong>
</p>
<p>
<code>cairo.context#copy_clip_rectangle_list()</code>
</p>
<p>
Gets the current clip region as a list of rectangles in user coordinates.
</p>
<p>
The status in the list may be cairo.STATUS<em>CLIP</em>NOT<em>REPRESENTABLE</em>to indicate that the clip region cannot be represented as a list of user-space rectangles. The status may have other values to indicate other errors.
</p>
<p>
<strong>cairo.context#fill</strong>
</p>
<p>
<code>cairo.context#fill():reduce</code>
</p>
<p>
A drawing operator that fills the current path according to the current fill rule, (each sub-path is implicitly closed before being filled). After cairo.context#fill(), the current path will be cleared from the cairo context. See cairo.context#set<em>fill</em>rule() and cairo.context#fill<em>preserve().</em>
</p>
<p>
<strong>cairo.context#fill_preserve</strong>
</p>
<p>
<code>cairo.context#fill_preserve():reduce</code>
</p>
<p>
A drawing operator that fills the current path according to the current fill rule, (each sub-path is implicitly closed before being filled). Unlike cairo.context#fill(), cairo.context#fill<em>preserve() preserves the path within the cairo context.</em>
</p>
<p>
See cairo.context#set<em>fill</em>rule() and cairo.context#fill().
</p>
<p>
<strong>cairo.context#fill_extents</strong>
</p>
<p>
<code>cairo.context#fill_extents():reduce</code>
</p>
<p>
Computes a bounding box in user coordinates covering the area that would be affected, (the "inked" area), by a cairo.context#fill() operation given the current path and fill parameters. If the current path is empty, returns an empty rectangle ((0,0), (0,0)). Surface dimensions and clipping are not taken into account.
</p>
<p>
Contrast with cairo.context#path<em>extents(), which is similar,</em>but returns non-zero extents for some paths with no inked area, (such as a simple line segment).
</p>
<p>
Note that cairo.context#fill<em>extents() must necessarily do more work to compute the precise inked areas in light of the fill rule,</em>so cairo.context#path<em>extents() may be more desirable for sake of performance if the non-inked path extents are desired.</em>
</p>
<p>
See cairo.context#fill(), cairo.context#set<em>fill</em>rule() and cairo.context#fill<em>preserve().</em>
</p>
<p>
<strong>cairo.context#in_fill</strong>
</p>
<p>
<code>cairo.context#in_fill(x:number, y:number)</code>
</p>
<p>
Tests whether the given point is inside the area that would be affected by a cairo.context#fill() operation given the current path and filling parameters. Surface dimensions and clipping are not taken into account.
</p>
<p>
See cairo.context#fill(), cairo.context#set<em>fill</em>rule() and cairo.context#fill<em>preserve().</em>
</p>
<p>
<strong>cairo.context#mask</strong>
</p>
<p>
<code>cairo.context#mask(pattern:cairo.pattern):reduce</code>
</p>
<p>
A drawing operator that paints the current source using the alpha channel of pattern as a mask. (Opaque areas of pattern are painted with the source, transparent areas are not painted.)
</p>
<p>
<strong>cairo.context#mask_surface</strong>
</p>
<p>
<code>cairo.context#mask_surface(surface:cairo.surface, surface_x:number, surface_y:number):reduce</code>
</p>
<p>
A drawing operator that paints the current source using the alpha channel of surface as a mask. (Opaque areas of surface are painted with the source, transparent areas are not painted.)
</p>
<p>
<strong>cairo.context#paint</strong>
</p>
<p>
<code>cairo.context#paint():reduce</code>
</p>
<p>
A drawing operator that paints the current source everywhere within the current clip region.
</p>
<p>
<strong>cairo.context#paint_with_alpha</strong>
</p>
<p>
<code>cairo.context#paint_with_alpha(alpha:number):reduce</code>
</p>
<p>
A drawing operator that paints the current source everywhere within the current clip region using a mask of constant alpha value alpha. The effect is similar to cairo.context#paint(), but the drawing is faded out using the alpha value.
</p>
<p>
<strong>cairo.context#stroke</strong>
</p>
<p>
<code>cairo.context#stroke():reduce</code>
</p>
<p>
A drawing operator that strokes the current path according to the current line width, line join, line cap, and dash settings. After cairo.context#stroke(), the current path will be cleared from the cairo context. See cairo.context#set<em>line</em>width(), cairo.context#set<em>line</em>join(), cairo.context#set<em>line</em>cap(), cairo.context#set<em>dash(), and cairo.context#stroke</em>preserve().
</p>
<p>
Note: Degenerate segments and sub-paths are treated specially and provide a useful result. These can result in two different situations:
</p>
<ol>
<li>Zero-length "on" segments set in cairo.context#set<em>dash().</em> If the cap style is cairo.LINE<em>CAP</em>ROUND or cairo.LINE<em>CAP</em>SQUARE then these segments will be drawn as circular dots or squares respectively. In the case of cairo.LINE<em>CAP</em>SQUARE, the orientation of the squares is determined by the direction of the underlying path.</li>
<li>A sub-path created by cairo.context#move<em>to() followed by either a cairo.context#close</em>path() or one or more calls to cairo.context#line<em>to() to the same coordinate as the cairo.context#move</em>to(). If the cap style is cairo.LINE<em>CAP</em>ROUND then these sub-paths will be drawn as circular dots. Note that in the case of cairo.LINE<em>CAP</em>SQUARE a degenerate sub-path will not be drawn at all, (since the correct orientation is indeterminate).</li>
</ol>
<p>
In no case will a cap style of cairo.LINE<em>CAP</em>BUTT cause anything to be drawn in the case of either degenerate segments or sub-paths.
</p>
<p>
<strong>cairo.context#stroke_preserve</strong>
</p>
<p>
<code>cairo.context#stroke_preserve():reduce</code>
</p>
<p>
A drawing operator that strokes the current path according to the current line width, line join, line cap, and dash settings. Unlike cairo.context#stroke(), cairo.context#stroke<em>preserve() preserves the path within the cairo context.</em>
</p>
<p>
See cairo.context#set<em>line</em>width(), cairo.context#set<em>line</em>join(), cairo.context#set<em>line</em>cap(), cairo.context#set<em>dash(), and cairo.context#stroke</em>preserve().
</p>
<p>
<strong>cairo.context#stroke_extents</strong>
</p>
<p>
<code>cairo.context#stroke_extents()</code>
</p>
<p>
Computes a bounding box in user coordinates covering the area that would be affected, (the "inked" area), by a cairo.context#stroke() operation given the current path and stroke parameters. If the current path is empty, returns an empty rectangle ((0,0), (0,0)). Surface dimensions and clipping are not taken into account.
</p>
<p>
Note that if the line width is set to exactly zero, then cairo.context#stroke<em>extents() will return an empty rectangle.</em>Contrast with cairo.context#path<em>extents() which can be used to compute the non-empty bounds as the line width approaches zero.</em>
</p>
<p>
Note that cairo.context#stroke<em>extents() must necessarily do more work to compute the precise inked areas in light of the stroke parameters,</em>so cairo.context#path<em>extents() may be more desirable for sake of performance if non-inked path extents are desired.</em>
</p>
<p>
See cairo.context#stroke(), cairo.context#set<em>line</em>width(), cairo.context#set<em>line</em>join(), cairo.context#set<em>line</em>cap(), cairo.context#set<em>dash(), and cairo.context#stroke</em>preserve().
</p>
<p>
<strong>cairo.context#in_stroke</strong>
</p>
<p>
<code>cairo.context#in_stroke(x:number, y:number)</code>
</p>
<p>
Tests whether the given point is inside the area that would be affected by a cairo.context#stroke() operation given the current path and stroking parameters. Surface dimensions and clipping are not taken into account. See cairo.context#stroke(), cairo.context#set<em>line</em>width(), cairo.context#set<em>line</em>join(), cairo.context#set<em>line</em>cap(), cairo.context#<em>set</em>dash(), and cairo.context#stroke<em>preserve().</em>
</p>
<p>
<strong>cairo.context#copy_page</strong>
</p>
<p>
<code>cairo.context#copy_page():reduce</code>
</p>
<p>
Emits the current page for backends that support multiple pages, but doesn't clear it, so, the contents of the current page will be retained for the next page too. Use cairo.cairo#show<em>page() if you want to get an empty page after the emission.</em>
</p>
<p>
This is a convenience function that simply calls cairo.context#surface<em>copy</em>page() on cr's target.
</p>
<p>
<strong>cairo.context#show_page</strong>
</p>
<p>
<code>cairo.context#show_page():reduce</code>
</p>
<p>
Emits and clears the current page for backends that support multiple pages. Use cairo.context#copy<em>page() if you don't want to clear the page.</em>
</p>
<p>
This is a convenience function that simply calls cairo.context#surface<em>show</em>page() on cr's target.
</p>
<h3><span class="caption-index-3">10.1.2</span><a name="caption-10-1-2"></a>Paths - Creating paths and manipulating path data</h3>
<p>
<strong>cairo.context#copy_path</strong>
</p>
<p>
<code>cairo.context#copy_path()</code>
</p>
<p>
Creates a copy of the current path and returns it to the user as a cairo.path. See cairo<em>path</em>data<em>t for hints on how to iterate over the returned data structure.</em>
</p>
<p>
The result will have no data (data==NULL and num<em>data==0), if either of the following conditions hold:</em>
</p>
<ol>
<li>If there is insufficient memory to copy the path. In this case path-&gt;status will be set to cairo.STATUS<em>NO</em>MEMORY.</li>
<li>If cr is already in an error state. In this case path-&gt;status will contain the same status that would be returned by cairo.context#status().</li>
</ol>
<p>
<strong>cairo.context#copy_path_flat</strong>
</p>
<p>
<code>cairo.context#copy_path_flat()</code>
</p>
<p>
Gets a flattened copy of the current path and returns it to the user as a cairo.path. See cairo<em>path</em>data<em>t for hints on how to iterate over the returned data structure.</em>
</p>
<p>
This function is like cairo.context#copy<em>path() except that any curves in the path will be approximated with piecewise-linear approximations,</em>(accurate to within the current tolerance value). That is, the result is guaranteed to not have any elements of type cairo.PATH<em>CURVE</em>TO which will instead be replaced by a series of cairo.PATH<em>LINE</em>TO elements.
</p>
<p>
The result will have no data (data==NULL and num<em>data==0), if either of the following conditions hold:</em>
</p>
<ol>
<li>If there is insufficient memory to copy the path. In this case path-&gt;status will be set to cairo.STATUS<em>NO</em>MEMORY.</li>
<li>If cr is already in an error state. In this case path-&gt;status will contain the same status that would be returned by cairo.context#status().</li>
</ol>
<p>
<strong>cairo.context#append_path</strong>
</p>
<p>
<code>cairo.context#append_path(path:cairo.path):reduce</code>
</p>
<p>
Append the path onto the current path. The path may be either the return value from one of cairo.context#copy<em>path() or cairo.context#copy</em>path<em>flat() or it may be constructed manually.</em>See cairo<em>path</em>t for details on how the path data structure should be initialized, and note that path-&gt;status must be initialized to cairo.STATUS<em>SUCCESS.</em>
</p>
<p>
<strong>cairo.context#has_current_point</strong>
</p>
<p>
<code>cairo.context#has_current_point()</code>
</p>
<p>
Returns whether a current point is defined on the current path. See cairo.context#get<em>current</em>point() for details on the current point.
</p>
<p>
<strong>cairo.context#get_current_point</strong>
</p>
<p>
<code>cairo.context#get_current_point()</code>
</p>
<p>
Gets the current point of the current path, which is conceptually the final point reached by the path so far.
</p>
<p>
The current point is returned in the user-space coordinate system. If there is no defined current point or if cr is in an error status, x and y will both be set to 0.0. It is possible to check this in advance with cairo.context#has<em>current</em>point().
</p>
<p>
Most path construction functions alter the current point. See the following for details on how they affect the current point: cairo.context#new<em>path(), cairo.context#new</em>sub<em>path(), cairo.context#append</em>path(), cairo.context#close<em>path(), cairo.context#move</em>to(), cairo.context#line<em>to(), cairo.context#curve</em>to(), cairo.context#rel<em>move</em>to(), cairo.context#rel<em>line</em>to(), cairo.context#rel<em>curve</em>to(), cairo.context#arc(), cairo.context#arc<em>negative(), cairo.context#rectangle(), cairo.context#text</em>path(), cairo.context#glyph<em>path(), cairo.context#stroke</em>to<em>path().</em>
</p>
<p>
Some functions use and alter the current point but do not otherwise change current path: cairo.context#show<em>text().</em>
</p>
<p>
Some functions unset the current path and as a result, current point: cairo.context#fill(), cairo.context#stroke().
</p>
<p>
<strong>cairo.context#new_path</strong>
</p>
<p>
<code>cairo.context#new_path():reduce</code>
</p>
<p>
Clears the current path. After this call there will be no path and no current point.
</p>
<p>
<strong>cairo.context#new_sub_path</strong>
</p>
<p>
<code>cairo.context#new_sub_path():reduce</code>
</p>
<p>
Begin a new sub-path. Note that the existing path is not affected. After this call there will be no current point.
</p>
<p>
In many cases, this call is not needed since new sub-paths are frequently started with cairo.context#move<em>to().</em>
</p>
<p>
A call to cairo.context#new<em>sub</em>path() is particularly useful when beginning a new sub-path with one of the cairo.context#arc() calls. This makes things easier as it is no longer necessary to manually compute the arc's initial coordinates for a call to cairo.context#move<em>to().</em>
</p>
<p>
<strong>cairo.context#close_path</strong>
</p>
<p>
<code>cairo.context#close_path():reduce</code>
</p>
<p>
Adds a line segment to the path from the current point to the beginning of the current sub-path, (the most recent point passed to cairo.context#move<em>to()), and closes this sub-path.</em>After this call the current point will be at the joined endpoint of the sub-path.
</p>
<p>
The behavior of cairo.context#close<em>path() is distinct from simply calling cairo.context#line</em>to() with the equivalent coordinate in the case of stroking. When a closed sub-path is stroked, there are no caps on the ends of the sub-path. Instead, there is a line join connecting the final and initial segments of the sub-path.
</p>
<p>
If there is no current point before the call to cairo.context#close<em>path(), this function will have no effect.</em>
</p>
<p>
Note: As of cairo version 1.2.4 any call to cairo.context#close<em>path() will place an explicit MOVE</em>TO element into the path immediately after the CLOSE<em>PATH element,</em>(which can be seen in cairo.context#copy<em>path() for example).</em>This can simplify path processing in some cases as it may not be necessary to save the "last move<em>to point" during processing as the MOVE</em>TO immediately after the CLOSE<em>PATH will provide that point.</em>
</p>
<p>
<strong>cairo.context#arc</strong>
</p>
<p>
<code>cairo.context#arc(xc:number, yc:number, radius:number, angle1?:number, angle2?:number):map:reduce:[deg]</code>
</p>
<p>
Adds a circular arc of the given radius to the current path. The arc is centered at (xc, yc), begins at angle1 and proceeds in the direction of increasing angles to end at angle2. If angle2 is less than angle1 it will be progressively increased by 2<em>M_PI until it is greater than angle1.</em>
</p>
<p>
If there is a current point, an initial line segment will be added to the path to connect the current point to the beginning of the arc. If this initial line is undesired, it can be avoided by calling cairo.context#new<em>sub</em>path() before calling cairo.context#arc().
</p>
<p>
Angles are measured in radians. An angle of 0.0 is in the direction of the positive X axis (in user space). An angle of math.pi/2.0 radians (90 degrees) is in the direction of the positive Y axis (in user space). Angles increase in the direction from the positive X axis toward the positive Y axis. So with the default transformation matrix, angles increase in a clockwise direction.
</p>
<p>
(To convert from degrees to radians, use degrees <em> (math.pi / 180.).)</em>
</p>
<p>
This function gives the arc in the direction of increasing angles; see cairo.context#arc<em>negative() to get the arc in the direction of decreasing angles.</em>
</p>
<p>
The arc is circular in user space. To achieve an elliptical arc, you can scale the current transformation matrix by different amounts in the X and Y directions. For example, to draw an ellipse in the box given by x, y, width, height:
</p>
<p>
cr.save() cr.translate(x + width / 2., y + height / 2.) cr.scale(width / 2., height / 2.) cr.arc(0., 0., 1., 0., 2 <em> math.pi)</em>cr.restore()
</p>
<p>
<em>Gura:</em> If attribute :deg is specified, angle1 and angle2 are represented in degrees instead of radians.
</p>
<p>
<strong>cairo.context#arc_negative</strong>
</p>
<p>
<code>cairo.context#arc_negative(xc:number, yc:number, radius:number, angle1?:number, angle2?:number):map:reduce:[deg]</code>
</p>
<p>
Adds a circular arc of the given radius to the current path. The arc is centered at (xc, yc), begins at angle1 and proceeds in the direction of decreasing angles to end at angle2. If angle2 is greater than angle1 it will be progressively decreased by 2<em>math.pi until it is less than angle1.</em>
</p>
<p>
See cairo.context#arc() for more details. This function differs only in the direction of the arc between the two angles.
</p>
<p>
<em>Gura:</em> If attribute :deg is specified, angle1 and angle2 are represented in degrees instead of radians.
</p>
<p>
<strong>cairo.context#curve_to</strong>
</p>
<p>
<code>cairo.context#curve_to(x1:number, y1:number, x2:number, y2:number, x3:number, y3:number):map:reduce</code>
</p>
<p>
Adds a cubic Bezier spline to the path from the current point to position (x3, y3) in user-space coordinates, using (x1, y1) and (x2, y2) as the control points. After this call the current point will be (x3, y3).
</p>
<p>
If there is no current point before the call to cairo.context#curve<em>to() this function will behave as if preceded by a call to cr.move</em>to(x1, y1).
</p>
<p>
<strong>cairo.context#line_to</strong>
</p>
<p>
<code>cairo.context#line_to(x:number, y:number):map:reduce</code>
</p>
<p>
Adds a line to the path from the current point to position (x, y) in user-space coordinates. After this call the current point will be (x, y).
</p>
<p>
If there is no current point before the call to cairo.context#line<em>to() this function will behave as cr.move</em>to(x, y).
</p>
<p>
<strong>cairo.context#move_to</strong>
</p>
<p>
<code>cairo.context#move_to(x:number, y:number):map:reduce</code>
</p>
<p>
Begin a new sub-path. After this call the current point will be (x, y).
</p>
<p>
<strong>cairo.context#rectangle</strong>
</p>
<p>
<code>cairo.context#rectangle(x:number, y:number, width:number, height:number):map:reduce</code>
</p>
<p>
Adds a closed sub-path rectangle of the given size to the current path at position (x, y) in user-space coordinates.
</p>
<p>
This function is logically equivalent to:
</p>
<p>
cr.move<em>to(x, y)</em>cr.rel<em>line</em>to(width, 0) cr.rel<em>line</em>to(0, height) cr.rel<em>line</em>to(-width, 0) cr.close<em>path()</em>
</p>
<p>
<strong>cairo.context#text_path</strong>
</p>
<p>
<code>cairo.context#text_path(text:string):map:reduce</code>
</p>
<p>
Adds closed paths for text to the current path. The generated path if filled, achieves an effect similar to that of cairo.context#show<em>text().</em>
</p>
<p>
Text conversion and positioning is done similar to cairo.context#show<em>text().</em>
</p>
<p>
Like cairo.context#show<em>text(), After this call the current point is moved to the origin of where the next glyph would be placed in this same progression.</em>That is, the current point will be at the origin of the final glyph offset by its advance values. This allows for chaining multiple calls to to cairo.context#text<em>path() without having to set current point in between.</em>
</p>
<p>
Note: The cairo.context#text<em>path() function call is part of what the cairo designers call the "toy" text API.</em>It is convenient for short demos and simple programs, but it is not expected to be adequate for serious text-using applications. See cairo.context#glyph<em>path() for the "real" text path API in cairo.</em>
</p>
<p>
<strong>cairo.context#rel_curve_to</strong>
</p>
<p>
<code>cairo.context#rel_curve_to(dx1:number, dy1:number, dx2:number, dy2:number, dx3:number, dy3:number):map:reduce</code>
</p>
<p>
Relative-coordinate version of cairo.context#curve<em>to().</em>All offsets are relative to the current point. Adds a cubic Bezier spline to the path from the current point to a point offset from the current point by (dx3, dy3), using points offset by (dx1, dy1) and (dx2, dy2) as the control points. After this call the current point will be offset by (dx3, dy3).
</p>
<p>
Given a current point of (x, y), cr.rel<em>curve</em>to(dx1, dy1, dx2, dy2, dx3, dy3) is logically equivalent to cr.curve<em>to(x+dx1, y+dy1, x+dx2, y+dy2, x+dx3, y+dy3).</em>
</p>
<p>
It is an error to call this function with no current point. Doing so will cause cr to shutdown with a status of cairo.STATUS<em>NO</em>CURRENT<em>POINT.</em>
</p>
<p>
<strong>cairo.context#rel_line_to</strong>
</p>
<p>
<code>cairo.context#rel_line_to(dx:number, dy:number):map:reduce</code>
</p>
<p>
Relative-coordinate version of cairo.context#line<em>to().</em>Adds a line to the path from the current point to a point that is offset from the current point by (dx, dy) in user space. After this call the current point will be offset by (dx, dy).
</p>
<p>
Given a current point of (x, y), cr.rel<em>line</em>to(dx, dy) is logically equivalent to cr.line<em>to(x + dx, y + dy).</em>
</p>
<p>
It is an error to call this function with no current point. Doing so will cause cr to shutdown with a status of cairo.STATUS<em>NO</em>CURRENT<em>POINT.</em>
</p>
<p>
<strong>cairo.context#rel_move_to</strong>
</p>
<p>
<code>cairo.context#rel_move_to(dx:number, dy:number):map:reduce</code>
</p>
<p>
Begin a new sub-path. After this call the current point will offset by (dx, dy).
</p>
<p>
Given a current point of (x, y), cr.rel<em>move</em>to(dx, dy) is logically equivalent to cr.move<em>to(x + dx, y + dy).</em>
</p>
<p>
It is an error to call this function with no current point. Doing so will cause cr to shutdown with a status of cairo.STATUS<em>NO</em>CURRENT<em>POINT.</em>
</p>
<p>
<strong>cairo.context#path_extents</strong>
</p>
<p>
<code>cairo.context#path_extents()</code>
</p>
<p>
Computes a bounding box in user-space coordinates covering the points on the current path. If the current path is empty, returns an empty rectangle ((0,0), (0,0)). Stroke parameters, fill rule, surface dimensions and clipping are not taken into account.
</p>
<p>
Contrast with cairo.context#fill<em>extents() and cairo.context#stroke</em>extents() which return the extents of only the area that would be "inked" by the corresponding drawing operations.
</p>
<p>
The result of cairo.context#path<em>extents() is defined as equivalent to the limit of cairo.context#stroke</em>extents() with cairo.LINE<em>CAP</em>ROUND as the line width approaches 0.0, (but never reaching the empty-rectangle returned by cairo.context#stroke<em>extents() for a line width of 0.0).</em>
</p>
<p>
Specifically, this means that zero-area sub-paths such as cairo.context#move<em>to();cairo.context#line</em>to() segments, (even degenerate cases where the coordinates to both calls are identical), will be considered as contributing to the extents. However, a lone cairo.context#move<em>to() will not contribute to the results of cairo.context#path</em>extents().
</p>
<h3><span class="caption-index-3">10.1.3</span><a name="caption-10-1-3"></a>cairo_pattern_t - Sources for drawing</h3>
<p>
<strong>cairo.pattern#add_color_stop_rgb</strong>
</p>
<p>
<code>cairo.pattern#add_color_stop_rgb(offset:number, red:number, green:number, blue:number):reduce</code>
</p>
<p>
Adds an opaque color stop to a gradient pattern. The offset specifies the location along the gradient's control vector. For example, a linear gradient's control vector is from (x0,y0) to (x1,y1) while a radial gradient's control vector is from any point on the start circle to the corresponding point on the end circle.
</p>
<p>
The color is specified in the same way as in cairo.context#set<em>source</em>rgb().
</p>
<p>
If two (or more) stops are specified with identical offset values, they will be sorted according to the order in which the stops are added, (stops added earlier will compare less than stops added later). This can be useful for reliably making sharp color transitions instead of the typical blend.
</p>
<p>
Note: If the pattern is not a gradient pattern, (eg. a linear or radial pattern), then the pattern will be put into an error status with a status of cairo.STATUS<em>PATTERN</em>TYPE<em>MISMATCH.</em>
</p>
<p>
<strong>cairo.pattern#add_color_stop_rgba</strong>
</p>
<p>
<code>cairo.pattern#add_color_stop_rgba(offset:number, red:number, green:number, blue:number, alpha:number):reduce</code>
</p>
<p>
Adds a translucent color stop to a gradient pattern. The offset specifies the location along the gradient's control vector. For example, a linear gradient's control vector is from (x0,y0) to (x1,y1) while a radial gradient's control vector is from any point on the start circle to the corresponding point on the end circle.
</p>
<p>
The color is specified in the same way as in cairo.context#set<em>source</em>rgba().
</p>
<p>
If two (or more) stops are specified with identical offset values, they will be sorted according to the order in which the stops are added, (stops added earlier will compare less than stops added later). This can be useful for reliably making sharp color transitions instead of the typical blend.
</p>
<p>
Note: If the pattern is not a gradient pattern, (eg. a linear or radial pattern), then the pattern will be put into an error status with a status of cairo.STATUS<em>PATTERN</em>TYPE<em>MISMATCH.</em>
</p>
<p>
<strong>cairo.pattern#get_color_stop_count</strong>
</p>
<p>
<code>cairo.pattern#get_color_stop_count()</code>
</p>
<p>
Gets the number of color stops specified in the given gradient pattern.
</p>
<p>
<strong>cairo.pattern#get_color_stop_rgba</strong>
</p>
<p>
<code>cairo.pattern#get_color_stop_rgba(index:number)</code>
</p>
<p>
Gets the color and offset information at the given index for a gradient pattern. Values of index are 0 to 1 less than the number returned by cairo.pattern#get<em>color</em>stop<em>count().</em>
</p>
<p>
<strong>cairo.pattern.create_rgb</strong>
</p>
<p>
<code>cairo.pattern.create_rgb(red:number, green:number, blue:number):static {block?}</code>
</p>
<p>
Creates a new cairo.pattern corresponding to an opaque color. The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.
</p>
<p>
<strong>cairo.pattern.create_rgba</strong>
</p>
<p>
<code>cairo.pattern.create_rgba(red:number, green:number, blue:number, alpha:number):static {block?}</code>
</p>
<p>
Creates a new cairo,pattern corresponding to a translucent color. The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.
</p>
<p>
<strong>cairo.pattern#get_rgba</strong>
</p>
<p>
<code>cairo.pattern#get_rgba()</code>
</p>
<p>
Gets the solid color for a solid color pattern.
</p>
<p>
<strong>cairo.pattern.create_for_surface</strong>
</p>
<p>
<code>cairo.pattern.create_for_surface(surface:cairo.surface):static {block?}</code>
</p>
<p>
Create a new cairo.pattern for the given surface.
</p>
<p>
<strong>cairo.pattern#get_surface</strong>
</p>
<p>
<code>cairo.pattern#get_surface()</code>
</p>
<p>
Gets the surface of a surface pattern. The reference returned in surface is owned by the pattern; the caller should call cairo<em>surface</em>reference() if the surface is to be retained.
</p>
<p>
<strong>cairo.pattern.create_linear</strong>
</p>
<p>
<code>cairo.pattern.create_linear(x0:number, y0:number, x1:number, y1:number):static {block?}</code>
</p>
<p>
Create a new linear gradient cairo.pattern along the line defined by (x0, y0) and (x1, y1). Before using the gradient pattern, a number of color stops should be defined using cairo.pattern#add<em>color</em>stop<em>rgb() or cairo.pattern#add</em>color<em>stop</em>rgba().
</p>
<p>
Note: The coordinates here are in pattern space. For a new pattern, pattern space is identical to user space, but the relationship between the spaces can be changed with cairo.pattern#set<em>matrix().</em>
</p>
<p>
<strong>cairo.pattern#get_linear_points</strong>
</p>
<p>
<code>cairo.pattern#get_linear_points()</code>
</p>
<p>
Gets the gradient endpoints for a linear gradient.
</p>
<p>
<strong>cairo.pattern.create_radial</strong>
</p>
<p>
<code>cairo.pattern.create_radial(cx0:number, cy0:number, radius0:number, cx1:number, cy1:number, radius1:number):static {block?}</code>
</p>
<p>
Creates a new radial gradient cairo<em>pattern</em>t between the two circles defined by (cx0, cy0, radius0) and (cx1, cy1, radius1). Before using the gradient pattern, a number of color stops should be defined using cairo.pattern#add<em>color</em>stop<em>rgb() or cairo.pattern#add</em>color<em>stop</em>rgba().
</p>
<p>
Note: The coordinates here are in pattern space. For a new pattern, pattern space is identical to user space, but the relationship between the spaces can be changed with cairo.pattern#set<em>matrix().</em>
</p>
<p>
<strong>cairo.pattern#get_radial_circles</strong>
</p>
<p>
<code>cairo.pattern#get_radial_circles()</code>
</p>
<p>
Gets the gradient endpoint circles for a radial gradient, each specified as a center coordinate and a radius.
</p>
<p>
<strong>cairo.mesh_pattern.create</strong>
</p>
<p>
<code>cairo.mesh_pattern.create():static {block?}</code>
</p>
<p>
<strong>cairo.mesh_pattern#begin_patch</strong>
</p>
<p>
<code>cairo.mesh_pattern#begin_patch():reduce</code>
</p>
<p>
<strong>cairo.mesh_pattern#end_patch</strong>
</p>
<p>
<code>cairo.mesh_pattern#end_patch():reduce</code>
</p>
<p>
<strong>cairo.mesh_pattern#move_to</strong>
</p>
<p>
<code>cairo.mesh_pattern#move_to(x:number, y:number):reduce</code>
</p>
<p>
<strong>cairo.mesh_pattern#line_to</strong>
</p>
<p>
<code>cairo.mesh_pattern#line_to(x:number, y:number):reduce</code>
</p>
<p>
<strong>cairo.mesh_pattern#curve_to</strong>
</p>
<p>
<code>cairo.mesh_pattern#curve_to(x1:number, y1:number, x2:number, y2:number, x3:number, y3:number):reduce</code>
</p>
<p>
<strong>cairo.mesh_pattern#set_control_point</strong>
</p>
<p>
<code>cairo.mesh_pattern#set_control_point(point_num:number, x:number, y:number):reduce</code>
</p>
<p>
<strong>cairo.mesh_pattern#set_corner_color_rgb</strong>
</p>
<p>
<code>cairo.mesh_pattern#set_corner_color_rgb(corner_num:number, red:number, green:number, blue:number):reduce</code>
</p>
<p>
<strong>cairo.mesh_pattern#set_corner_color_rgba</strong>
</p>
<p>
<code>cairo.mesh_pattern#set_corner_color_rgba(corner_num:number, red:number, green:number, blue:number, alpha:number):reduce</code>
</p>
<p>
<strong>cairo.pattern#status</strong>
</p>
<p>
<code>cairo.pattern#status()</code>
</p>
<p>
Checks whether an error has previously occurred for this pattern.
</p>
<p>
<strong>cairo.pattern#set_extend</strong>
</p>
<p>
<code>cairo.pattern#set_extend(extend:number):reduce</code>
</p>
<p>
Sets the mode to be used for drawing outside the area of a pattern. See cairo<em>extend</em>t for details on the semantics of each extend strategy.
</p>
<p>
The default extend mode is cairo.EXTEND<em>NONE for surface patterns and cairo.EXTEND</em>PAD for gradient patterns.
</p>
<p>
<strong>cairo.pattern#get_extend</strong>
</p>
<p>
<code>cairo.pattern#get_extend()</code>
</p>
<p>
Gets the current extend mode for a pattern. See cairo<em>extend</em>t for details on the semantics of each extend strategy.
</p>
<p>
<strong>cairo.pattern#set_filter</strong>
</p>
<p>
<code>cairo.pattern#set_filter(filter:number):reduce</code>
</p>
<p>
Sets the filter to be used for resizing when using this pattern. See cairo<em>filter</em>t for details on each filter.
</p>
<ul>
<li><p>
Note that you might want to control filtering even when you do not have an explicit cairo.pattern object, (for example when using cairo.context#set<em>source</em>surface()). In these cases, it is convenient to use cairo.context#get<em>source() to get access to the pattern that cairo creates implicitly. For example:</em>
</p>
<p>
cr.set<em>source</em>surface(image, x, y) cr.get<em>source().set</em>filter(cairo.FILTER<em>NEAREST)</em>
</p>
</li>
</ul>
<p>
<strong>cairo.pattern#get_filter</strong>
</p>
<p>
<code>cairo.pattern#get_filter()</code>
</p>
<p>
Gets the current filter for a pattern. See cairo<em>filter</em>t for details on each filter.
</p>
<p>
<strong>cairo.pattern#set_matrix</strong>
</p>
<p>
<code>cairo.pattern#set_matrix(matrix:matrix):reduce</code>
</p>
<p>
Sets the pattern's transformation matrix to matrix. This matrix is a transformation from user space to pattern space.
</p>
<p>
When a pattern is first created it always has the identity matrix for its transformation matrix, which means that pattern space is initially identical to user space.
</p>
<p>
Important: Please note that the direction of this transformation matrix is from user space to pattern space. This means that if you imagine the flow from a pattern to user space (and on to device space), then coordinates in that flow will be transformed by the inverse of the pattern matrix.
</p>
<p>
For example, if you want to make a pattern appear twice as large as it does by default the correct code to use is:
</p>
<p>
cairo<em>matrix</em>init<em>scale (&amp;matrix, 0.5, 0.5);</em>cairo<em>pattern</em>set<em>matrix (pattern, &amp;matrix);</em>
</p>
<p>
Meanwhile, using values of 2.0 rather than 0.5 in the code above would cause the pattern to appear at half of its default size.
</p>
<p>
Also, please note the discussion of the user-space locking semantics of cairo.context#set<em>source().</em>
</p>
<p>
<strong>cairo.pattern#get_matrix</strong>
</p>
<p>
<code>cairo.pattern#get_matrix()</code>
</p>
<p>
Stores the pattern's transformation matrix into matrix.
</p>
<p>
<strong>cairo.pattern#get_type</strong>
</p>
<p>
<code>cairo.pattern#get_type()</code>
</p>
<p>
This function returns the type a pattern. See cairo<em>pattern</em>type<em>t for available types.</em>
</p>
<h3><span class="caption-index-3">10.1.4</span><a name="caption-10-1-4"></a>Regions - Representing a pixel-aligned area</h3>
<p>
<strong>cairo.region.create</strong>
</p>
<p>
<code>cairo.region.create():static {block?}</code>
</p>
<p>
<strong>cairo.region.create_rectangle</strong>
</p>
<p>
<code>cairo.region.create_rectangle(rectangle:cairo.rectangle_int):static {block?}</code>
</p>
<p>
<strong>cairo.region.create_rectangles</strong>
</p>
<p>
<code>cairo.region.create_rectangles(rects[]:cairo.rectangle_int):static {block?}</code>
</p>
<p>
<strong>cairo.region#copy</strong>
</p>
<p>
<code>cairo.region#copy() {block?}</code>
</p>
<p>
<strong>cairo.region#status</strong>
</p>
<p>
<code>cairo.region#status()</code>
</p>
<p>
<strong>cairo.region#get_extents</strong>
</p>
<p>
<code>cairo.region#get_extents()</code>
</p>
<p>
<strong>cairo.region#get_rectangle</strong>
</p>
<p>
<code>cairo.region#get_rectangle(nth:number)</code>
</p>
<p>
<strong>cairo.region#is_empty</strong>
</p>
<p>
<code>cairo.region#is_empty()</code>
</p>
<p>
<strong>cairo.region#contains_point</strong>
</p>
<p>
<code>cairo.region#contains_point(x:number, y:number)</code>
</p>
<p>
<strong>cairo.region#contains_rectangle</strong>
</p>
<p>
<code>cairo.region#contains_rectangle(rectangle:cairo.rectangle_int)</code>
</p>
<p>
<strong>cairo.region#equal</strong>
</p>
<p>
<code>cairo.region#equal(region:cairo.region)</code>
</p>
<p>
<strong>cairo.region#translate</strong>
</p>
<p>
<code>cairo.region#translate(dx:number, dy:number)</code>
</p>
<p>
<strong>cairo.region#intersect</strong>
</p>
<p>
<code>cairo.region#intersect(other:cairo.region)</code>
</p>
<p>
<strong>cairo.region#intersect_rectangle</strong>
</p>
<p>
<code>cairo.region#intersect_rectangle(rectangle:cairo.rectangle_int)</code>
</p>
<p>
<strong>cairo.region#union</strong>
</p>
<p>
<code>cairo.region#union(other:cairo.region)</code>
</p>
<p>
<strong>cairo.region#union_rectangle</strong>
</p>
<p>
<code>cairo.region#union_rectangle(rectangle:cairo.rectangle_int)</code>
</p>
<p>
<strong>cairo.region#xor</strong>
</p>
<p>
<code>cairo.region#xor(other:cairo.region)</code>
</p>
<p>
<strong>cairo.region#xor_rectangle</strong>
</p>
<p>
<code>cairo.region#xor_rectangle(rectangle:cairo.rectangle_int)</code>
</p>
<h3><span class="caption-index-3">10.1.5</span><a name="caption-10-1-5"></a>Transformations - Manipulating the current transformation matrix</h3>
<p>
<strong>cairo.context#translate</strong>
</p>
<p>
<code>cairo.context#translate(tx:number, ty:number):reduce</code>
</p>
<p>
Modifies the current transformation matrix (CTM) by translating the user-space origin by (tx, ty). This offset is interpreted as a user-space coordinate according to the CTM in place before the new call to cairo.context#translate(). In other words, the translation of the user-space origin takes place after any existing transformation.
</p>
<p>
<strong>cairo.context#scale</strong>
</p>
<p>
<code>cairo.context#scale(sx:number, sy:number):reduce</code>
</p>
<p>
Modifies the current transformation matrix (CTM) by scaling the X and Y user-space axes by sx and sy respectively. The scaling of the axes takes place after any existing transformation of user space.
</p>
<p>
<strong>cairo.context#rotate</strong>
</p>
<p>
<code>cairo.context#rotate(angle:number):reduce:[deg]</code>
</p>
<p>
Modifies the current transformation matrix (CTM) by rotating the user-space axes by angle radians. The rotation of the axes takes places after any existing transformation of user space. The rotation direction for positive angles is from the positive X axis toward the positive Y axis.
</p>
<p>
<em>Gura:</em> If attribute :deg is specified, angle is represented in degrees instead of radians.
</p>
<p>
<strong>cairo.context#transform</strong>
</p>
<p>
<code>cairo.context#transform(matrix:matrix):reduce</code>
</p>
<p>
Modifies the current transformation matrix (CTM) by applying matrix as an additional transformation. The new transformation of user space takes place after any existing transformation.
</p>
<p>
<strong>cairo.context#set_matrix</strong>
</p>
<p>
<code>cairo.context#set_matrix(matrix:matrix):reduce</code>
</p>
<p>
Modifies the current transformation matrix (CTM) by setting it equal to matrix.
</p>
<p>
<strong>cairo.context#get_matrix</strong>
</p>
<p>
<code>cairo.context#get_matrix()</code>
</p>
<p>
Stores the current transformation matrix (CTM) into matrix.
</p>
<p>
<strong>cairo.context#identity_matrix</strong>
</p>
<p>
<code>cairo.context#identity_matrix():reduce</code>
</p>
<p>
Resets the current transformation matrix (CTM) by setting it equal to the identity matrix. That is, the user-space and device-space axes will be aligned and one user-space unit will transform to one device-space unit.
</p>
<p>
<strong>cairo.context#user_to_device</strong>
</p>
<p>
<code>cairo.context#user_to_device(x:number, y:number)</code>
</p>
<p>
Transform a coordinate from user space to device space by multiplying the given point by the current transformation matrix (CTM).
</p>
<p>
<strong>cairo.context#user_to_device_distance</strong>
</p>
<p>
<code>cairo.context#user_to_device_distance(dx:number, dy:number)</code>
</p>
<p>
Transform a distance vector from user space to device space. This function is similar to cairo.context#user<em>to</em>device() except that the translation components of the CTM will be ignored when transforming (dx,dy).
</p>
<p>
<strong>cairo.context#device_to_user</strong>
</p>
<p>
<code>cairo.context#device_to_user(x:number, y:number)</code>
</p>
<p>
Transform a coordinate from device space to user space by multiplying the given point by the inverse of the current transformation matrix (CTM).
</p>
<p>
<strong>cairo.context#device_to_user_distance</strong>
</p>
<p>
<code>cairo.context#device_to_user_distance(dx:number, dy:number)</code>
</p>
<p>
Transform a distance vector from device space to user space. This function is similar to cairo.context#device<em>to</em>user() except that the translation components of the inverse CTM will be ignored when transforming (dx,dy).
</p>
<h3><span class="caption-index-3">10.1.6</span><a name="caption-10-1-6"></a>text - Rendering text and glyphs</h3>
<p>
<strong>cairo.context#select_font_face</strong>
</p>
<p>
<code>cairo.context#select_font_face(family:string, slant:number, weight:number):reduce</code>
</p>
<p>
Note: The cairo.context#select<em>font</em>face() function call is part of what the cairo designers call the "toy" text API. It is convenient for short demos and simple programs, but it is not expected to be adequate for serious text-using applications.
</p>
<p>
Selects a family and style of font from a simplified description as a family name, slant and weight. Cairo provides no operation to list available family names on the system (this is a "toy", remember), but the standard CSS2 generic family names, ("serif", "sans-serif", "cursive", "fantasy", "monospace"), are likely to work as expected.
</p>
<p>
If family starts with the string "cairo:", or if no native font backends are compiled in, cairo will use an internal font family. The internal font family recognizes many modifiers in the family string, most notably, it recognizes the string "monospace". That is, the family name "cairo:monospace" will use the monospace version of the internal font family.
</p>
<p>
For "real" font selection, see the font-backend-specific font<em>face</em>create functions for the font backend you are using. (For example, if you are using the freetype-based cairo-ft font backend, see cairo<em>ft</em>font<em>face</em>create<em>for</em>ft<em>face() or cairo</em>ft<em>font</em>face<em>create</em>for<em>pattern().)</em>The resulting font face could then be used with cairo.scaled<em>font</em>create() and cairo.context#set<em>scaled</em>font().
</p>
<p>
Similarly, when using the "real" font support, you can call directly into the underlying font system, (such as fontconfig or freetype), for operations such as listing available fonts, etc.
</p>
<p>
It is expected that most applications will need to use a more comprehensive font handling and text layout library, (for example, pango), in conjunction with cairo.
</p>
<p>
If text is drawn without a call to cairo.context#select<em>font</em>face(), (nor cairo.context#set<em>font</em>face() nor cairo.context#set<em>scaled</em>font()), the default family is platform-specific, but is essentially "sans-serif". Default slant is cairo.FONT<em>SLANT</em>NORMAL, and default weight is cairo.FONT<em>WEIGHT</em>NORMAL.
</p>
<p>
This function is equivalent to a call to cairo.toy<em>font</em>face.create() followed by cairo.context#set<em>font</em>face().
</p>
<p>
<strong>cairo.context#set_font_size</strong>
</p>
<p>
<code>cairo.context#set_font_size(size:number):reduce</code>
</p>
<p>
Sets the current font matrix to a scale by a factor of size, replacing any font matrix previously set with cairo.context#set<em>font</em>size() or cairo.context#set<em>font</em>matrix(). This results in a font size of size user space units. (More precisely, this matrix will result in the font's em-square being a size by size square in user space.)
</p>
<p>
If text is drawn without a call to cairo.context#set<em>font</em>size(), (nor cairo.context#set<em>font</em>matrix() nor cairo.context#set<em>scaled</em>font()), the default font size is 10.0.
</p>
<p>
<strong>cairo.context#set_font_matrix</strong>
</p>
<p>
<code>cairo.context#set_font_matrix(matrix:matrix):reduce</code>
</p>
<p>
Sets the current font matrix to matrix. The font matrix gives a transformation from the design space of the font (in this space, the em-square is 1 unit by 1 unit) to user space. Normally, a simple scale is used (see cairo<em>set</em>font<em>size()), but a more complex font matrix can be used to shear the font or stretch it unequally along the two axes.</em>
</p>
<p>
<strong>cairo.context#get_font_matrix</strong>
</p>
<p>
<code>cairo.context#get_font_matrix()</code>
</p>
<p>
Stores the current font matrix into matrix. See cairo.context#set<em>font</em>matrix().
</p>
<p>
<strong>cairo.context#set_font_options</strong>
</p>
<p>
<code>cairo.context#set_font_options(options:cairo.font_options):reduce</code>
</p>
<p>
Sets a set of custom font rendering options for the cairo<em>t.</em>Rendering options are derived by merging these options with the options derived from underlying surface; if the value in options has a default value (like cairo.ANTIALIAS<em>DEFAULT), then the value from the surface is used.</em>
</p>
<p>
<strong>cairo.context#get_font_options</strong>
</p>
<p>
<code>cairo.context#get_font_options()</code>
</p>
<p>
Retrieves font rendering options set via cairo.context#set<em>font</em>options. Note that the returned options do not include any options derived from the underlying surface; they are literally the options passed to cairo.context#set<em>font</em>options().
</p>
<p>
<strong>cairo.context#set_font_face</strong>
</p>
<p>
<code>cairo.context#set_font_face(font_face:cairo.font_face):reduce</code>
</p>
<p>
Replaces the current cairo<em>font</em>face<em>t object in the cairo</em>t with font<em>face.</em>The replaced font face in the cairo<em>t will be destroyed if there are no other references to it.</em>
</p>
<p>
<strong>cairo.context#get_font_face</strong>
</p>
<p>
<code>cairo.context#get_font_face()</code>
</p>
<p>
Gets the current font face for a cairo<em>t.</em>
</p>
<p>
<strong>cairo.context#set_scaled_font</strong>
</p>
<p>
<code>cairo.context#set_scaled_font(scaled_font:cairo.scaled_font):reduce</code>
</p>
<p>
Replaces the current font face, font matrix, and font options in the cairo<em>t with those of the cairo</em>scaled<em>font</em>t. Except for some translation, the current CTM of the cairo<em>t should be the same as that of the cairo</em>scaled<em>font</em>t, which can be accessed using cairo.context#scaled<em>font</em>get<em>ctm().</em>
</p>
<p>
<strong>cairo.context#get_scaled_font</strong>
</p>
<p>
<code>cairo.context#get_scaled_font()</code>
</p>
<p>
Gets the current scaled font for a cairo<em>t.</em>
</p>
<p>
<strong>cairo.context#show_text</strong>
</p>
<p>
<code>cairo.context#show_text(text:string):reduce</code>
</p>
<p>
A drawing operator that generates the shape from a string of UTF-8 characters, rendered according to the current font<em>face, font</em>size (font<em>matrix), and font</em>options.
</p>
<p>
This function first computes a set of glyphs for the string of text. The first glyph is placed so that its origin is at the current point. The origin of each subsequent glyph is offset from that of the previous glyph by the advance values of the previous glyph.
</p>
<p>
After this call the current point is moved to the origin of where the next glyph would be placed in this same progression. That is, the current point will be at the origin of the final glyph offset by its advance values. This allows for easy display of a single logical string with multiple calls to cairo.context#show<em>text().</em>
</p>
<p>
Note: The cairo.context#show<em>text() function call is part of what the cairo designers call the "toy" text API.</em>It is convenient for short demos and simple programs, but it is not expected to be adequate for serious text-using applications. See cairo.context#show<em>glyphs() for the "real" text display API in cairo.</em>
</p>
<p>
<strong>cairo.context#show_glyphs</strong>
</p>
<p>
<code>cairo.context#show_glyphs(glyphs:cairo.glyph):reduce</code>
</p>
<p>
A drawing operator that generates the shape from an array of glyphs, rendered according to the current font face, font size (font matrix), and font options.
</p>
<p>
<strong>cairo.context#font_extents</strong>
</p>
<p>
<code>cairo.context#font_extents()</code>
</p>
<p>
Gets the font extents for the currently selected font.
</p>
<p>
<strong>cairo.context#text_extents</strong>
</p>
<p>
<code>cairo.context#text_extents(text:string)</code>
</p>
<p>
Gets the extents for a string of text. The extents describe a user-space rectangle that encloses the "inked" portion of the text, (as it would be drawn by cairo.context#show<em>text()).</em>Additionally, the x<em>advance and y</em>advance values indicate the amount by which the current point would be advanced by cairo.context#show<em>text().</em>
</p>
<p>
Note that whitespace characters do not directly contribute to the size of the rectangle (extents.width and extents.height). They do contribute indirectly by changing the position of non-whitespace characters. In particular, trailing whitespace characters are likely to not affect the size of the rectangle, though they will affect the x<em>advance and y</em>advance values.
</p>
<p>
<strong>cairo.context#glyph_extents</strong>
</p>
<p>
<code>cairo.context#glyph_extents(glyphs:cairo.glyph)</code>
</p>
<p>
Gets the extents for an array of glyphs. The extents describe a user-space rectangle that encloses the "inked" portion of the glyphs, (as they would be drawn by cairo.context#show<em>glyphs()).</em>Additionally, the x<em>advance and y</em>advance values indicate the amount by which the current point would be advanced by cairo.context#show<em>glyphs().</em>
</p>
<p>
Note that whitespace glyphs do not contribute to the size of the rectangle (extents.width and extents.height).
</p>
<p>
<strong>cairo.toy_font_face.create</strong>
</p>
<p>
<code>cairo.toy_font_face.create(family:string, slant:number, weight:number):static {block?}</code>
</p>
<p>
Creates a font face from a triplet of family, slant, and weight. These font faces are used in implementation of the the cairo<em>t "toy" font API.</em>
</p>
<p>
If family is the zero-length string "", the platform-specific default family is assumed. The default family then can be queried using cairo.toy<em>font</em>face#get<em>family().</em>
</p>
<p>
The cairo.context#select<em>font</em>face() function uses this to create font faces. See that function for limitations and other details of toy font faces.
</p>
<p>
<strong>cairo.toy_font_face#get_family</strong>
</p>
<p>
<code>cairo.toy_font_face#get_family()</code>
</p>
<p>
Gets the familly name of a toy font.
</p>
<p>
<strong>cairo.toy_font_face#get_slant</strong>
</p>
<p>
<code>cairo.toy_font_face#get_slant()</code>
</p>
<p>
Gets the slant a toy font.
</p>
<p>
<strong>cairo.toy_font_face#get_weight</strong>
</p>
<p>
<code>cairo.toy_font_face#get_weight()</code>
</p>
<p>
Gets the weight a toy font.
</p>
<h3><span class="caption-index-3">10.1.7</span><a name="caption-10-1-7"></a>Raster Sources - Supplying arbitary image data</h3>
<h2><span class="caption-index-2">10.2</span><a name="caption-10-2"></a>Fonts</h2>
<h3><span class="caption-index-3">10.2.1</span><a name="caption-10-2-1"></a>cairo_font_face_t - Base class for font faces</h3>
<h3><span class="caption-index-3">10.2.2</span><a name="caption-10-2-2"></a>cairo_scaled_font_t - Font face at particular size and options</h3>
<p>
<strong>cairo.scaled_font.create</strong>
</p>
<p>
<code>cairo.scaled_font.create(font_face:cairo.font_face, font_matrix:matrix, ctm:matrix, options):static {block?}</code>
</p>
<h3><span class="caption-index-3">10.2.3</span><a name="caption-10-2-3"></a>cairo_font_options_t - How a font should be rendered</h3>
<h3><span class="caption-index-3">10.2.4</span><a name="caption-10-2-4"></a>FreeType  Fonts - Font support for FreeType</h3>
<h3><span class="caption-index-3">10.2.5</span><a name="caption-10-2-5"></a>Win32 Fonts - Font support for Microsoft Windows</h3>
<h3><span class="caption-index-3">10.2.6</span><a name="caption-10-2-6"></a>Quartz (CGFont) Fonts - Font support via CGFont on OS X</h3>
<h3><span class="caption-index-3">10.2.7</span><a name="caption-10-2-7"></a>User Fonts - Font support with font data provided by the user</h3>
<h2><span class="caption-index-2">10.3</span><a name="caption-10-3"></a>Surfaces</h2>
<h3><span class="caption-index-3">10.3.1</span><a name="caption-10-3-1"></a>cairo_device_t - interface to underlying rendering system</h3>
<h3><span class="caption-index-3">10.3.2</span><a name="caption-10-3-2"></a>cairo_surface_t - Base class for surfaces</h3>
<h3><span class="caption-index-3">10.3.3</span><a name="caption-10-3-3"></a>Image Surfaces - Rendering to memory buffers</h3>
<h3><span class="caption-index-3">10.3.4</span><a name="caption-10-3-4"></a>PDF Surfaces - Rendering PDF documents</h3>
<h3><span class="caption-index-3">10.3.5</span><a name="caption-10-3-5"></a>PNG Support - Reading and writing PNG images</h3>
<h3><span class="caption-index-3">10.3.6</span><a name="caption-10-3-6"></a>PostScript Surfaces - Rendering PostScript documents</h3>
<h3><span class="caption-index-3">10.3.7</span><a name="caption-10-3-7"></a>Recording Surfaces - Records all drawing operations</h3>
<h3><span class="caption-index-3">10.3.8</span><a name="caption-10-3-8"></a>Win32 Surfaces - Microsoft Windows surface support</h3>
<h3><span class="caption-index-3">10.3.9</span><a name="caption-10-3-9"></a>SVG Surfaces - Rendering SVG documents</h3>
<h3><span class="caption-index-3">10.3.10</span><a name="caption-10-3-10"></a>Quartz Surfaces - Rendering to Quartz surfaces</h3>
<h3><span class="caption-index-3">10.3.11</span><a name="caption-10-3-11"></a>XCB Surfaces - X Window System rendering using the XCB library</h3>
<h3><span class="caption-index-3">10.3.12</span><a name="caption-10-3-12"></a>XLib Surfaces - X Window System rendering using XLib</h3>
<h3><span class="caption-index-3">10.3.13</span><a name="caption-10-3-13"></a>XLib-XRender Backend - X Window System rendering using XLib and the X Render extension</h3>
<h3><span class="caption-index-3">10.3.14</span><a name="caption-10-3-14"></a>Script Surfaces - Rendering to replayable scripts</h3>
<h2><span class="caption-index-2">10.4</span><a name="caption-10-4"></a>Utilities</h2>
<h3><span class="caption-index-3">10.4.1</span><a name="caption-10-4-1"></a>cairo_matrix_t - Generic matrix operations</h3>
<h1><span class="caption-index-1">11</span><a name="caption-11"></a>conio Module</h1>
<p>
The <code>conio</code> module provides following measures to work on a console screen:
</p>
<ul>
<li>Moves the cursor where texts are printed.</li>
<li>Changes text colors.</li>
<li>Retrieves console size.</li>
<li>Waits for keyboard input.</li>
</ul>
<p>
To utilize it, import the <code>conio</code> module using <code>import</code> function.
</p>
<p>
Below is an example to print a frame around a console:
</p>
<pre><code>import(conio)

conio.clear()
[w, h] = conio.getwinsize()
conio.moveto(0, 0) {
    print('*' * w)
}
conio.moveto(0, 1 .. (h - 2)) {
    print('*', ' ' * (w - 2), '*')
}
conio.moveto(0, h - 1) {
    print('*' * w)
}
conio.waitkey():raise
</code></pre>
<h2><span class="caption-index-2">11.1</span><a name="caption-11-1"></a>Module Functions</h2>
<p>
<strong>conio.clear</strong>
</p>
<p>
<code>conio.clear(region?:symbol):void</code>
</p>
<p>
Clears the screen.
</p>
<p>
In default, it clears whole the screen. Argument <code>region</code> that takes one of the symbols below would specify the region to be cleared.
</p>
<ul>
<li><code>`line</code> .. clears characters in the line where the cursor exists.</li>
<li><code>`left</code> .. clears characters on the left side of the cursor.</li>
<li><code>`right</code> .. clears characters on the right side of the cursor.</li>
<li><code>`top</code> .. clears characters on the above side of the cursor.</li>
<li><code>`bottom</code> .. clears characters on the below side of the cursor.</li>
</ul>
<p>
<strong>conio.getwinsize</strong>
</p>
<p>
<code>conio.getwinsize()</code>
</p>
<p>
Returns the screen size as a list <code>[width, height]</code>.
</p>
<p>
<strong>conio.setcolor</strong>
</p>
<p>
<code>conio.setcolor(fg:symbol:nil, bg?:symbol):map:void {block?}</code>
</p>
<p>
Sets foreground and background color of text by specifying a color symbol. Available color symbols are listed below:
</p>
<ul>
<li><code>`black</code></li>
<li><code>`blue</code></li>
<li><code>`green</code></li>
<li><code>`aqua</code></li>
<li><code>`cyan</code></li>
<li><code>`red</code></li>
<li><code>`purple</code></li>
<li><code>`magenta</code></li>
<li><code>`yellow</code></li>
<li><code>`white</code></li>
<li><code>`gray</code></li>
<li><code>`bright_blue</code></li>
<li><code>`bright_green</code></li>
<li><code>`bright_aqua</code></li>
<li><code>`bright_cyan</code></li>
<li><code>`bright_red</code></li>
<li><code>`bright_purple</code></li>
<li><code>`bright_magenta</code></li>
<li><code>`bright_yellow</code></li>
<li><code>`bright_white</code></li>
</ul>
<p>
If <code>fg</code> is set to nil, the foreground color remains unchanged. If <code>bg</code> is omitted or set to nil, the background color remains unchanged.
</p>
<p>
If <code>block</code> is specified, the color is changed before evaluating the block, and then gets back to what has been set when done.
</p>
<p>
<strong>conio.moveto</strong>
</p>
<p>
<code>conio.moveto(x:number, y:number):map:void {block?}</code>
</p>
<p>
Moves cursor to the specified position. The most top-left position on the screen is represented as <code>0, 0</code>.
</p>
<p>
If <code>block</code> is specified, the cursor is moved before evaluating the block, and then gets back to where it has been when done.
</p>
<p>
<strong>conio.waitkey</strong>
</p>
<p>
<code>conio.waitkey():[raise]</code>
</p>
<p>
Waits for a keyboard input and returns a character code number associated with the key.
</p>
<p>
If <code>:raise</code> attribute is specified, hitting <code>Ctrl-C</code> issues a terminating signal that causes the program done.
</p>
<p>
Character code numbers of some of the special keys are defined as below:
</p>
<ul>
<li><code>conio.K_BACKSPACE</code></li>
<li><code>conio.K_TAB</code></li>
<li><code>conio.K_RETURN</code></li>
<li><code>conio.K_ESCAPE</code></li>
<li><code>conio.K_SPACE</code></li>
<li><code>conio.K_UP</code></li>
<li><code>conio.K_DOWN</code></li>
<li><code>conio.K_RIGHT</code></li>
<li><code>conio.K_LEFT</code></li>
<li><code>conio.K_INSERT</code></li>
<li><code>conio.K_HOME</code></li>
<li><code>conio.K_END</code></li>
<li><code>conio.K_PAGEUP</code></li>
<li><code>conio.K_PAGEDOWN</code></li>
<li><code>conio.K_DELETE</code></li>
</ul>
<h1><span class="caption-index-1">12</span><a name="caption-12"></a>csv Module</h1>
<p>
The <code>csv</code> module provices measures to read/write CSV files. To utilize it, import the <code>csv</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read a CSV file that contains three fields per line:
</p>
<pre><code>import(csv)

Record = struct(name:string, age:number, email:string)
records = Record * csv.read('records.csv')
printf('name:%s, age:%d, email:%sn',
       records:*name, records:*age, records:*email)
</code></pre>
<h2><span class="caption-index-2">12.1</span><a name="caption-12-1"></a>Module Functions</h2>
<p>
<strong>csv.parse</strong>
</p>
<p>
<code>csv.parse(str:string):map</code>
</p>
<p>
<strong>csv.read</strong>
</p>
<p>
<code>csv.read(stream:stream:r) {block?}</code>
</p>
<p>
<strong>csv.writer</strong>
</p>
<p>
<code>csv.writer(stream:stream:w, format?:string) {block?}</code>
</p>
<h2><span class="caption-index-2">12.2</span><a name="caption-12-2"></a>csv.writer Class</h2>
<p>
<strong>csv.writer#write</strong>
</p>
<p>
<code>csv.writer#write(fields+):map:reduce</code>
</p>
<h2><span class="caption-index-2">12.3</span><a name="caption-12-3"></a>Methods Added to stream Class</h2>
<p>
<strong>stream#read@csv</strong>
</p>
<p>
<code>stream#read@csv() {block?}</code>
</p>
<p>
<strong>stream#writer@csv</strong>
</p>
<p>
<code>stream#writer@csv(format?:string) {block?}</code>
</p>
<h1><span class="caption-index-1">13</span><a name="caption-13"></a>curl Module</h1>
<p>
The <code>curl</code> module provices measures to access Internet resources using cURL library. To utilize it, import the <code>curl</code> module using <code>import</code> function.
</p>
<h2><span class="caption-index-2">13.1</span><a name="caption-13-1"></a>Module Functions</h2>
<p>
<strong>curl.version</strong>
</p>
<p>
<code>curl.version() {block?}</code>
</p>
<p>
Returns a string of the libcurl version.
</p>
<p>
<strong>curl.easy_init</strong>
</p>
<p>
<code>curl.easy_init() {block?}</code>
</p>
<p>
Initializes cURL and returns a easy<em>handle object.</em>
</p>
<h2><span class="caption-index-2">13.2</span><a name="caption-13-2"></a>curl.easy_handle Class</h2>
<p>
<strong>curl.easy_handle#escape</strong>
</p>
<p>
<code>curl.easy_handle#escape(string:string):void</code>
</p>
<p>
<strong>curl.easy_handle#getinfo</strong>
</p>
<p>
<code>curl.easy_handle#getinfo(info:number)</code>
</p>
<p>
<strong>curl.easy_handle#perform</strong>
</p>
<p>
<code>curl.easy_handle#perform(stream?:stream:w):void</code>
</p>
<p>
<strong>curl.easy_handle#recv</strong>
</p>
<p>
<code>curl.easy_handle#recv(buflen:number)</code>
</p>
<p>
<strong>curl.easy_handle#reset</strong>
</p>
<p>
<code>curl.easy_handle#reset():void</code>
</p>
<p>
<strong>curl.easy_handle#send</strong>
</p>
<p>
<code>curl.easy_handle#send(buffer:binary)</code>
</p>
<p>
<strong>curl.easy_handle#setopt</strong>
</p>
<p>
<code>curl.easy_handle#setopt(option:number, arg):void</code>
</p>
<p>
<strong>curl.easy_handle#unescape</strong>
</p>
<p>
<code>curl.easy_handle#unescape(string:string):void</code>
</p>
<h1><span class="caption-index-1">14</span><a name="caption-14"></a>emf Module</h1>
<p>
The <code>emf</code> module provices measures to read/write EMF (Enhanced Meta File) files.
</p>
<h2><span class="caption-index-2">14.1</span><a name="caption-14-1"></a>Module Functions</h2>
<h2><span class="caption-index-2">14.2</span><a name="caption-14-2"></a>example Module</h2>
<p>
The <code>example</code> module is just an example that is supposed to be referenced as a skeleton when you want to create a new module.
</p>
<h3><span class="caption-index-3">14.2.1</span><a name="caption-14-2-1"></a>Module Functions</h3>
<h1><span class="caption-index-1">15</span><a name="caption-15"></a>freetype Module</h1>
<p>
The <code>freetype</code> module provices measures to access vectorized font data using freetype library. To utilize it, import the <code>freetype</code> module using <code>import</code> function.
</p>
<h2><span class="caption-index-2">15.1</span><a name="caption-15-1"></a>Module Functions</h2>
<p>
<strong>freetype.sysfontpath</strong>
</p>
<p>
<code>freetype.sysfontpath(name?:string):map</code>
</p>
<h2><span class="caption-index-2">15.2</span><a name="caption-15-2"></a>freetype.BBox Class</h2>
<h2><span class="caption-index-2">15.3</span><a name="caption-15-3"></a>freetype.BDF_Property Class</h2>
<h2><span class="caption-index-2">15.4</span><a name="caption-15-4"></a>freetype.Bitmap Class</h2>
<p>
<strong>freetype.Bitmap#Embolden</strong>
</p>
<p>
<code>freetype.Bitmap#Embolden(strength:number):reduce</code>
</p>
<h2><span class="caption-index-2">15.5</span><a name="caption-15-5"></a>freetype.CharMap Class</h2>
<p>
<strong>freetype.CharMap#Get_Index</strong>
</p>
<p>
<code>freetype.CharMap#Get_Index()</code>
</p>
<h2><span class="caption-index-2">15.6</span><a name="caption-15-6"></a>freetype.FTC_CMapCache Class</h2>
<h2><span class="caption-index-2">15.7</span><a name="caption-15-7"></a>freetype.FTC_ImageCache Class</h2>
<h2><span class="caption-index-2">15.8</span><a name="caption-15-8"></a>freetype.FTC_ImageType Class</h2>
<h2><span class="caption-index-2">15.9</span><a name="caption-15-9"></a>freetype.FTC_Manager Class</h2>
<h2><span class="caption-index-2">15.10</span><a name="caption-15-10"></a>freetype.FTC_Node Class</h2>
<h2><span class="caption-index-2">15.11</span><a name="caption-15-11"></a>freetype.FTC_SBit Class</h2>
<h2><span class="caption-index-2">15.12</span><a name="caption-15-12"></a>freetype.FTC_SBitCache Class</h2>
<h2><span class="caption-index-2">15.13</span><a name="caption-15-13"></a>freetype.FTC_Scaler Class</h2>
<h2><span class="caption-index-2">15.14</span><a name="caption-15-14"></a>freetype.Face Class</h2>
<p>
<strong>freetype.Face</strong>
</p>
<p>
<code>freetype.Face(stream:stream, face_index:number =&gt; 0):map {block?}</code>
</p>
<p>
<strong>freetype.Face#CheckTrueTypePatents</strong>
</p>
<p>
<code>freetype.Face#CheckTrueTypePatents()</code>
</p>
<p>
<strong>freetype.Face#Get_Advance</strong>
</p>
<p>
<code>freetype.Face#Get_Advance(glyph_index:number, load_flags:number)</code>
</p>
<p>
<strong>freetype.Face#Get_Advances</strong>
</p>
<p>
<code>freetype.Face#Get_Advances(glyph_index_start:number, count:number, load_flags:number)</code>
</p>
<p>
<strong>freetype.Face#Get_Glyph_Name</strong>
</p>
<p>
<code>freetype.Face#Get_Glyph_Name(glyph_index:number)</code>
</p>
<p>
<strong>freetype.Face#Get_Postscript_Name</strong>
</p>
<p>
<code>freetype.Face#Get_Postscript_Name()</code>
</p>
<p>
<strong>freetype.Face#Get_Kerning</strong>
</p>
<p>
<code>freetype.Face#Get_Kerning(left_glyph:number, right_glyph:number, kern_mode:number)</code>
</p>
<p>
<strong>freetype.Face#Load_Char</strong>
</p>
<p>
<code>freetype.Face#Load_Char(char_code:number, load_flags:number):reduce</code>
</p>
<p>
<strong>freetype.Face#Load_Glyph</strong>
</p>
<p>
<code>freetype.Face#Load_Glyph(glyph_index:number, load_flags:number):reduce</code>
</p>
<p>
<strong>freetype.Face#Set_Charmap</strong>
</p>
<p>
<code>freetype.Face#Set_Charmap(charmap:freetype.CharMap):reduce</code>
</p>
<p>
<strong>freetype.Face#Set_Pixel_Sizes</strong>
</p>
<p>
<code>freetype.Face#Set_Pixel_Sizes(pixel_width:number, pixel_height:number):reduce</code>
</p>
<h2><span class="caption-index-2">15.15</span><a name="caption-15-15"></a>freetype.Glyph Class</h2>
<p>
<strong>freetype.Glyph#Copy</strong>
</p>
<p>
<code>freetype.Glyph#Copy()</code>
</p>
<p>
<strong>freetype.Glyph#Stroke</strong>
</p>
<p>
<code>freetype.Glyph#Stroke(stroker:freetype.Stroker):reduce</code>
</p>
<p>
<strong>freetype.Glyph#StrokeBorder</strong>
</p>
<p>
<code>freetype.Glyph#StrokeBorder(stroker:freetype.Stroker, inside:boolean):reduce</code>
</p>
<h2><span class="caption-index-2">15.16</span><a name="caption-15-16"></a>freetype.GlyphSlot Class</h2>
<p>
<strong>freetype.GlyphSlot#Get_Glyph</strong>
</p>
<p>
<code>freetype.GlyphSlot#Get_Glyph()</code>
</p>
<p>
<strong>freetype.GlyphSlot#Render</strong>
</p>
<p>
<code>freetype.GlyphSlot#Render(render_mode:number):reduce</code>
</p>
<h2><span class="caption-index-2">15.17</span><a name="caption-15-17"></a>freetype.Matrix Class</h2>
<p>
<strong>freetype.Matrix</strong>
</p>
<p>
<code>freetype.Matrix(matrix:matrix):map {block?}</code>
</p>
<p>
<strong>freetype.Matrix#Multiply</strong>
</p>
<p>
<code>freetype.Matrix#Multiply(matrix:freetype.Matrix):reduce</code>
</p>
<p>
<strong>freetype.Matrix#Invert</strong>
</p>
<p>
<code>freetype.Matrix#Invert():reduce</code>
</p>
<h2><span class="caption-index-2">15.18</span><a name="caption-15-18"></a>freetype.Outline Class</h2>
<p>
<strong>freetype.Outline#Translate</strong>
</p>
<p>
<code>freetype.Outline#Translate(xOffset:freetype.Matrix, yOffset:freetype.Matrix):reduce</code>
</p>
<p>
<strong>freetype.Outline#Transform</strong>
</p>
<p>
<code>freetype.Outline#Transform(matrix:freetype.Matrix):reduce</code>
</p>
<p>
<strong>freetype.Outline#Embolden</strong>
</p>
<p>
<code>freetype.Outline#Embolden(strength:number):reduce</code>
</p>
<p>
<strong>freetype.Outline#Reverse</strong>
</p>
<p>
<code>freetype.Outline#Reverse():reduce</code>
</p>
<h2><span class="caption-index-2">15.19</span><a name="caption-15-19"></a>freetype.Raster Class</h2>
<h2><span class="caption-index-2">15.20</span><a name="caption-15-20"></a>freetype.Span Class</h2>
<h2><span class="caption-index-2">15.21</span><a name="caption-15-21"></a>freetype.Stroker Class</h2>
<p>
<strong>freetype.Stroker</strong>
</p>
<p>
<code>freetype.Stroker():map {block?}</code>
</p>
<p>
<strong>freetype.Stroker#BeginSubPath</strong>
</p>
<p>
<code>freetype.Stroker#BeginSubPath(to:freetype.Vector, open:boolean):reduce</code>
</p>
<h2><span class="caption-index-2">15.22</span><a name="caption-15-22"></a>freetype.Vector Class</h2>
<p>
<strong>freetype.Vector</strong>
</p>
<p>
<code>freetype.Vector(x:number, y:number):map {block?}</code>
</p>
<p>
<strong>freetype.Vector#Length</strong>
</p>
<p>
<code>freetype.Vector#Length()</code>
</p>
<p>
<strong>freetype.Vector#Transform</strong>
</p>
<p>
<code>freetype.Vector#Transform(matrix:freetype.Matrix):reduce</code>
</p>
<h2><span class="caption-index-2">15.23</span><a name="caption-15-23"></a>freetype.font Class</h2>
<p>
<strong>freetype.font</strong>
</p>
<p>
<code>freetype.font(face:freetype.Face):map {block?}</code>
</p>
<p>
<strong>freetype.font#cleardeco</strong>
</p>
<p>
<code>freetype.font#cleardeco():reduce</code>
</p>
<p>
<strong>freetype.font#drawtext</strong>
</p>
<p>
<code>freetype.font#drawtext(image:image, x:number, y:number, str:string):map:reduce {block?}</code>
</p>
<p>
Draws a text on the image.
</p>
<p>
<strong>freetype.font#calcsize</strong>
</p>
<p>
<code>freetype.font#calcsize(str:string):map</code>
</p>
<p>
<strong>freetype.font#calcbbox</strong>
</p>
<p>
<code>freetype.font#calcbbox(x:number, y:number, str:string):map</code>
</p>
<h2><span class="caption-index-2">15.24</span><a name="caption-15-24"></a>Methods Added to image Class</h2>
<p>
<strong>image#drawtext</strong>
</p>
<p>
<code>image#drawtext(font:freetype.font, x:number, y:number, str:string):map:reduce {block?}</code>
</p>
<p>
Draws a text on the image.
</p>
<h1><span class="caption-index-1">16</span><a name="caption-16"></a>fs Module</h1>
<p>
The <code>fs</code> module provides measures to access and modify information in file systems. This is a built-in module, so you can use it without being imported.
</p>
<h2><span class="caption-index-2">16.1</span><a name="caption-16-1"></a>Module Functions</h2>
<p>
<strong>fs.chdir</strong>
</p>
<p>
<code>fs.chdir(pathname:string) {block?}</code>
</p>
<p>
Changes the current working directory.
</p>
<p>
<strong>fs.chmod</strong>
</p>
<p>
<code>fs.chmod(mode, pathname:string):map:void:[follow_link]</code>
</p>
<p>
Changes the access mode of a file specified by <code>pathname</code>.
</p>
<p>
There are two formats to specify the mode: one is by a number, and another in a string.
</p>
<p>
When specified in a number, following bits are associated with access permissions:
</p>
<ul>
<li><code>b8 b7 b6</code> .. Read, write and executable permissions for owners</li>
<li><code>b5 b4 b3</code> .. Read, write and executable permissions for groups</li>
<li><code>b2 b1 b0</code> .. Read, write and executable permissions for others</li>
</ul>
<p>
When set to one, each permission is validated.
</p>
<p>
When specified in a string, it accepts a permission directive in a format of following regular expression
</p>
<pre><code>[ugoa]+([-+=][rwx]+)+
</code></pre>
<p>
It starts with characters that represent target which permissions are modified as described below:
</p>
<ul>
<li><code>u</code> .. owners</li>
<li><code>g</code> .. groups</li>
<li><code>o</code> .. others</li>
<li><code>a</code> .. all users</li>
</ul>
<p>
Then, follows an operation:
</p>
<ul>
<li><code>-</code> .. remove</li>
<li><code>+</code> .. append</li>
<li><code>=</code> .. set</li>
</ul>
<p>
At last, permission attributes are specified as below:
</p>
<ul>
<li><code>r</code> .. read permission</li>
<li><code>w</code> .. write permission</li>
<li><code>x</code> .. executable permission</li>
</ul>
<p>
If the modification target is a link file, each platform would have different result:
</p>
<ul>
<li>Linux .. Modifies permissions of the link file itself. Specifying <code>:follow_link</code> attribute would modify permsisions of the target file instead.</li>
<li>MacOS .. Modifies permissions of the target file. Attribute <code>:follow_link</code> has no effect.</li>
<li>Windows .. Modifies permissions of the link file. Attribute <code>:follow_link</code> has no effect.</li>
</ul>
<p>
<strong>fs.copy</strong>
</p>
<p>
<code>fs.copy(src:string, dst:string):map:void:[overwrite]</code>
</p>
<p>
Copies a file.
</p>
<p>
An argument <code>src</code> needs to specify a path name of a file that is to be copied while <code>dst</code> can specify a path name of either a file or a directory. If <code>dst</code> is a directory, the file would be copied into that. Otherwise, it would create a copy of <code>src</code> that has a name specified by <code>dst</code>.
</p>
<p>
If a destination file already exists, an error occurs. Specifying an attribute <code>:overwrite</code> would overwrite an existing one.
</p>
<p>
<strong>fs.cpdir</strong>
</p>
<p>
<code>fs.cpdir(src:string, dst:string):map:void:[tree]</code>
</p>
<p>
Copies a directory.
</p>
<p>
Arguments <code>src</code> and <code>dst</code> specify source directory and destination directory respectively. In default, sub directories are not copied.Specifying <code>:tree</code> attribute would copy all the sub directories in the source.
</p>
<p>
<strong>fs.getcwd</strong>
</p>
<p>
<code>fs.getcwd()</code>
</p>
<p>
Returns the current working directory.
</p>
<p>
<strong>fs.mkdir</strong>
</p>
<p>
<code>fs.mkdir(pathname:string):map:void:[tree]</code>
</p>
<p>
Creates a directory.
</p>
<p>
If <code>pathname</code> consists of multiple sub directories and some of them still doesn't exist, an error occurs. Specifying <code>:tree</code> attribute would create such directories.
</p>
<p>
<strong>fs.remove</strong>
</p>
<p>
<code>fs.remove(pathname:string):map:void</code>
</p>
<p>
Removes a file from the file system.
</p>
<p>
<strong>fs.rename</strong>
</p>
<p>
<code>fs.rename(src:string, dst:string):map:void</code>
</p>
<p>
Renames a file or directory.
</p>
<p>
<strong>fs.rmdir</strong>
</p>
<p>
<code>fs.rmdir(pathname:string):map:void:[tree]</code>
</p>
<p>
Removes a directory.
</p>
<p>
If the directory contains sub directories, an error occurs. Specifying <code>:tree</code> attribute would delete such a directory.
</p>
<h1><span class="caption-index-1">17</span><a name="caption-17"></a>gif Module</h1>
<p>
The <code>gif</code> module provides measures to read/write image data in GIF format. To utilize it, import the <code>gif</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read a GIF file:
</p>
<pre><code>import(gif)
img = image('foo.gif')
</code></pre>
<p>
Below is an example to create a GIF file that contains multiple images:
</p>
<pre><code>import(gif)
g = gif.content()
g.addimage(['cell1.png', 'cell2.png', 'cell3.png'], 10) g.write('anim.gif')
</code></pre>
<h2><span class="caption-index-2">17.1</span><a name="caption-17-1"></a>Exntension of Function's Capability</h2>
<p>
This module extends the capability of function <code>image()</code> and instance method <code>image#write()</code> so that they can read/write GIF files.
</p>
<p>
When function <code>image()</code> is provided with a stream that satisfies the following conditions, it would recognize the stream as a GIF file.
</p>
<ul>
<li>The identifier of the stream ends with a suffix <code>.gif</code>.</li>
<li>The stream data begins with a byte sequence "<code>GIF87a</code>" or "<code>GIF89a</code>".</li>
</ul>
<p>
When instance method <code>image#write()</code> is provided with a stream that satisfies the following condition, it would write image data in GIF format.
</p>
<ul>
<li>The identifier of the stream ends with a suffix <code>.gif</code>.</li>
</ul>
<h2><span class="caption-index-2">17.2</span><a name="caption-17-2"></a>gif.content Class</h2>
<p>
<strong>gif.content</strong>
</p>
<p>
<code>gif.content(stream?:stream:r, format:symbol =&gt; `rgba) {block?}</code>
</p>
<p>
Reads a GIF data from a stream and returns an object that contains GIF related information and images of a specified format. format is is <code>rgb,</code>rgba or <code>noimage. If</code>noimage is specified, only the information data is read
</p>
<p>
<strong>gif.content#addimage</strong>
</p>
<p>
<code>gif.content#addimage(image:image, delayTime:number =&gt; 10, leftPos:number =&gt; 0, topPos:number =&gt; 0, disposalMethod:symbol =&gt; `none):map:reduce</code>
</p>
<p>
Adds an image to GIF information. If you add multiple images, they are to be rendered in sequence like an animation. You can specify the delay time to switch to the next image by delayTime argument in 10 msec step. The offset for rendering is specified by leftPost and topPos. Parameter disposalMethod determine how the image should be treated after the time expires, and it takes one of <code>none,</code>keep, <code>background and</code>previous.
</p>
<p>
<strong>gif.content#write</strong>
</p>
<p>
<code>gif.content#write(stream:stream:w):reduce</code>
</p>
<p>
Writes a GIF image to a stream.
</p>
<h2><span class="caption-index-2">17.3</span><a name="caption-17-3"></a>Methods Added to image Class</h2>
<p>
<strong>image#read@gif</strong>
</p>
<p>
<code>image#read@gif(stream:stream:r):reduce</code>
</p>
<p>
Reads a GIF image from a stream.
</p>
<p>
<strong>image#write@gif</strong>
</p>
<p>
<code>image#write@gif(stream:stream:w):reduce</code>
</p>
<p>
Writes a GIF image to a stream.
</p>
<h1><span class="caption-index-1">18</span><a name="caption-18"></a>glu Module</h1>
<p>
The <code>glu</code> module provides functions of GLU library.
</p>
<h2><span class="caption-index-2">18.1</span><a name="caption-18-1"></a>Module Functions</h2>
<p>
<strong>glu.gluBeginCurve</strong>
</p>
<p>
<code>glu.gluBeginCurve(nurb:glu.Nurbs):void {block?}</code>
</p>
<p>
<strong>glu.gluBeginPolygon</strong>
</p>
<p>
<code>glu.gluBeginPolygon(tess:glu.Tesselator):void {block?}</code>
</p>
<p>
<strong>glu.gluBeginSurface</strong>
</p>
<p>
<code>glu.gluBeginSurface(nurb:glu.Nurbs):void {block?}</code>
</p>
<p>
<strong>glu.gluBeginTrim</strong>
</p>
<p>
<code>glu.gluBeginTrim(nurb:glu.Nurbs):void {block?}</code>
</p>
<p>
<strong>glu.gluBuild1DMipmaps</strong>
</p>
<p>
<code>glu.gluBuild1DMipmaps(target:number, internalFormat:number, width:number, format:number, type:number, data)</code>
</p>
<p>
<strong>glu.gluBuild1DMipmapsFromImage</strong>
</p>
<p>
<code>glu.gluBuild1DMipmapsFromImage(target:number, internalFormat:number, image:image)</code>
</p>
<p>
<strong>glu.gluBuild2DMipmaps</strong>
</p>
<p>
<code>glu.gluBuild2DMipmaps(target:number, internalFormat:number, width:number, height:number, format:number, type:number, data)</code>
</p>
<p>
<strong>glu.gluBuild2DMipmapsFromImage</strong>
</p>
<p>
<code>glu.gluBuild2DMipmapsFromImage(target:number, internalFormat:number, image:image)</code>
</p>
<p>
<strong>glu.gluCylinder</strong>
</p>
<p>
<code>glu.gluCylinder(quad:glu.Quadric, base:number, top:number, height:number, slices:number, stacks:number):void</code>
</p>
<p>
<strong>glu.gluDeleteNurbsRenderer</strong>
</p>
<p>
<code>glu.gluDeleteNurbsRenderer(nurb:glu.Nurbs):void</code>
</p>
<p>
<strong>glu.gluDeleteQuadric</strong>
</p>
<p>
<code>glu.gluDeleteQuadric(quad:glu.Quadric):void</code>
</p>
<p>
<strong>glu.gluDeleteTess</strong>
</p>
<p>
<code>glu.gluDeleteTess(tess:glu.Tesselator):void</code>
</p>
<p>
<strong>glu.gluDisk</strong>
</p>
<p>
<code>glu.gluDisk(quad:glu.Quadric, inner:number, outer:number, slices:number, loops:number):void</code>
</p>
<p>
<strong>glu.gluEndCurve</strong>
</p>
<p>
<code>glu.gluEndCurve(nurb:glu.Nurbs):void</code>
</p>
<p>
<strong>glu.gluEndPolygon</strong>
</p>
<p>
<code>glu.gluEndPolygon(tess:glu.Tesselator):void</code>
</p>
<p>
<strong>glu.gluEndSurface</strong>
</p>
<p>
<code>glu.gluEndSurface(nurb:glu.Nurbs):void</code>
</p>
<p>
<strong>glu.gluEndTrim</strong>
</p>
<p>
<code>glu.gluEndTrim(nurb:glu.Nurbs):void</code>
</p>
<p>
<strong>glu.gluErrorString</strong>
</p>
<p>
<code>glu.gluErrorString(error:number)</code>
</p>
<p>
<strong>glu.gluGetNurbsProperty</strong>
</p>
<p>
<code>glu.gluGetNurbsProperty(nurb:glu.Nurbs, property:number, data:array@float:nomap):void</code>
</p>
<p>
<strong>glu.gluGetString</strong>
</p>
<p>
<code>glu.gluGetString(name:number)</code>
</p>
<p>
<strong>glu.gluGetTessProperty</strong>
</p>
<p>
<code>glu.gluGetTessProperty(tess:glu.Tesselator, which:number, data:array@double:nomap):void</code>
</p>
<p>
<strong>glu.gluLoadSamplingMatrices</strong>
</p>
<p>
<code>glu.gluLoadSamplingMatrices(nurb:glu.Nurbs, model:array@float:nomap, perspective:array@float:nomap, view:array@int:nomap):void</code>
</p>
<p>
<strong>glu.gluLookAt</strong>
</p>
<p>
<code>glu.gluLookAt(eyeX:number, eyeY:number, eyeZ:number, centerX:number, centerY:number, centerZ:number, upX:number, upY:number, upZ:number):void</code>
</p>
<p>
<strong>glu.gluNewNurbsRenderer</strong>
</p>
<p>
<code>glu.gluNewNurbsRenderer()</code>
</p>
<p>
<strong>glu.gluNewQuadric</strong>
</p>
<p>
<code>glu.gluNewQuadric()</code>
</p>
<p>
<strong>glu.gluNewTess</strong>
</p>
<p>
<code>glu.gluNewTess()</code>
</p>
<p>
<strong>glu.gluNextContour</strong>
</p>
<p>
<code>glu.gluNextContour(tess:glu.Tesselator, type:number):void</code>
</p>
<p>
<strong>glu.gluNurbsCallback</strong>
</p>
<p>
<code>glu.gluNurbsCallback(nurbs:glu.Nurbs, which:number, func:function)</code>
</p>
<p>
<strong>glu.gluNurbsCallbackData</strong>
</p>
<p>
<code>glu.gluNurbsCallbackData(nurb:glu.Nurbs, userData):void</code>
</p>
<p>
<strong>glu.gluNurbsCallbackDataEXT</strong>
</p>
<p>
<code>glu.gluNurbsCallbackDataEXT(nurb:glu.Nurbs, userData):void</code>
</p>
<p>
<strong>glu.gluNurbsCurve</strong>
</p>
<p>
<code>glu.gluNurbsCurve(nurb:glu.Nurbs, knots:array@float:nomap, stride:number, control:array@float:nomap, order:number, type:number):void</code>
</p>
<p>
<strong>glu.gluNurbsProperty</strong>
</p>
<p>
<code>glu.gluNurbsProperty(nurb:glu.Nurbs, property:number, value:number):void</code>
</p>
<p>
<strong>glu.gluNurbsSurface</strong>
</p>
<p>
<code>glu.gluNurbsSurface(nurb:glu.Nurbs, sKnots:array@float:nomap, tKnots:array@float:nomap, sStride:number, tStride:number, control:array@float:nomap, sOrder:number, tOrder:number, type:number):void</code>
</p>
<p>
<strong>glu.gluOrtho2D</strong>
</p>
<p>
<code>glu.gluOrtho2D(left:number, right:number, bottom:number, top:number):void</code>
</p>
<p>
<strong>glu.gluPartialDisk</strong>
</p>
<p>
<code>glu.gluPartialDisk(quad:glu.Quadric, inner:number, outer:number, slices:number, loops:number, start:number, sweep:number):void</code>
</p>
<p>
<strong>glu.gluPerspective</strong>
</p>
<p>
<code>glu.gluPerspective(fovy:number, aspect:number, zNear:number, zFar:number):void</code>
</p>
<p>
<strong>glu.gluPickMatrix</strong>
</p>
<p>
<code>glu.gluPickMatrix(x:number, y:number, delX:number, delY:number, viewport:array@int:nomap):void</code>
</p>
<p>
<strong>glu.gluProject</strong>
</p>
<p>
<code>glu.gluProject(objX:number, objY:number, objZ:number, model:array@double:nomap, proj:array@double:nomap, view:array@int:nomap, winX:array@double:nomap, winY:array@double:nomap, winZ:array@double:nomap)</code>
</p>
<p>
<strong>glu.gluPwlCurve</strong>
</p>
<p>
<code>glu.gluPwlCurve(nurb:glu.Nurbs, data:array@float:nomap, stride:number, type:number):void</code>
</p>
<p>
<strong>glu.gluQuadricCallback</strong>
</p>
<p>
<code>glu.gluQuadricCallback(quad:glu.Quadric, which:number, func:function:nil):void</code>
</p>
<p>
<strong>glu.gluQuadricDrawStyle</strong>
</p>
<p>
<code>glu.gluQuadricDrawStyle(quad:glu.Quadric, draw:number):void</code>
</p>
<p>
<strong>glu.gluQuadricNormals</strong>
</p>
<p>
<code>glu.gluQuadricNormals(quad:glu.Quadric, normal:number):void</code>
</p>
<p>
<strong>glu.gluQuadricOrientation</strong>
</p>
<p>
<code>glu.gluQuadricOrientation(quad:glu.Quadric, orientation:number):void</code>
</p>
<p>
<strong>glu.gluQuadricTexture</strong>
</p>
<p>
<code>glu.gluQuadricTexture(quad:glu.Quadric, texture:boolean):void</code>
</p>
<p>
<strong>glu.gluScaleImage</strong>
</p>
<p>
<code>glu.gluScaleImage(imageIn:image, wOut:number, hOut:number)</code>
</p>
<p>
<strong>glu.gluSphere</strong>
</p>
<p>
<code>glu.gluSphere(quad:glu.Quadric, radius:number, slices:number, stacks:number):void</code>
</p>
<p>
<strong>glu.gluTessBeginContour</strong>
</p>
<p>
<code>glu.gluTessBeginContour(tess:glu.Tesselator):void {block?}</code>
</p>
<p>
<strong>glu.gluTessBeginPolygon</strong>
</p>
<p>
<code>glu.gluTessBeginPolygon(tess:glu.Tesselator, polygon_data):void {block?}</code>
</p>
<p>
<strong>glu.gluTessCallback</strong>
</p>
<p>
<code>glu.gluTessCallback(tess:glu.Tesselator, which:number, func:function):void</code>
</p>
<p>
<strong>glu.gluTessEndContour</strong>
</p>
<p>
<code>glu.gluTessEndContour(tess:glu.Tesselator):void</code>
</p>
<p>
<strong>glu.gluTessEndPolygon</strong>
</p>
<p>
<code>glu.gluTessEndPolygon(tess:glu.Tesselator):void</code>
</p>
<p>
<strong>glu.gluTessNormal</strong>
</p>
<p>
<code>glu.gluTessNormal(tess:glu.Tesselator, valueX:number, valueY:number, valueZ:number):void</code>
</p>
<p>
<strong>glu.gluTessProperty</strong>
</p>
<p>
<code>glu.gluTessProperty(tess:glu.Tesselator, which:number, data:number):void</code>
</p>
<p>
<strong>glu.gluTessVertex</strong>
</p>
<p>
<code>glu.gluTessVertex(tess:glu.Tesselator, location:array@double:nomap, vertex_data):void</code>
</p>
<p>
<strong>glu.gluUnProject</strong>
</p>
<p>
<code>glu.gluUnProject(winX:number, winY:number, winZ:number, model:array@double:nomap, proj:array@double:nomap, view:array@int:nomap, objX:array@double:nomap, objY:array@double:nomap, objZ:array@double:nomap)</code>
</p>
<h1><span class="caption-index-1">19</span><a name="caption-19"></a>glut Module</h1>
<p>
The <code>glut</code> module provides functions of GLUT library.
</p>
<h2><span class="caption-index-2">19.1</span><a name="caption-19-1"></a>Module Functions</h2>
<p>
<strong>glut.glutInit</strong>
</p>
<p>
<code>glut.glutInit(argv[]:string) {block?}</code>
</p>
<p>
<code>glutInit</code> is used to initialize the GLUT library.
</p>
<p>
<strong>glut.glutInitDisplayMode</strong>
</p>
<p>
<code>glut.glutInitDisplayMode(mode:number):map:void</code>
</p>
<p>
<code>glutInitDisplayMode</code> sets the <em>initial display mode</em>.
</p>
<p>
<strong>glut.glutInitDisplayString</strong>
</p>
<p>
<code>glut.glutInitDisplayString(string:string):map:void</code>
</p>
<p>
<strong>glut.glutInitWindowPosition</strong>
</p>
<p>
<code>glut.glutInitWindowPosition(x:number, y:number):map:void</code>
</p>
<p>
<code>glutInitWindowPosition</code> sets the initial window position.	
</p>
<p>
<strong>glut.glutInitWindowSize</strong>
</p>
<p>
<code>glut.glutInitWindowSize(width:number, height:number):map:void</code>
</p>
<p>
<code>glutInitWindowSize</code> sets the initial window size.	
</p>
<p>
<strong>glut.glutMainLoop</strong>
</p>
<p>
<code>glut.glutMainLoop():void</code>
</p>
<p>
<code>glutMainLoop</code> enters the GLUT event processing loop.
</p>
<p>
<strong>glut.glutCreateWindow</strong>
</p>
<p>
<code>glut.glutCreateWindow(title:string):map {block?}</code>
</p>
<p>
<code>glutCreateWindow</code> creates a top-level window.
</p>
<p>
<strong>glut.glutCreateSubWindow</strong>
</p>
<p>
<code>glut.glutCreateSubWindow(win:number, x:number, y:number, width:number, height:number):map {block?}</code>
</p>
<p>
<code>glutCreateSubWindow</code> creates a subwindow.
</p>
<p>
<strong>glut.glutDestroyWindow</strong>
</p>
<p>
<code>glut.glutDestroyWindow(win:number):map:void</code>
</p>
<p>
<code>glutDestroyWindow</code> destroys the specified window.
</p>
<p>
<strong>glut.glutPostRedisplay</strong>
</p>
<p>
<code>glut.glutPostRedisplay():void</code>
</p>
<p>
<code>glutPostRedisplay marks the *current window* as needing to be redisplayed.</code>
</p>
<p>
<strong>glut.glutPostWindowRedisplay</strong>
</p>
<p>
<code>glut.glutPostWindowRedisplay(win:number):map:void</code>
</p>
<p>
<strong>glut.glutSwapBuffers</strong>
</p>
<p>
<code>glut.glutSwapBuffers():void</code>
</p>
<p>
<code>glutSwapBuffers</code> swaps the buffers of the <em>current window</em> if double buffered.
</p>
<p>
<strong>glut.glutGetWindow</strong>
</p>
<p>
<code>glut.glutGetWindow() {block?}</code>
</p>
<p>
<code>glutGetWindow</code> returns the identifier of the <em>current window</em>.
</p>
<p>
<strong>glut.glutSetWindow</strong>
</p>
<p>
<code>glut.glutSetWindow(win:number):map:void</code>
</p>
<p>
<code>glutSetWindow</code> sets the <em>current window</em>.
</p>
<p>
<strong>glut.glutSetWindowTitle</strong>
</p>
<p>
<code>glut.glutSetWindowTitle(title:string):map:void</code>
</p>
<p>
<code>glutSetWindowTitle</code> changes the window title of the current top-level window.
</p>
<p>
<strong>glut.glutSetIconTitle</strong>
</p>
<p>
<code>glut.glutSetIconTitle(title:string):map:void</code>
</p>
<p>
<code>glutSetIconTitle</code> changes the icon title of the current top-level window.
</p>
<p>
<strong>glut.glutPositionWindow</strong>
</p>
<p>
<code>glut.glutPositionWindow(x:number, y:number):map:void</code>
</p>
<p>
<code>glutPositionWindow</code> requests a change to the position of the <em>current window</em>.
</p>
<p>
<strong>glut.glutReshapeWindow</strong>
</p>
<p>
<code>glut.glutReshapeWindow(width:number, height:number):map:void</code>
</p>
<p>
<code>glutReshapeWindow</code> requests a change to the size of the <em>current window</em>.
</p>
<p>
<strong>glut.glutPopWindow</strong>
</p>
<p>
<code>glut.glutPopWindow():void</code>
</p>
<p>
<strong>glut.glutPushWindow</strong>
</p>
<p>
<code>glut.glutPushWindow():void</code>
</p>
<p>
<strong>glut.glutIconifyWindow</strong>
</p>
<p>
<code>glut.glutIconifyWindow():void</code>
</p>
<p>
<strong>glut.glutShowWindow</strong>
</p>
<p>
<code>glut.glutShowWindow():void</code>
</p>
<p>
<strong>glut.glutHideWindow</strong>
</p>
<p>
<code>glut.glutHideWindow():void</code>
</p>
<p>
<strong>glut.glutFullScreen</strong>
</p>
<p>
<code>glut.glutFullScreen():void</code>
</p>
<p>
<strong>glut.glutSetCursor</strong>
</p>
<p>
<code>glut.glutSetCursor(cursor:number):map:void</code>
</p>
<p>
<strong>glut.glutWarpPointer</strong>
</p>
<p>
<code>glut.glutWarpPointer(x:number, y:number):map:void</code>
</p>
<p>
<strong>glut.glutEstablishOverlay</strong>
</p>
<p>
<code>glut.glutEstablishOverlay():void</code>
</p>
<p>
<strong>glut.glutRemoveOverlay</strong>
</p>
<p>
<code>glut.glutRemoveOverlay():void</code>
</p>
<p>
<strong>glut.glutUseLayer</strong>
</p>
<p>
<code>glut.glutUseLayer(layer:number):map:void</code>
</p>
<p>
<strong>glut.glutPostOverlayRedisplay</strong>
</p>
<p>
<code>glut.glutPostOverlayRedisplay():void</code>
</p>
<p>
<strong>glut.glutPostWindowOverlayRedisplay</strong>
</p>
<p>
<code>glut.glutPostWindowOverlayRedisplay(win:number):map:void</code>
</p>
<p>
<strong>glut.glutShowOverlay</strong>
</p>
<p>
<code>glut.glutShowOverlay():void</code>
</p>
<p>
<strong>glut.glutHideOverlay</strong>
</p>
<p>
<code>glut.glutHideOverlay():void</code>
</p>
<p>
<strong>glut.glutCreateMenu</strong>
</p>
<p>
<code>glut.glutCreateMenu(func:function) {block?}</code>
</p>
<p>
<strong>glut.glutDestroyMenu</strong>
</p>
<p>
<code>glut.glutDestroyMenu(menu:number):map:void</code>
</p>
<p>
<strong>glut.glutGetMenu</strong>
</p>
<p>
<code>glut.glutGetMenu() {block?}</code>
</p>
<p>
<strong>glut.glutSetMenu</strong>
</p>
<p>
<code>glut.glutSetMenu(menu:number):map:void</code>
</p>
<p>
<strong>glut.glutAddMenuEntry</strong>
</p>
<p>
<code>glut.glutAddMenuEntry(label:string, value:number):map:void</code>
</p>
<p>
<strong>glut.glutAddSubMenu</strong>
</p>
<p>
<code>glut.glutAddSubMenu(label:string, submenu:number):map:void</code>
</p>
<p>
<strong>glut.glutChangeToMenuEntry</strong>
</p>
<p>
<code>glut.glutChangeToMenuEntry(item:number, label:string, value:number):map:void</code>
</p>
<p>
<strong>glut.glutChangeToSubMenu</strong>
</p>
<p>
<code>glut.glutChangeToSubMenu(item:number, label:string, submenu:number):map:void</code>
</p>
<p>
<strong>glut.glutRemoveMenuItem</strong>
</p>
<p>
<code>glut.glutRemoveMenuItem(item:number):map:void</code>
</p>
<p>
<strong>glut.glutAttachMenu</strong>
</p>
<p>
<code>glut.glutAttachMenu(button:number):map:void</code>
</p>
<p>
<strong>glut.glutDetachMenu</strong>
</p>
<p>
<code>glut.glutDetachMenu(button:number):map:void</code>
</p>
<p>
<strong>glut.glutDisplayFunc</strong>
</p>
<p>
<code>glut.glutDisplayFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutReshapeFunc</strong>
</p>
<p>
<code>glut.glutReshapeFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutKeyboardFunc</strong>
</p>
<p>
<code>glut.glutKeyboardFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutMouseFunc</strong>
</p>
<p>
<code>glut.glutMouseFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutMotionFunc</strong>
</p>
<p>
<code>glut.glutMotionFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutPassiveMotionFunc</strong>
</p>
<p>
<code>glut.glutPassiveMotionFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutEntryFunc</strong>
</p>
<p>
<code>glut.glutEntryFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutVisibilityFunc</strong>
</p>
<p>
<code>glut.glutVisibilityFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutIdleFunc</strong>
</p>
<p>
<code>glut.glutIdleFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutTimerFunc</strong>
</p>
<p>
<code>glut.glutTimerFunc(millis:number, func:function:nil, value:number):void</code>
</p>
<p>
<strong>glut.glutMenuStateFunc</strong>
</p>
<p>
<code>glut.glutMenuStateFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutSpecialFunc</strong>
</p>
<p>
<code>glut.glutSpecialFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutSpaceballMotionFunc</strong>
</p>
<p>
<code>glut.glutSpaceballMotionFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutSpaceballRotateFunc</strong>
</p>
<p>
<code>glut.glutSpaceballRotateFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutSpaceballButtonFunc</strong>
</p>
<p>
<code>glut.glutSpaceballButtonFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutButtonBoxFunc</strong>
</p>
<p>
<code>glut.glutButtonBoxFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutDialsFunc</strong>
</p>
<p>
<code>glut.glutDialsFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutTabletMotionFunc</strong>
</p>
<p>
<code>glut.glutTabletMotionFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutTabletButtonFunc</strong>
</p>
<p>
<code>glut.glutTabletButtonFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutMenuStatusFunc</strong>
</p>
<p>
<code>glut.glutMenuStatusFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutOverlayDisplayFunc</strong>
</p>
<p>
<code>glut.glutOverlayDisplayFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutWindowStatusFunc</strong>
</p>
<p>
<code>glut.glutWindowStatusFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutKeyboardUpFunc</strong>
</p>
<p>
<code>glut.glutKeyboardUpFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutSpecialUpFunc</strong>
</p>
<p>
<code>glut.glutSpecialUpFunc(func:function:nil):void</code>
</p>
<p>
<strong>glut.glutJoystickFunc</strong>
</p>
<p>
<code>glut.glutJoystickFunc(func:function:nil, pollInterval:number):void</code>
</p>
<p>
<strong>glut.glutSetColor</strong>
</p>
<p>
<code>glut.glutSetColor(ndx:number, red:number, green:number, blue:number):void</code>
</p>
<p>
<strong>glut.glutGetColor</strong>
</p>
<p>
<code>glut.glutGetColor(ndx:number, component:number):map {block?}</code>
</p>
<p>
<strong>glut.glutCopyColormap</strong>
</p>
<p>
<code>glut.glutCopyColormap(win:number):map:void</code>
</p>
<p>
<strong>glut.glutGet</strong>
</p>
<p>
<code>glut.glutGet(type:number):map {block?}</code>
</p>
<p>
<strong>glut.glutDeviceGet</strong>
</p>
<p>
<code>glut.glutDeviceGet(type:number):map {block?}</code>
</p>
<p>
<strong>glut.glutExtensionSupported</strong>
</p>
<p>
<code>glut.glutExtensionSupported(name:string):map {block?}</code>
</p>
<p>
<strong>glut.glutGetModifiers</strong>
</p>
<p>
<code>glut.glutGetModifiers() {block?}</code>
</p>
<p>
<strong>glut.glutLayerGet</strong>
</p>
<p>
<code>glut.glutLayerGet(type:number):map {block?}</code>
</p>
<p>
<strong>glut.glutGetProcAddress</strong>
</p>
<p>
<code>glut.glutGetProcAddress(procName:string):map:void {block?}</code>
</p>
<p>
<strong>glut.glutBitmapCharacter</strong>
</p>
<p>
<code>glut.glutBitmapCharacter(font:glut.Font, character:number):map:void</code>
</p>
<p>
<strong>glut.glutBitmapWidth</strong>
</p>
<p>
<code>glut.glutBitmapWidth(font:glut.Font, character:number):map {block?}</code>
</p>
<p>
<strong>glut.glutStrokeCharacter</strong>
</p>
<p>
<code>glut.glutStrokeCharacter(font:glut.Font, character:number):map:void</code>
</p>
<p>
<strong>glut.glutStrokeWidth</strong>
</p>
<p>
<code>glut.glutStrokeWidth(font:glut.Font, character:number):map {block?}</code>
</p>
<p>
<strong>glut.glutBitmapLength</strong>
</p>
<p>
<code>glut.glutBitmapLength(font:glut.Font, string:string):map {block?}</code>
</p>
<p>
<strong>glut.glutStrokeLength</strong>
</p>
<p>
<code>glut.glutStrokeLength(font:glut.Font, string:string):map {block?}</code>
</p>
<p>
<strong>glut.glutWireSphere</strong>
</p>
<p>
<code>glut.glutWireSphere(radius:number, slices:number, stacks:number):map:void</code>
</p>
<p>
<strong>glut.glutSolidSphere</strong>
</p>
<p>
<code>glut.glutSolidSphere(radius:number, slices:number, stacks:number):map:void</code>
</p>
<p>
<strong>glut.glutWireCone</strong>
</p>
<p>
<code>glut.glutWireCone(base:number, height:number, slices:number, stacks:number):map:void</code>
</p>
<p>
<strong>glut.glutSolidCone</strong>
</p>
<p>
<code>glut.glutSolidCone(base:number, height:number, slices:number, stacks:number):map:void</code>
</p>
<p>
<strong>glut.glutWireCube</strong>
</p>
<p>
<code>glut.glutWireCube(size:number):map:void</code>
</p>
<p>
<strong>glut.glutSolidCube</strong>
</p>
<p>
<code>glut.glutSolidCube(size:number):map:void</code>
</p>
<p>
<strong>glut.glutWireTorus</strong>
</p>
<p>
<code>glut.glutWireTorus(innerRadius:number, outerRadius:number, sides:number, rings:number):map:void</code>
</p>
<p>
<strong>glut.glutSolidTorus</strong>
</p>
<p>
<code>glut.glutSolidTorus(innerRadius:number, outerRadius:number, sides:number, rings:number):map:void</code>
</p>
<p>
<strong>glut.glutWireDodecahedron</strong>
</p>
<p>
<code>glut.glutWireDodecahedron():void</code>
</p>
<p>
<strong>glut.glutSolidDodecahedron</strong>
</p>
<p>
<code>glut.glutSolidDodecahedron():void</code>
</p>
<p>
<strong>glut.glutWireTeapot</strong>
</p>
<p>
<code>glut.glutWireTeapot(size:number):map:void</code>
</p>
<p>
<strong>glut.glutSolidTeapot</strong>
</p>
<p>
<code>glut.glutSolidTeapot(size:number):map:void</code>
</p>
<p>
<strong>glut.glutWireOctahedron</strong>
</p>
<p>
<code>glut.glutWireOctahedron():void</code>
</p>
<p>
<strong>glut.glutSolidOctahedron</strong>
</p>
<p>
<code>glut.glutSolidOctahedron():void</code>
</p>
<p>
<strong>glut.glutWireTetrahedron</strong>
</p>
<p>
<code>glut.glutWireTetrahedron():void</code>
</p>
<p>
<strong>glut.glutSolidTetrahedron</strong>
</p>
<p>
<code>glut.glutSolidTetrahedron():void</code>
</p>
<p>
<strong>glut.glutWireIcosahedron</strong>
</p>
<p>
<code>glut.glutWireIcosahedron():void</code>
</p>
<p>
<strong>glut.glutSolidIcosahedron</strong>
</p>
<p>
<code>glut.glutSolidIcosahedron():void</code>
</p>
<p>
<strong>glut.glutVideoResizeGet</strong>
</p>
<p>
<code>glut.glutVideoResizeGet(param:number):map {block?}</code>
</p>
<p>
<strong>glut.glutSetupVideoResizing</strong>
</p>
<p>
<code>glut.glutSetupVideoResizing():void</code>
</p>
<p>
<strong>glut.glutStopVideoResizing</strong>
</p>
<p>
<code>glut.glutStopVideoResizing():void</code>
</p>
<p>
<strong>glut.glutVideoResize</strong>
</p>
<p>
<code>glut.glutVideoResize(x:number, y:number, width:number, height:number):map:void</code>
</p>
<p>
<strong>glut.glutVideoPan</strong>
</p>
<p>
<code>glut.glutVideoPan(x:number, y:number, width:number, height:number):map:void</code>
</p>
<p>
<strong>glut.glutReportErrors</strong>
</p>
<p>
<code>glut.glutReportErrors():void</code>
</p>
<p>
<strong>glut.glutIgnoreKeyRepeat</strong>
</p>
<p>
<code>glut.glutIgnoreKeyRepeat(ignore:number):map:void</code>
</p>
<p>
<strong>glut.glutSetKeyRepeat</strong>
</p>
<p>
<code>glut.glutSetKeyRepeat(repeatMode:number):map:void</code>
</p>
<p>
<strong>glut.glutForceJoystickFunc</strong>
</p>
<p>
<code>glut.glutForceJoystickFunc():void</code>
</p>
<p>
<strong>glut.glutGameModeString</strong>
</p>
<p>
<code>glut.glutGameModeString(string:string):map:void</code>
</p>
<p>
<strong>glut.glutEnterGameMode</strong>
</p>
<p>
<code>glut.glutEnterGameMode() {block?}</code>
</p>
<p>
<strong>glut.glutLeaveGameMode</strong>
</p>
<p>
<code>glut.glutLeaveGameMode():void</code>
</p>
<p>
<strong>glut.glutGameModeGet</strong>
</p>
<p>
<code>glut.glutGameModeGet(mode:number):map {block?}</code>
</p>
<h1><span class="caption-index-1">20</span><a name="caption-20"></a>gmp Module</h1>
<p>
The <code>gmp</code> module provides measures to calculate numbers in a variable-length format. To utilize it, import the <code>gmp</code> module using <code>import</code> function.
</p>
<p>
It expands features of operators like addition and multiplier so that they can calculate such numbers.
</p>
<h2><span class="caption-index-2">20.1</span><a name="caption-20-1"></a>Module Functions</h2>
<p>
<strong>gmp.gcd</strong>
</p>
<p>
<code>gmp.gcd(num1:gmp.mpz, num2:gmp.mpz):map</code>
</p>
<p>
<strong>gmp.lcm</strong>
</p>
<p>
<code>gmp.lcm(num1:gmp.mpz, num2:gmp.mpz):map</code>
</p>
<p>
<strong>gmp.sqrt</strong>
</p>
<p>
<code>gmp.sqrt(num):map</code>
</p>
<h2><span class="caption-index-2">20.2</span><a name="caption-20-2"></a>gmp.mpf Class</h2>
<p>
<strong>gmp.mpf</strong>
</p>
<p>
<code>gmp.mpf(value?, prec?:number):map {block?}</code>
</p>
<p>
<strong>gmp.mpf.get_default_prec</strong>
</p>
<p>
<code>gmp.mpf.get_default_prec():static</code>
</p>
<p>
<strong>gmp.mpf.set_default_prec</strong>
</p>
<p>
<code>gmp.mpf.set_default_prec(prec:number):static:void</code>
</p>
<h2><span class="caption-index-2">20.3</span><a name="caption-20-3"></a>gmp.mpq Class</h2>
<p>
<strong>gmp.mpq</strong>
</p>
<p>
<code>gmp.mpq(numer?, denom?:number):map {block?}</code>
</p>
<h2><span class="caption-index-2">20.4</span><a name="caption-20-4"></a>gmp.mpz Class</h2>
<p>
<strong>gmp.mpz</strong>
</p>
<p>
<code>gmp.mpz(value?):map {block?}</code>
</p>
<h2><span class="caption-index-2">20.5</span><a name="caption-20-5"></a>Extention of string Class</h2>
<p>
<strong>string#mpf</strong>
</p>
<p>
<code>string#mpf(base?:number):map</code>
</p>
<p>
<strong>string#mpq</strong>
</p>
<p>
<code>string#mpq(base?:number):map</code>
</p>
<p>
<strong>string#mpz</strong>
</p>
<p>
<code>string#mpz(base?:number):map</code>
</p>
<h1><span class="caption-index-1">21</span><a name="caption-21"></a>guri Module</h1>
<h2><span class="caption-index-2">21.1</span><a name="caption-21-1"></a>Module Functions</h2>
<h1><span class="caption-index-1">22</span><a name="caption-22"></a>gzip Module</h1>
<p>
The <code>gzip</code> module provides measures to read/write GZIP files. To utilize it, import the <code>gzip</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read data from a GZIP file and write its uncompressed data to another file.
</p>
<pre><code>import(gzip)
gzip.reader('foo.dat.gz').copyto('foo.dat')
</code></pre>
<p>
Below is an example to read data from a file and write its compressed data to a GZIP file.
</p>
<pre><code>import(gzip)
gzip.writer('foo.dat.gz').copyfrom('foo.dat')
</code></pre>
<h2><span class="caption-index-2">22.1</span><a name="caption-22-1"></a>Module Functions</h2>
<p>
<strong>gzip.reader</strong>
</p>
<p>
<code>gzip.reader(stream:stream:r) {block?}</code>
</p>
<p>
<strong>gzip.writer</strong>
</p>
<p>
<code>gzip.writer(stream:stream:w, level?:number) {block?}</code>
</p>
<h2><span class="caption-index-2">22.2</span><a name="caption-22-2"></a>Methods Added to stream Class</h2>
<p>
<strong>stream#reader@gzip</strong>
</p>
<p>
<code>stream#reader@gzip() {block?}</code>
</p>
<p>
<strong>stream#writer@gzip</strong>
</p>
<p>
<code>stream#writer@gzip(level?:number) {block?}</code>
</p>
<h1><span class="caption-index-1">23</span><a name="caption-23"></a>hash Module</h1>
<p>
The <code>hash</code> module provides measures to calculate hash values of a data sequence in a stream. To utilize it, import the <code>hash</code> module using <code>import</code> function.
</p>
<h2><span class="caption-index-2">23.1</span><a name="caption-23-1"></a>Module Functions</h2>
<p>
<strong>hash.md5</strong>
</p>
<p>
<code>hash.md5(stream?:stream:r) {block?}</code>
</p>
<p>
<strong>hash.sha1</strong>
</p>
<p>
<code>hash.sha1(stream?:stream:r) {block?}</code>
</p>
<p>
<strong>hash.crc32</strong>
</p>
<p>
<code>hash.crc32(stream?:stream:r) {block?}</code>
</p>
<h2><span class="caption-index-2">23.2</span><a name="caption-23-2"></a>hash.accumulator Class</h2>
<p>
<strong>hash.accumulator#init</strong>
</p>
<p>
<code>hash.accumulator#init():reduce</code>
</p>
<p>
<strong>hash.accumulator#update</strong>
</p>
<p>
<code>hash.accumulator#update(stream:stream:r):reduce</code>
</p>
<h1><span class="caption-index-1">24</span><a name="caption-24"></a>http Module</h1>
<p>
The <code>http</code> module provides measures to connect the Internet through HTTP protocol.
</p>
<h2><span class="caption-index-2">24.1</span><a name="caption-24-1"></a>Module Functions</h2>
<h1><span class="caption-index-1">25</span><a name="caption-25"></a>jpeg Module</h1>
<p>
The <code>jpeg</code> module provides measures to read/write image data in JPEG format. To utilize it, import the <code>jpeg</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read a JPEG file:
</p>
<pre><code>import(jpeg)
img = image('foo.jpeg')
</code></pre>
<h2><span class="caption-index-2">25.1</span><a name="caption-25-1"></a>Exntension of Function's Capability</h2>
<p>
This module extends the capability of function <code>image()</code> and instance method <code>image#write()</code> so that they can read/write JPEG files.
</p>
<p>
When function <code>image()</code> is provided with a stream that satisfies the following conditions, it would recognize the stream as a JPEG file.
</p>
<ul>
<li>The identifier of the stream ends with a suffix <code>.jpeg</code>, <code>.jpg</code> or <code>.jpe</code>.</li>
<li>The stream data begins with a byte sequence "<code>\xff\xd8</code>" that means SOI (start of Image) marker in JPEG specification.</li>
</ul>
<p>
When instance method <code>image#write()</code> is provided with a stream that satisfies the following condition, it would write image data in JPEG format.
</p>
<ul>
<li>The identifier of the stream ends with a suffix <code>.jpeg</code>, <code>.jpg</code> or <code>.jpe</code>.</li>
</ul>
<h2><span class="caption-index-2">25.2</span><a name="caption-25-2"></a>jpeg.exif Class</h2>
<p>
<strong>jpeg.exif</strong>
</p>
<p>
<code>jpeg.exif(stream?:stream:r):map:[raise] {block?}</code>
</p>
<p>
<strong>jpeg.exif#each</strong>
</p>
<p>
<code>jpeg.exif#each() {block?}</code>
</p>
<h2><span class="caption-index-2">25.3</span><a name="caption-25-3"></a>jpeg.ifd Class</h2>
<p>
<strong>jpeg.ifd#each</strong>
</p>
<p>
<code>jpeg.ifd#each() {block?}</code>
</p>
<h2><span class="caption-index-2">25.4</span><a name="caption-25-4"></a>jpeg.tag Class</h2>
<h2><span class="caption-index-2">25.5</span><a name="caption-25-5"></a>Methods Added to image Class</h2>
<p>
<strong>image#read@jpeg</strong>
</p>
<p>
<code>image#read@jpeg(stream:stream:r):reduce</code>
</p>
<p>
Reads a JPEG image data from a stream.
</p>
<p>
<strong>image#write@jpeg</strong>
</p>
<p>
<code>image#write@jpeg(stream:stream:w, quality:number =&gt; 75):reduce</code>
</p>
<p>
Writes a JPEG image data to a stream.
</p>
<h1><span class="caption-index-1">26</span><a name="caption-26"></a>llvm Module</h1>
<h2><span class="caption-index-2">26.1</span><a name="caption-26-1"></a>Module Functions</h2>
<h1><span class="caption-index-1">27</span><a name="caption-27"></a>markdown Module</h1>
<p>
The <code>markdown</code> module provides measures to parse a text formatted in markdown syntax. To utilize it, import the <code>markdown</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read a document written in Markdown format and then render its HTML text into a file.
</p>
<pre><code>import(markdown)
markdown.document('foo.md').render@html('foo.html')
</code></pre>
<p>
<code>markdown</code> module consists of the following two module files:
</p>
<ul>
<li><code>markdown.gurd</code> .. a binary module file that provides parser procedures.</li>
<li><code>markdown.gura</code> .. a script module file that renders parsed result in desired formats.</li>
</ul>
<h2><span class="caption-index-2">27.1</span><a name="caption-27-1"></a>Module Functions</h2>
<p>
<strong>markdown.document</strong>
</p>
<p>
<code>markdown.document(stream?:stream:r) {block?}</code>
</p>
<p>
Returns an instance of <code>markdown.document</code>. If <code>stream</code> is specified, the content of the instance shall be initialized with the result of parsing the stream.
</p>
<p>
<strong>markdown.setpresenter</strong>
</p>
<p>
<code>markdown.setpresenter():void {block}</code>
</p>
<p>
Sets a presentation procedure that shows helps written in Markdown format. The procedure is written in the function's block that takes block parameters: <code>|title:string, doc:markdown.document|</code>.
</p>
<h2><span class="caption-index-2">27.2</span><a name="caption-27-2"></a>markdown.document Class</h2>
<p>
<strong>markdown.document#parse</strong>
</p>
<p>
<code>markdown.document#parse(str:string):void</code>
</p>
<p>
Parses a Markdown text in a string.
</p>
<p>
<strong>markdown.document#read</strong>
</p>
<p>
<code>markdown.document#read(stream:stream:r):void</code>
</p>
<p>
Parses a Markdown text from a stream.
</p>
<h2><span class="caption-index-2">27.3</span><a name="caption-27-3"></a>markdown.item Class</h2>
<p>
<strong>markdown.item#print</strong>
</p>
<p>
<code>markdown.item#print(indent?:number):void</code>
</p>
<p>
Prints structured content of the item. Argument <code>indent</code> specifies an indentation level and is set to zero when omitted.
</p>
<h1><span class="caption-index-1">28</span><a name="caption-28"></a>math Module</h1>
<p>
The <code>math</code> module provices functions for mathematical calculation. This is a built-in module, so you can use it without being imported.
</p>
<h2><span class="caption-index-2">28.1</span><a name="caption-28-1"></a>Module Functions</h2>
<p>
<strong>math.real</strong>
</p>
<p>
<code>math.real(num):map</code>
</p>
<p>
Returns a real part of a complex number.
</p>
<p>
<strong>math.imag</strong>
</p>
<p>
<code>math.imag(num):map</code>
</p>
<p>
Returns an imaginary part of a complex number.
</p>
<p>
<strong>math.arg</strong>
</p>
<p>
<code>math.arg(num):map:[deg]</code>
</p>
<p>
Returns an argument value of a complex number in radian.
</p>
<p>
<strong>math.norm</strong>
</p>
<p>
<code>math.norm(num):map</code>
</p>
<p>
Returns a norm value of a complex number.
</p>
<p>
<strong>math.conj</strong>
</p>
<p>
<code>math.conj(num):map</code>
</p>
<p>
Returns a conjugate of a complex number.
</p>
<p>
<strong>math.acos</strong>
</p>
<p>
<code>math.acos(num):map:[deg]</code>
</p>
<p>
Returns an inverse cosine value.
</p>
<p>
<strong>math.asin</strong>
</p>
<p>
<code>math.asin(num):map:[deg]</code>
</p>
<p>
Returns an inverse sine value.
</p>
<p>
<strong>math.atan</strong>
</p>
<p>
<code>math.atan(num):map:[deg]</code>
</p>
<p>
Returns an inverse tangent value.
</p>
<p>
<strong>math.atan2</strong>
</p>
<p>
<code>math.atan2(num1, num2):map:[deg]</code>
</p>
<p>
Returns an inverse tangent value of a fraction of num1 and num2.
</p>
<p>
<strong>math.ceil</strong>
</p>
<p>
<code>math.ceil(num):map</code>
</p>
<p>
Returns a nearest integer number above or equal to the specified value.
</p>
<p>
<strong>math.cos</strong>
</p>
<p>
<code>math.cos(num):map:[deg]</code>
</p>
<p>
Returns a cosine value.
</p>
<p>
<strong>math.cosh</strong>
</p>
<p>
<code>math.cosh(num):map</code>
</p>
<p>
Returns a hyperbolic cosine value.
</p>
<p>
<strong>math.exp</strong>
</p>
<p>
<code>math.exp(num):map</code>
</p>
<p>
Returns an exponential value.
</p>
<p>
<strong>math.abs</strong>
</p>
<p>
<code>math.abs(num):map</code>
</p>
<p>
Returns an absolute value.
</p>
<p>
<strong>math.floor</strong>
</p>
<p>
<code>math.floor(num):map</code>
</p>
<p>
Returns a nearest integer number below or equal to the specified value.
</p>
<p>
<strong>math.log</strong>
</p>
<p>
<code>math.log(num):map</code>
</p>
<p>
Returns a natural logarithm value.
</p>
<p>
<strong>math.log10</strong>
</p>
<p>
<code>math.log10(num):map</code>
</p>
<p>
Returns a decadic logarithm value.
</p>
<p>
<strong>math.sin</strong>
</p>
<p>
<code>math.sin(num):map:[deg]</code>
</p>
<p>
Returns a sine value.
</p>
<p>
<strong>math.sinh</strong>
</p>
<p>
<code>math.sinh(num):map</code>
</p>
<p>
Returns a hyperbolic sine value.
</p>
<p>
<strong>math.sqrt</strong>
</p>
<p>
<code>math.sqrt(num):map</code>
</p>
<p>
Returns a square root value.
</p>
<p>
<strong>math.tan</strong>
</p>
<p>
<code>math.tan(num):map:[deg]</code>
</p>
<p>
Returns a tangent value.
</p>
<p>
<strong>math.tanh</strong>
</p>
<p>
<code>math.tanh(num):map</code>
</p>
<p>
Returns a hyperbolic tangent value.
</p>
<p>
<strong>math.hypot</strong>
</p>
<p>
<code>math.hypot(x, y):map</code>
</p>
<p>
Returns a hyperbolic tangent value.
</p>
<p>
<strong>math.least_square</strong>
</p>
<p>
<code>math.least_square(x:iterator, y:iterator, dim:number =&gt; 1, var:symbol =&gt; `x)</code>
</p>
<p>
Calculates a least square method using a sequence of pairs of <code>x</code> and <code>y</code>, and returns an expression of the fitted curve. You can specify the dimension by an argument <code>dim</code>. In default, a symbol of the expression's variable is <code>x</code>and it can be changed by specifying an argument <code>var</code>.
</p>
<p>
<strong>math.bezier</strong>
</p>
<p>
<code>math.bezier(nums[]+:number)</code>
</p>
<p>
Returns a list that consists of functions that generate coordinates of bezier curves with specified control points. One or more lists of control points can be specified. This means that if you give it two lists of numbers as arguments, it returns two functions of bezier curve.
</p>
<p>
<strong>math.diff</strong>
</p>
<p>
<code>math.diff(expr:expr, var:symbol):map {block?}</code>
</p>
<p>
Returns a mathematical differential expression of the given <code>expr</code> by a variable <code>var</code>.
</p>
<p>
Example: <code>math.diff(</code>(math.sin(x <strong> 2)), <code>x)</code></strong>
</p>
<p>
<strong>math.optimize</strong>
</p>
<p>
<code>math.optimize(expr:expr):map {block?}</code>
</p>
<p>
<strong>math.fft</strong>
</p>
<p>
<code>math.fft(seq[])</code>
</p>
<p>
<strong>math.dot_product</strong>
</p>
<p>
<code>math.dot_product(a[], b[])</code>
</p>
<p>
<strong>math.cross_product</strong>
</p>
<p>
<code>math.cross_product(a[], b[])</code>
</p>
<p>
<strong>math.covariance</strong>
</p>
<p>
<code>math.covariance(a:iterator, b:iterator)</code>
</p>
<p>
Returns a covariance between the sequences of values.
</p>
<p>
<strong>math.integral</strong>
</p>
<p>
<code>math.integral()</code>
</p>
<p>
<strong>math.gcd</strong>
</p>
<p>
<code>math.gcd(a:number, b+:number):map</code>
</p>
<p>
Returns a greatest common divisor among two or more numbers.
</p>
<p>
<strong>math.lcm</strong>
</p>
<p>
<code>math.lcm(a:number, b+:number):map</code>
</p>
<p>
Returns a least common multiple among two or more numbers.
</p>
<h1><span class="caption-index-1">29</span><a name="caption-29"></a>midi Module</h1>
<p>
The <code>midi</code> module provides measures to read/write MIDI files. To utilize it, import the <code>midi</code> module using <code>import</code> function.
</p>
<h2><span class="caption-index-2">29.1</span><a name="caption-29-1"></a>Module Functions</h2>
<h2><span class="caption-index-2">29.2</span><a name="caption-29-2"></a>midi.event Class</h2>
<h2><span class="caption-index-2">29.3</span><a name="caption-29-3"></a>midi.track Class</h2>
<p>
<strong>midi.track#seek</strong>
</p>
<p>
<code>midi.track#seek(offset:number, origin?:symbol):reduce</code>
</p>
<p>
Moves the insertion point in the track at which the next event is inserted. If <code>origin</code> is omitted or set to <code>`set</code>, the insertion point will be set to absolute offset from the beginning. If <code>origin</code> is set to <code>`cur</code>, the insertion point will be moved by offset from the current position.
</p>
<p>
<strong>midi.track#tell</strong>
</p>
<p>
<code>midi.track#tell()</code>
</p>
<p>
Returns the current insertion point in the track.
</p>
<p>
<strong>midi.track#erase</strong>
</p>
<p>
<code>midi.track#erase(n?:number):reduce</code>
</p>
<p>
Deletes an event at the current insertion point in the track. The argument <code>n</code> specifies the number of events to be deleted. If <code>n</code> is omitted, one event will be deleted.
</p>
<p>
<strong>midi.track#mml</strong>
</p>
<p>
<code>midi.track#mml(str:string, max_velocity?:number):map:reduce</code>
</p>
<p>
Parses MML in the string <code>str</code> and inserts resulted MIDI events at the current insertion point in the track.
</p>
<p>
The argument <code>max_velocity</code> specifies the maximum number of velocity in the MML. If omitted, it will be set to 127.
</p>
<p>
<strong>midi.track#note_off</strong>
</p>
<p>
<code>midi.track#note_off(channel:number, note:number, velocity:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#note_on</strong>
</p>
<p>
<code>midi.track#note_on(channel:number, note:number, velocity:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#poly_pressure</strong>
</p>
<p>
<code>midi.track#poly_pressure(channel:number, note:number, value:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#control_change</strong>
</p>
<p>
<code>midi.track#control_change(channel:number, controller, value:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#program_change</strong>
</p>
<p>
<code>midi.track#program_change(channel:number, program, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#channel_pressure</strong>
</p>
<p>
<code>midi.track#channel_pressure(channel:number, pressure:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#pitch_bend</strong>
</p>
<p>
<code>midi.track#pitch_bend(channel:number, value:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#sequence_number</strong>
</p>
<p>
<code>midi.track#sequence_number(number:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#text_event</strong>
</p>
<p>
<code>midi.track#text_event(text:string, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#copyright_notice</strong>
</p>
<p>
<code>midi.track#copyright_notice(text:string, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#sequence_or_track_name</strong>
</p>
<p>
<code>midi.track#sequence_or_track_name(text:string, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#instrument_name</strong>
</p>
<p>
<code>midi.track#instrument_name(text:string, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#lyric_text</strong>
</p>
<p>
<code>midi.track#lyric_text(text:string, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#marker_text</strong>
</p>
<p>
<code>midi.track#marker_text(text:string, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#cue_point</strong>
</p>
<p>
<code>midi.track#cue_point(text:string, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#midi_channel_prefix_assignment</strong>
</p>
<p>
<code>midi.track#midi_channel_prefix_assignment(channel:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#end_of_track</strong>
</p>
<p>
<code>midi.track#end_of_track(deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#tempo_setting</strong>
</p>
<p>
<code>midi.track#tempo_setting(mpqn:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#smpte_offset</strong>
</p>
<p>
<code>midi.track#smpte_offset(hour:number, minute:number, second:number, frame:number, subFrame:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#time_signature</strong>
</p>
<p>
<code>midi.track#time_signature(numerator:number, denominator:number, metronome:number, cnt32nd:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#key_signature</strong>
</p>
<p>
<code>midi.track#key_signature(key:number, scale:number, deltaTime?:number):map:reduce</code>
</p>
<p>
<strong>midi.track#sequencer_specific_event</strong>
</p>
<p>
<code>midi.track#sequencer_specific_event(binary:binary, deltaTime?:number):map:reduce</code>
</p>
<h2><span class="caption-index-2">29.4</span><a name="caption-29-4"></a>midi.sequence Class</h2>
<p>
<strong>midi.sequence</strong>
</p>
<p>
<code>midi.sequence(stream?:stream) {block?}</code>
</p>
<p>
It creates an instance that contains SMF information.
</p>
<p>
<strong>midi.sequence#read</strong>
</p>
<p>
<code>midi.sequence#read(stream:stream:r):map:reduce</code>
</p>
<p>
<strong>midi.sequence#write</strong>
</p>
<p>
<code>midi.sequence#write(stream:stream:w):map:reduce</code>
</p>
<p>
<strong>midi.sequence#play</strong>
</p>
<p>
<code>midi.sequence#play(port:midi.port, speed?:number, repeat:number:nil =&gt; 1):[background,player]</code>
</p>
<p>
<strong>midi.sequence#track</strong>
</p>
<p>
<code>midi.sequence#track(index:number):map {block?}</code>
</p>
<p>
<strong>midi.sequence#mml</strong>
</p>
<p>
<code>midi.sequence#mml(str:string, max_velocity?:number):reduce</code>
</p>
<p>
<strong>midi.sequence#readmml</strong>
</p>
<p>
<code>midi.sequence#readmml(stream:stream, max_velocity?:number):reduce</code>
</p>
<h2><span class="caption-index-2">29.5</span><a name="caption-29-5"></a>midi.portinfo Class</h2>
<h2><span class="caption-index-2">29.6</span><a name="caption-29-6"></a>midi.port Class</h2>
<p>
<strong>midi.port#send</strong>
</p>
<p>
<code>midi.port#send(msg+:number):map:reduce</code>
</p>
<p>
<strong>midi.port#play</strong>
</p>
<p>
<code>midi.port#play(sequence:midi.sequence, speed?:number, repeat:number:nil =&gt; 1):map:[background,player]</code>
</p>
<p>
<strong>midi.port#mml</strong>
</p>
<p>
<code>midi.port#mml(str:string, max_velocity?:number):[background,player]</code>
</p>
<p>
<strong>midi.port#readmml</strong>
</p>
<p>
<code>midi.port#readmml(stream:stream, max_velocity?:number):[background,player]</code>
</p>
<p>
<strong>midi.port#note_off</strong>
</p>
<p>
<code>midi.port#note_off(channel:number, note:number, velocity:number):map:reduce</code>
</p>
<p>
<strong>midi.port#note_on</strong>
</p>
<p>
<code>midi.port#note_on(channel:number, note:number, velocity:number):map:reduce</code>
</p>
<p>
<strong>midi.port#poly_pressure</strong>
</p>
<p>
<code>midi.port#poly_pressure(channel:number, note:number, value:number):map:reduce</code>
</p>
<p>
<strong>midi.port#control_change</strong>
</p>
<p>
<code>midi.port#control_change(channel:number, controller:number, value:number):map:reduce</code>
</p>
<p>
<strong>midi.port#program_change</strong>
</p>
<p>
<code>midi.port#program_change(channel:number, program:number):map:reduce</code>
</p>
<p>
<strong>midi.port#channel_pressure</strong>
</p>
<p>
<code>midi.port#channel_pressure(channel:number, pressure:number):map:reduce</code>
</p>
<p>
<strong>midi.port#pitch_bend</strong>
</p>
<p>
<code>midi.port#pitch_bend(channel:number, value:number):map:reduce</code>
</p>
<h2><span class="caption-index-2">29.7</span><a name="caption-29-7"></a>midi.player Class</h2>
<h2><span class="caption-index-2">29.8</span><a name="caption-29-8"></a>midi.controller Class</h2>
<h2><span class="caption-index-2">29.9</span><a name="caption-29-9"></a>midi.program Class</h2>
<h2><span class="caption-index-2">29.10</span><a name="caption-29-10"></a>midi.soundfont Class</h2>
<p>
<strong>midi.soundfont</strong>
</p>
<p>
<code>midi.soundfont(stream:stream) {block?}</code>
</p>
<p>
It creates an instance to access data in SoundFont file.
</p>
<p>
<strong>midi.soundfont#synthesizer</strong>
</p>
<p>
<code>midi.soundfont#synthesizer(preset:number, bank:number, key:number, velocity:number):map {block?}</code>
</p>
<p>
<strong>midi.soundfont#print</strong>
</p>
<p>
<code>midi.soundfont#print():void</code>
</p>
<h2><span class="caption-index-2">29.11</span><a name="caption-29-11"></a>midi.synthesizer Class</h2>
<h1><span class="caption-index-1">30</span><a name="caption-30"></a>msico Module</h1>
<p>
The <code>msico</code> module provides measures to read/write image data in Microsoft Icon file format. To utilize it, import the <code>msico</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read an ICO file:
</p>
<pre><code>import(msico)
img = image('foo.ico')
</code></pre>
<h2><span class="caption-index-2">30.1</span><a name="caption-30-1"></a>Module Functions</h2>
<h2><span class="caption-index-2">30.2</span><a name="caption-30-2"></a>msico.content Class</h2>
<p>
<strong>msico.content</strong>
</p>
<p>
<code>msico.content(stream?:stream:r, format:symbol =&gt; `rgba) {block?}</code>
</p>
<p>
<strong>msico.content#write</strong>
</p>
<p>
<code>msico.content#write(stream:stream:w):reduce</code>
</p>
<p>
Writes an ICO image to a stream.
</p>
<p>
<strong>msico.content#addimage</strong>
</p>
<p>
<code>msico.content#addimage(image:image):map:reduce</code>
</p>
<h2><span class="caption-index-2">30.3</span><a name="caption-30-3"></a>Methods Added to image Class</h2>
<p>
<strong>image#read@msico</strong>
</p>
<p>
<code>image#read@msico(stream:stream:r, idx:number =&gt; 0):reduce</code>
</p>
<p>
Reads an ICO image from a stream.
</p>
<h1><span class="caption-index-1">31</span><a name="caption-31"></a>mysql Module</h1>
<h2><span class="caption-index-2">31.1</span><a name="caption-31-1"></a>Module Functions</h2>
<h1><span class="caption-index-1">32</span><a name="caption-32"></a>opengl Module</h1>
<p>
The <code>opengl</code> module provides functions of OpenGL library.
</p>
<h2><span class="caption-index-2">32.1</span><a name="caption-32-1"></a>Module Functions</h2>
<p>
<strong>opengl.glAccum</strong>
</p>
<p>
<code>opengl.glAccum(op:number, value:number):map:void</code>
</p>
<p>
operate on the accumulation buffer
</p>
<p>
<strong>opengl.glAlphaFunc</strong>
</p>
<p>
<code>opengl.glAlphaFunc(func:number, ref:number):map:void</code>
</p>
<p>
specify the alpha test function
</p>
<p>
<strong>opengl.glAreTexturesResident</strong>
</p>
<p>
<code>opengl.glAreTexturesResident(textures:array@uint:nomap):map {block?}</code>
</p>
<p>
determine if textures are loaded in texture memory
</p>
<p>
<strong>opengl.glArrayElement</strong>
</p>
<p>
<code>opengl.glArrayElement(i:number):map:void</code>
</p>
<p>
render a vertex using the specified vertex array element
</p>
<p>
<strong>opengl.glBegin</strong>
</p>
<p>
<code>opengl.glBegin(mode:number):map:void {block?}</code>
</p>
<p>
delimit the vertices of a primitive or a group of like primitives
</p>
<p>
<strong>opengl.glBindTexture</strong>
</p>
<p>
<code>opengl.glBindTexture(target:number, texture:number):map:void</code>
</p>
<p>
<strong>opengl.glBitmap</strong>
</p>
<p>
<code>opengl.glBitmap(width:number, height:number, xorig:number, yorig:number, xmove:number, ymove:number, bitmap:array@uchar:nomap:nil):map:void</code>
</p>
<p>
<strong>opengl.glBlendFunc</strong>
</p>
<p>
<code>opengl.glBlendFunc(sfactor:number, dfactor:number):map:void</code>
</p>
<p>
<strong>opengl.glCallList</strong>
</p>
<p>
<code>opengl.glCallList(list:number):map:void</code>
</p>
<p>
<strong>opengl.glCallLists</strong>
</p>
<p>
<code>opengl.glCallLists(type:number, lists[]:number):map:void</code>
</p>
<p>
<strong>opengl.glClear</strong>
</p>
<p>
<code>opengl.glClear(mask:number):map:void</code>
</p>
<p>
<strong>opengl.glClearAccum</strong>
</p>
<p>
<code>opengl.glClearAccum(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glClearColor</strong>
</p>
<p>
<code>opengl.glClearColor(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glClearDepth</strong>
</p>
<p>
<code>opengl.glClearDepth(depth:number):map:void</code>
</p>
<p>
<strong>opengl.glClearIndex</strong>
</p>
<p>
<code>opengl.glClearIndex(c:number):map:void</code>
</p>
<p>
<strong>opengl.glClearStencil</strong>
</p>
<p>
<code>opengl.glClearStencil(s:number):map:void</code>
</p>
<p>
<strong>opengl.glClipPlane</strong>
</p>
<p>
<code>opengl.glClipPlane(plane:number, equation:array@double:nomap):map {block?}</code>
</p>
<p>
<strong>opengl.glColor3b</strong>
</p>
<p>
<code>opengl.glColor3b(red:number, green:number, blue:number):map:void</code>
</p>
<p>
<strong>opengl.glColor3bv</strong>
</p>
<p>
<code>opengl.glColor3bv(v:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor3d</strong>
</p>
<p>
<code>opengl.glColor3d(red:number, green:number, blue:number):map:void</code>
</p>
<p>
<strong>opengl.glColor3dv</strong>
</p>
<p>
<code>opengl.glColor3dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor3f</strong>
</p>
<p>
<code>opengl.glColor3f(red:number, green:number, blue:number):map:void</code>
</p>
<p>
<strong>opengl.glColor3fv</strong>
</p>
<p>
<code>opengl.glColor3fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor3i</strong>
</p>
<p>
<code>opengl.glColor3i(red:number, green:number, blue:number):map:void</code>
</p>
<p>
<strong>opengl.glColor3iv</strong>
</p>
<p>
<code>opengl.glColor3iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor3s</strong>
</p>
<p>
<code>opengl.glColor3s(red:number, green:number, blue:number):map:void</code>
</p>
<p>
<strong>opengl.glColor3sv</strong>
</p>
<p>
<code>opengl.glColor3sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor3ub</strong>
</p>
<p>
<code>opengl.glColor3ub(red:number, green:number, blue:number):map:void</code>
</p>
<p>
<strong>opengl.glColor3ubv</strong>
</p>
<p>
<code>opengl.glColor3ubv(v:array@uchar:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor3ui</strong>
</p>
<p>
<code>opengl.glColor3ui(red:number, green:number, blue:number):map:void</code>
</p>
<p>
<strong>opengl.glColor3uiv</strong>
</p>
<p>
<code>opengl.glColor3uiv(v:array@uint:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor3us</strong>
</p>
<p>
<code>opengl.glColor3us(red:number, green:number, blue:number):map:void</code>
</p>
<p>
<strong>opengl.glColor3usv</strong>
</p>
<p>
<code>opengl.glColor3usv(v:array@ushort:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor4b</strong>
</p>
<p>
<code>opengl.glColor4b(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glColor4bv</strong>
</p>
<p>
<code>opengl.glColor4bv(v:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor4d</strong>
</p>
<p>
<code>opengl.glColor4d(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glColor4dv</strong>
</p>
<p>
<code>opengl.glColor4dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor4f</strong>
</p>
<p>
<code>opengl.glColor4f(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glColor4fv</strong>
</p>
<p>
<code>opengl.glColor4fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor4i</strong>
</p>
<p>
<code>opengl.glColor4i(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glColor4iv</strong>
</p>
<p>
<code>opengl.glColor4iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor4s</strong>
</p>
<p>
<code>opengl.glColor4s(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glColor4sv</strong>
</p>
<p>
<code>opengl.glColor4sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor4ub</strong>
</p>
<p>
<code>opengl.glColor4ub(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glColor4ubv</strong>
</p>
<p>
<code>opengl.glColor4ubv(v:array@uchar:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor4ui</strong>
</p>
<p>
<code>opengl.glColor4ui(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glColor4uiv</strong>
</p>
<p>
<code>opengl.glColor4uiv(v:array@uint:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColor4us</strong>
</p>
<p>
<code>opengl.glColor4us(red:number, green:number, blue:number, alpha:number):map:void</code>
</p>
<p>
<strong>opengl.glColor4usv</strong>
</p>
<p>
<code>opengl.glColor4usv(v:array@ushort:nomap):map:void</code>
</p>
<p>
<strong>opengl.glColorMask</strong>
</p>
<p>
<code>opengl.glColorMask(red:boolean, green:boolean, blue:boolean, alpha:boolean):map:void</code>
</p>
<p>
<strong>opengl.glColorMaterial</strong>
</p>
<p>
<code>opengl.glColorMaterial(face:number, mode:number):map:void</code>
</p>
<p>
<strong>opengl.glCopyPixels</strong>
</p>
<p>
<code>opengl.glCopyPixels(x:number, y:number, width:number, height:number, type:number):map:void</code>
</p>
<p>
<strong>opengl.glCopyTexImage1D</strong>
</p>
<p>
<code>opengl.glCopyTexImage1D(target:number, level:number, internalformat:number, x:number, y:number, width:number, border:number):map:void</code>
</p>
<p>
<strong>opengl.glCopyTexImage2D</strong>
</p>
<p>
<code>opengl.glCopyTexImage2D(target:number, level:number, internalformat:number, x:number, y:number, width:number, height:number, border:number):map:void</code>
</p>
<p>
<strong>opengl.glCopyTexSubImage1D</strong>
</p>
<p>
<code>opengl.glCopyTexSubImage1D(target:number, level:number, xoffset:number, x:number, y:number, width:number):map:void</code>
</p>
<p>
<strong>opengl.glCopyTexSubImage2D</strong>
</p>
<p>
<code>opengl.glCopyTexSubImage2D(target:number, level:number, xoffset:number, yoffset:number, x:number, y:number, width:number, height:number):map:void</code>
</p>
<p>
<strong>opengl.glCullFace</strong>
</p>
<p>
<code>opengl.glCullFace(mode:number):map:void</code>
</p>
<p>
<strong>opengl.glDeleteLists</strong>
</p>
<p>
<code>opengl.glDeleteLists(list:number, range:number):map:void</code>
</p>
<p>
<strong>opengl.glDeleteTextures</strong>
</p>
<p>
<code>opengl.glDeleteTextures(textures:array@uint:nomap):map:void</code>
</p>
<p>
<strong>opengl.glDepthFunc</strong>
</p>
<p>
<code>opengl.glDepthFunc(func:number):map:void</code>
</p>
<p>
<strong>opengl.glDepthMask</strong>
</p>
<p>
<code>opengl.glDepthMask(flag:boolean):map:void</code>
</p>
<p>
<strong>opengl.glDepthRange</strong>
</p>
<p>
<code>opengl.glDepthRange(zNear:number, zFar:number):map:void</code>
</p>
<p>
<strong>opengl.glDisable</strong>
</p>
<p>
<code>opengl.glDisable(cap:number):map:void</code>
</p>
<p>
<strong>opengl.glDisableClientState</strong>
</p>
<p>
<code>opengl.glDisableClientState(array:number):map:void</code>
</p>
<p>
<strong>opengl.glDrawArrays</strong>
</p>
<p>
<code>opengl.glDrawArrays(mode:number, first:number, count:number):map:void</code>
</p>
<p>
<strong>opengl.glDrawBuffer</strong>
</p>
<p>
<code>opengl.glDrawBuffer(mode:number):map:void</code>
</p>
<p>
<strong>opengl.glDrawPixels</strong>
</p>
<p>
<code>opengl.glDrawPixels(width:number, height:number, format:number, type:number, pixels):map:void</code>
</p>
<p>
<strong>opengl.glDrawPixelsFromImage</strong>
</p>
<p>
<code>opengl.glDrawPixelsFromImage(image:image):map:void</code>
</p>
<p>
<strong>opengl.glEdgeFlag</strong>
</p>
<p>
<code>opengl.glEdgeFlag(flag:boolean):map:void</code>
</p>
<p>
<strong>opengl.glEdgeFlagv</strong>
</p>
<p>
<code>opengl.glEdgeFlagv(flag[]:boolean):map:void</code>
</p>
<p>
<strong>opengl.glEnable</strong>
</p>
<p>
<code>opengl.glEnable(cap:number):map:void</code>
</p>
<p>
<strong>opengl.glEnableClientState</strong>
</p>
<p>
<code>opengl.glEnableClientState(array:number):map:void</code>
</p>
<p>
<strong>opengl.glEnd</strong>
</p>
<p>
<code>opengl.glEnd():void</code>
</p>
<p>
<strong>opengl.glEndList</strong>
</p>
<p>
<code>opengl.glEndList():void</code>
</p>
<p>
<strong>opengl.glEvalCoord1d</strong>
</p>
<p>
<code>opengl.glEvalCoord1d(u:number):map:void</code>
</p>
<p>
<strong>opengl.glEvalCoord1dv</strong>
</p>
<p>
<code>opengl.glEvalCoord1dv(u:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glEvalCoord1f</strong>
</p>
<p>
<code>opengl.glEvalCoord1f(u:number):map:void</code>
</p>
<p>
<strong>opengl.glEvalCoord1fv</strong>
</p>
<p>
<code>opengl.glEvalCoord1fv(u:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glEvalCoord2d</strong>
</p>
<p>
<code>opengl.glEvalCoord2d(u:number, v:number):map:void</code>
</p>
<p>
<strong>opengl.glEvalCoord2dv</strong>
</p>
<p>
<code>opengl.glEvalCoord2dv(u:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glEvalCoord2f</strong>
</p>
<p>
<code>opengl.glEvalCoord2f(u:number, v:number):map:void</code>
</p>
<p>
<strong>opengl.glEvalCoord2fv</strong>
</p>
<p>
<code>opengl.glEvalCoord2fv(u:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glEvalMesh1</strong>
</p>
<p>
<code>opengl.glEvalMesh1(mode:number, i1:number, i2:number):map:void</code>
</p>
<p>
<strong>opengl.glEvalMesh2</strong>
</p>
<p>
<code>opengl.glEvalMesh2(mode:number, i1:number, i2:number, j1:number, j2:number):map:void</code>
</p>
<p>
<strong>opengl.glEvalPoint1</strong>
</p>
<p>
<code>opengl.glEvalPoint1(i:number):map:void</code>
</p>
<p>
<strong>opengl.glEvalPoint2</strong>
</p>
<p>
<code>opengl.glEvalPoint2(i:number, j:number):map:void</code>
</p>
<p>
<strong>opengl.glFeedbackBuffer</strong>
</p>
<p>
<code>opengl.glFeedbackBuffer(type:number, buffer:array@float:nomap:nil):void</code>
</p>
<p>
<strong>opengl.glFinish</strong>
</p>
<p>
<code>opengl.glFinish():void</code>
</p>
<p>
<strong>opengl.glFlush</strong>
</p>
<p>
<code>opengl.glFlush():void</code>
</p>
<p>
<strong>opengl.glFogf</strong>
</p>
<p>
<code>opengl.glFogf(pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glFogfv</strong>
</p>
<p>
<code>opengl.glFogfv(pname:number, params:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glFogi</strong>
</p>
<p>
<code>opengl.glFogi(pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glFogiv</strong>
</p>
<p>
<code>opengl.glFogiv(pname:number, params:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glFrontFace</strong>
</p>
<p>
<code>opengl.glFrontFace(mode:number):map:void</code>
</p>
<p>
<strong>opengl.glFrustum</strong>
</p>
<p>
<code>opengl.glFrustum(left:number, right:number, bottom:number, top:number, zNear:number, zFar:number):map:void</code>
</p>
<p>
<strong>opengl.glGenLists</strong>
</p>
<p>
<code>opengl.glGenLists(range:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGenTextures</strong>
</p>
<p>
<code>opengl.glGenTextures(n:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetBooleanv</strong>
</p>
<p>
<code>opengl.glGetBooleanv(pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetClipPlane</strong>
</p>
<p>
<code>opengl.glGetClipPlane(plane:number):map</code>
</p>
<p>
<strong>opengl.glGetDoublev</strong>
</p>
<p>
<code>opengl.glGetDoublev(pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetError</strong>
</p>
<p>
<code>opengl.glGetError() {block?}</code>
</p>
<p>
<strong>opengl.glGetFloatv</strong>
</p>
<p>
<code>opengl.glGetFloatv(pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetIntegerv</strong>
</p>
<p>
<code>opengl.glGetIntegerv(pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetLightfv</strong>
</p>
<p>
<code>opengl.glGetLightfv(light:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetLightiv</strong>
</p>
<p>
<code>opengl.glGetLightiv(light:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetMapdv</strong>
</p>
<p>
<code>opengl.glGetMapdv(target:number, query:number, v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetMapfv</strong>
</p>
<p>
<code>opengl.glGetMapfv(target:number, query:number, v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetMapiv</strong>
</p>
<p>
<code>opengl.glGetMapiv(target:number, query:number, v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetMaterialfv</strong>
</p>
<p>
<code>opengl.glGetMaterialfv(face:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetMaterialiv</strong>
</p>
<p>
<code>opengl.glGetMaterialiv(face:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetPixelMapfv</strong>
</p>
<p>
<code>opengl.glGetPixelMapfv(map:number, values:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetPixelMapuiv</strong>
</p>
<p>
<code>opengl.glGetPixelMapuiv(map:number, values:array@uint:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetPixelMapusv</strong>
</p>
<p>
<code>opengl.glGetPixelMapusv(map:number, values:array@ushort:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetPolygonStipple</strong>
</p>
<p>
<code>opengl.glGetPolygonStipple(mask:array@uchar:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetString</strong>
</p>
<p>
<code>opengl.glGetString(name:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexEnvfv</strong>
</p>
<p>
<code>opengl.glGetTexEnvfv(target:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexEnviv</strong>
</p>
<p>
<code>opengl.glGetTexEnviv(target:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexGendv</strong>
</p>
<p>
<code>opengl.glGetTexGendv(coord:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexGenfv</strong>
</p>
<p>
<code>opengl.glGetTexGenfv(coord:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexGeniv</strong>
</p>
<p>
<code>opengl.glGetTexGeniv(coord:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexLevelParameterfv</strong>
</p>
<p>
<code>opengl.glGetTexLevelParameterfv(target:number, level:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexLevelParameteriv</strong>
</p>
<p>
<code>opengl.glGetTexLevelParameteriv(target:number, level:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexParameterfv</strong>
</p>
<p>
<code>opengl.glGetTexParameterfv(target:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glGetTexParameteriv</strong>
</p>
<p>
<code>opengl.glGetTexParameteriv(target:number, pname:number):map {block?}</code>
</p>
<p>
<strong>opengl.glHint</strong>
</p>
<p>
<code>opengl.glHint(target:number, mode:number):map:void</code>
</p>
<p>
<strong>opengl.glIndexMask</strong>
</p>
<p>
<code>opengl.glIndexMask(mask:number):map:void</code>
</p>
<p>
<strong>opengl.glIndexd</strong>
</p>
<p>
<code>opengl.glIndexd(c:number):map:void</code>
</p>
<p>
<strong>opengl.glIndexdv</strong>
</p>
<p>
<code>opengl.glIndexdv(c:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glIndexf</strong>
</p>
<p>
<code>opengl.glIndexf(c:number):map:void</code>
</p>
<p>
<strong>opengl.glIndexfv</strong>
</p>
<p>
<code>opengl.glIndexfv(c:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glIndexi</strong>
</p>
<p>
<code>opengl.glIndexi(c:number):map:void</code>
</p>
<p>
<strong>opengl.glIndexiv</strong>
</p>
<p>
<code>opengl.glIndexiv(c:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glIndexs</strong>
</p>
<p>
<code>opengl.glIndexs(c:number):map:void</code>
</p>
<p>
<strong>opengl.glIndexsv</strong>
</p>
<p>
<code>opengl.glIndexsv(c:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glIndexub</strong>
</p>
<p>
<code>opengl.glIndexub(c:number):map:void</code>
</p>
<p>
<strong>opengl.glIndexubv</strong>
</p>
<p>
<code>opengl.glIndexubv(c:array@uchar:nomap):map:void</code>
</p>
<p>
<strong>opengl.glInitNames</strong>
</p>
<p>
<code>opengl.glInitNames():void</code>
</p>
<p>
<strong>opengl.glIsEnabled</strong>
</p>
<p>
<code>opengl.glIsEnabled(cap:number):map {block?}</code>
</p>
<p>
<strong>opengl.glIsList</strong>
</p>
<p>
<code>opengl.glIsList(list:number):map {block?}</code>
</p>
<p>
<strong>opengl.glIsTexture</strong>
</p>
<p>
<code>opengl.glIsTexture(texture:number):map {block?}</code>
</p>
<p>
<strong>opengl.glLightModelf</strong>
</p>
<p>
<code>opengl.glLightModelf(pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glLightModelfv</strong>
</p>
<p>
<code>opengl.glLightModelfv(pname:number, params:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glLightModeli</strong>
</p>
<p>
<code>opengl.glLightModeli(pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glLightModeliv</strong>
</p>
<p>
<code>opengl.glLightModeliv(pname:number, params:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glLightf</strong>
</p>
<p>
<code>opengl.glLightf(light:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glLightfv</strong>
</p>
<p>
<code>opengl.glLightfv(light:number, pname:number, params:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glLighti</strong>
</p>
<p>
<code>opengl.glLighti(light:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glLightiv</strong>
</p>
<p>
<code>opengl.glLightiv(light:number, pname:number, params:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glLineStipple</strong>
</p>
<p>
<code>opengl.glLineStipple(factor:number, pattern:number):map:void</code>
</p>
<p>
<strong>opengl.glLineWidth</strong>
</p>
<p>
<code>opengl.glLineWidth(width:number):map:void</code>
</p>
<p>
<strong>opengl.glListBase</strong>
</p>
<p>
<code>opengl.glListBase(base:number):map:void</code>
</p>
<p>
<strong>opengl.glLoadIdentity</strong>
</p>
<p>
<code>opengl.glLoadIdentity():void</code>
</p>
<p>
<strong>opengl.glLoadMatrixd</strong>
</p>
<p>
<code>opengl.glLoadMatrixd(m):void</code>
</p>
<p>
<strong>opengl.glLoadMatrixf</strong>
</p>
<p>
<code>opengl.glLoadMatrixf(m):void</code>
</p>
<p>
<strong>opengl.glLoadName</strong>
</p>
<p>
<code>opengl.glLoadName(name:number):map:void</code>
</p>
<p>
<strong>opengl.glLogicOp</strong>
</p>
<p>
<code>opengl.glLogicOp(opcode:number):map:void</code>
</p>
<p>
<strong>opengl.glMap1d</strong>
</p>
<p>
<code>opengl.glMap1d(target:number, u1:number, u2:number, stride:number, order:number, points:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glMap1f</strong>
</p>
<p>
<code>opengl.glMap1f(target:number, u1:number, u2:number, stride:number, order:number, points:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glMap2d</strong>
</p>
<p>
<code>opengl.glMap2d(target:number, u1:number, u2:number, ustride:number, uorder:number, v1:number, v2:number, vstride:number, vorder:number, points:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glMap2f</strong>
</p>
<p>
<code>opengl.glMap2f(target:number, u1:number, u2:number, ustride:number, uorder:number, v1:number, v2:number, vstride:number, vorder:number, points:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glMapGrid1d</strong>
</p>
<p>
<code>opengl.glMapGrid1d(un:number, u1:number, u2:number):map:void</code>
</p>
<p>
<strong>opengl.glMapGrid1f</strong>
</p>
<p>
<code>opengl.glMapGrid1f(un:number, u1:number, u2:number):map:void</code>
</p>
<p>
<strong>opengl.glMapGrid2d</strong>
</p>
<p>
<code>opengl.glMapGrid2d(un:number, u1:number, u2:number, vn:number, v1:number, v2:number):map:void</code>
</p>
<p>
<strong>opengl.glMapGrid2f</strong>
</p>
<p>
<code>opengl.glMapGrid2f(un:number, u1:number, u2:number, vn:number, v1:number, v2:number):map:void</code>
</p>
<p>
<strong>opengl.glMaterialf</strong>
</p>
<p>
<code>opengl.glMaterialf(face:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glMaterialfv</strong>
</p>
<p>
<code>opengl.glMaterialfv(face:number, pname:number, params:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glMateriali</strong>
</p>
<p>
<code>opengl.glMateriali(face:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glMaterialiv</strong>
</p>
<p>
<code>opengl.glMaterialiv(face:number, pname:number, params:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glMatrixMode</strong>
</p>
<p>
<code>opengl.glMatrixMode(mode:number):map:void</code>
</p>
<p>
<strong>opengl.glMultMatrixd</strong>
</p>
<p>
<code>opengl.glMultMatrixd(m):void</code>
</p>
<p>
<strong>opengl.glMultMatrixf</strong>
</p>
<p>
<code>opengl.glMultMatrixf(m):void</code>
</p>
<p>
<strong>opengl.glNewList</strong>
</p>
<p>
<code>opengl.glNewList(list:number, mode:number):map:void {block?}</code>
</p>
<p>
<strong>opengl.glNormal3b</strong>
</p>
<p>
<code>opengl.glNormal3b(nx:number, ny:number, nz:number):map:void</code>
</p>
<p>
<strong>opengl.glNormal3bv</strong>
</p>
<p>
<code>opengl.glNormal3bv(v:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glNormal3d</strong>
</p>
<p>
<code>opengl.glNormal3d(nx:number, ny:number, nz:number):map:void</code>
</p>
<p>
<strong>opengl.glNormal3dv</strong>
</p>
<p>
<code>opengl.glNormal3dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glNormal3f</strong>
</p>
<p>
<code>opengl.glNormal3f(nx:number, ny:number, nz:number):map:void</code>
</p>
<p>
<strong>opengl.glNormal3fv</strong>
</p>
<p>
<code>opengl.glNormal3fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glNormal3i</strong>
</p>
<p>
<code>opengl.glNormal3i(nx:number, ny:number, nz:number):map:void</code>
</p>
<p>
<strong>opengl.glNormal3iv</strong>
</p>
<p>
<code>opengl.glNormal3iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glNormal3s</strong>
</p>
<p>
<code>opengl.glNormal3s(nx:number, ny:number, nz:number):map:void</code>
</p>
<p>
<strong>opengl.glNormal3sv</strong>
</p>
<p>
<code>opengl.glNormal3sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glOrtho</strong>
</p>
<p>
<code>opengl.glOrtho(left:number, right:number, bottom:number, top:number, zNear:number, zFar:number):map:void</code>
</p>
<p>
<strong>opengl.glPassThrough</strong>
</p>
<p>
<code>opengl.glPassThrough(token:number):map:void</code>
</p>
<p>
<strong>opengl.glPixelMapfv</strong>
</p>
<p>
<code>opengl.glPixelMapfv(map:number, mapsize:number, values:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glPixelMapuiv</strong>
</p>
<p>
<code>opengl.glPixelMapuiv(map:number, mapsize:number, values:array@uint:nomap):map:void</code>
</p>
<p>
<strong>opengl.glPixelMapusv</strong>
</p>
<p>
<code>opengl.glPixelMapusv(map:number, mapsize:number, values:array@ushort:nomap):map:void</code>
</p>
<p>
<strong>opengl.glPixelStoref</strong>
</p>
<p>
<code>opengl.glPixelStoref(pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glPixelStorei</strong>
</p>
<p>
<code>opengl.glPixelStorei(pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glPixelTransferf</strong>
</p>
<p>
<code>opengl.glPixelTransferf(pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glPixelTransferi</strong>
</p>
<p>
<code>opengl.glPixelTransferi(pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glPixelZoom</strong>
</p>
<p>
<code>opengl.glPixelZoom(xfactor:number, yfactor:number):map:void</code>
</p>
<p>
<strong>opengl.glPointSize</strong>
</p>
<p>
<code>opengl.glPointSize(size:number):map:void</code>
</p>
<p>
<strong>opengl.glPolygonMode</strong>
</p>
<p>
<code>opengl.glPolygonMode(face:number, mode:number):map:void</code>
</p>
<p>
<strong>opengl.glPolygonOffset</strong>
</p>
<p>
<code>opengl.glPolygonOffset(factor:number, units:number):map:void</code>
</p>
<p>
<strong>opengl.glPolygonStipple</strong>
</p>
<p>
<code>opengl.glPolygonStipple(mask:array@uchar:nomap):map:void</code>
</p>
<p>
<strong>opengl.glPopAttrib</strong>
</p>
<p>
<code>opengl.glPopAttrib():void</code>
</p>
<p>
<strong>opengl.glPopClientAttrib</strong>
</p>
<p>
<code>opengl.glPopClientAttrib():void</code>
</p>
<p>
<strong>opengl.glPopMatrix</strong>
</p>
<p>
<code>opengl.glPopMatrix():void</code>
</p>
<p>
<strong>opengl.glPopName</strong>
</p>
<p>
<code>opengl.glPopName():void</code>
</p>
<p>
<strong>opengl.glPrioritizeTextures</strong>
</p>
<p>
<code>opengl.glPrioritizeTextures(textures:array@uint:nomap, priorities:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glPushAttrib</strong>
</p>
<p>
<code>opengl.glPushAttrib(mask:number):map:void {block?}</code>
</p>
<p>
<strong>opengl.glPushClientAttrib</strong>
</p>
<p>
<code>opengl.glPushClientAttrib(mask:number):map:void {block?}</code>
</p>
<p>
<strong>opengl.glPushMatrix</strong>
</p>
<p>
<code>opengl.glPushMatrix():void {block?}</code>
</p>
<p>
<strong>opengl.glPushName</strong>
</p>
<p>
<code>opengl.glPushName(name:number):map:void {block?}</code>
</p>
<p>
<strong>opengl.glRasterPos2d</strong>
</p>
<p>
<code>opengl.glRasterPos2d(x:number, y:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos2dv</strong>
</p>
<p>
<code>opengl.glRasterPos2dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos2f</strong>
</p>
<p>
<code>opengl.glRasterPos2f(x:number, y:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos2fv</strong>
</p>
<p>
<code>opengl.glRasterPos2fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos2i</strong>
</p>
<p>
<code>opengl.glRasterPos2i(x:number, y:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos2iv</strong>
</p>
<p>
<code>opengl.glRasterPos2iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos2s</strong>
</p>
<p>
<code>opengl.glRasterPos2s(x:number, y:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos2sv</strong>
</p>
<p>
<code>opengl.glRasterPos2sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos3d</strong>
</p>
<p>
<code>opengl.glRasterPos3d(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos3dv</strong>
</p>
<p>
<code>opengl.glRasterPos3dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos3f</strong>
</p>
<p>
<code>opengl.glRasterPos3f(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos3fv</strong>
</p>
<p>
<code>opengl.glRasterPos3fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos3i</strong>
</p>
<p>
<code>opengl.glRasterPos3i(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos3iv</strong>
</p>
<p>
<code>opengl.glRasterPos3iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos3s</strong>
</p>
<p>
<code>opengl.glRasterPos3s(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos3sv</strong>
</p>
<p>
<code>opengl.glRasterPos3sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos4d</strong>
</p>
<p>
<code>opengl.glRasterPos4d(x:number, y:number, z:number, w:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos4dv</strong>
</p>
<p>
<code>opengl.glRasterPos4dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos4f</strong>
</p>
<p>
<code>opengl.glRasterPos4f(x:number, y:number, z:number, w:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos4fv</strong>
</p>
<p>
<code>opengl.glRasterPos4fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos4i</strong>
</p>
<p>
<code>opengl.glRasterPos4i(x:number, y:number, z:number, w:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos4iv</strong>
</p>
<p>
<code>opengl.glRasterPos4iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos4s</strong>
</p>
<p>
<code>opengl.glRasterPos4s(x:number, y:number, z:number, w:number):map:void</code>
</p>
<p>
<strong>opengl.glRasterPos4sv</strong>
</p>
<p>
<code>opengl.glRasterPos4sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glReadBuffer</strong>
</p>
<p>
<code>opengl.glReadBuffer(mode:number):map:void</code>
</p>
<p>
<strong>opengl.glReadPixels</strong>
</p>
<p>
<code>opengl.glReadPixels(x:number, y:number, width:number, height:number, format:symbol):map {block?}</code>
</p>
<p>
<strong>opengl.glRectd</strong>
</p>
<p>
<code>opengl.glRectd(x1:number, y1:number, x2:number, y2:number):map:void</code>
</p>
<p>
<strong>opengl.glRectdv</strong>
</p>
<p>
<code>opengl.glRectdv(v1:array@double:nomap, v2:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRectf</strong>
</p>
<p>
<code>opengl.glRectf(x1:number, y1:number, x2:number, y2:number):map:void</code>
</p>
<p>
<strong>opengl.glRectfv</strong>
</p>
<p>
<code>opengl.glRectfv(v1:array@float:nomap, v2:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRecti</strong>
</p>
<p>
<code>opengl.glRecti(x1:number, y1:number, x2:number, y2:number):map:void</code>
</p>
<p>
<strong>opengl.glRectiv</strong>
</p>
<p>
<code>opengl.glRectiv(v1:array@int:nomap, v2:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRects</strong>
</p>
<p>
<code>opengl.glRects(x1:number, y1:number, x2:number, y2:number):map:void</code>
</p>
<p>
<strong>opengl.glRectsv</strong>
</p>
<p>
<code>opengl.glRectsv(v1:array@short:nomap, v2:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glRenderMode</strong>
</p>
<p>
<code>opengl.glRenderMode(mode:number):map {block?}</code>
</p>
<p>
<strong>opengl.glRotated</strong>
</p>
<p>
<code>opengl.glRotated(angle:number, x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glRotatef</strong>
</p>
<p>
<code>opengl.glRotatef(angle:number, x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glScaled</strong>
</p>
<p>
<code>opengl.glScaled(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glScalef</strong>
</p>
<p>
<code>opengl.glScalef(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glScissor</strong>
</p>
<p>
<code>opengl.glScissor(x:number, y:number, width:number, height:number):map:void</code>
</p>
<p>
<strong>opengl.glSelectBuffer</strong>
</p>
<p>
<code>opengl.glSelectBuffer(buffer:array@uint:nomap:nil):void</code>
</p>
<p>
<strong>opengl.glShadeModel</strong>
</p>
<p>
<code>opengl.glShadeModel(mode:number):map:void</code>
</p>
<p>
<strong>opengl.glStencilFunc</strong>
</p>
<p>
<code>opengl.glStencilFunc(func:number, ref:number, mask:number):map:void</code>
</p>
<p>
<strong>opengl.glStencilMask</strong>
</p>
<p>
<code>opengl.glStencilMask(mask:number):map:void</code>
</p>
<p>
<strong>opengl.glStencilOp</strong>
</p>
<p>
<code>opengl.glStencilOp(fail:number, zfail:number, zpass:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord1d</strong>
</p>
<p>
<code>opengl.glTexCoord1d(s:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord1dv</strong>
</p>
<p>
<code>opengl.glTexCoord1dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord1f</strong>
</p>
<p>
<code>opengl.glTexCoord1f(s:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord1fv</strong>
</p>
<p>
<code>opengl.glTexCoord1fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord1i</strong>
</p>
<p>
<code>opengl.glTexCoord1i(s:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord1iv</strong>
</p>
<p>
<code>opengl.glTexCoord1iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord1s</strong>
</p>
<p>
<code>opengl.glTexCoord1s(s:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord1sv</strong>
</p>
<p>
<code>opengl.glTexCoord1sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord2d</strong>
</p>
<p>
<code>opengl.glTexCoord2d(s:number, t:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord2dv</strong>
</p>
<p>
<code>opengl.glTexCoord2dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord2f</strong>
</p>
<p>
<code>opengl.glTexCoord2f(s:number, t:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord2fv</strong>
</p>
<p>
<code>opengl.glTexCoord2fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord2i</strong>
</p>
<p>
<code>opengl.glTexCoord2i(s:number, t:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord2iv</strong>
</p>
<p>
<code>opengl.glTexCoord2iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord2s</strong>
</p>
<p>
<code>opengl.glTexCoord2s(s:number, t:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord2sv</strong>
</p>
<p>
<code>opengl.glTexCoord2sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord3d</strong>
</p>
<p>
<code>opengl.glTexCoord3d(s:number, t:number, r:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord3dv</strong>
</p>
<p>
<code>opengl.glTexCoord3dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord3f</strong>
</p>
<p>
<code>opengl.glTexCoord3f(s:number, t:number, r:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord3fv</strong>
</p>
<p>
<code>opengl.glTexCoord3fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord3i</strong>
</p>
<p>
<code>opengl.glTexCoord3i(s:number, t:number, r:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord3iv</strong>
</p>
<p>
<code>opengl.glTexCoord3iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord3s</strong>
</p>
<p>
<code>opengl.glTexCoord3s(s:number, t:number, r:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord3sv</strong>
</p>
<p>
<code>opengl.glTexCoord3sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord4d</strong>
</p>
<p>
<code>opengl.glTexCoord4d(s:number, t:number, r:number, q:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord4dv</strong>
</p>
<p>
<code>opengl.glTexCoord4dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord4f</strong>
</p>
<p>
<code>opengl.glTexCoord4f(s:number, t:number, r:number, q:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord4fv</strong>
</p>
<p>
<code>opengl.glTexCoord4fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord4i</strong>
</p>
<p>
<code>opengl.glTexCoord4i(s:number, t:number, r:number, q:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord4iv</strong>
</p>
<p>
<code>opengl.glTexCoord4iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord4s</strong>
</p>
<p>
<code>opengl.glTexCoord4s(s:number, t:number, r:number, q:number):map:void</code>
</p>
<p>
<strong>opengl.glTexCoord4sv</strong>
</p>
<p>
<code>opengl.glTexCoord4sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexEnvf</strong>
</p>
<p>
<code>opengl.glTexEnvf(target:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glTexEnvfv</strong>
</p>
<p>
<code>opengl.glTexEnvfv(target:number, pname:number, params:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexEnvi</strong>
</p>
<p>
<code>opengl.glTexEnvi(target:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glTexEnviv</strong>
</p>
<p>
<code>opengl.glTexEnviv(target:number, pname:number, params:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexGend</strong>
</p>
<p>
<code>opengl.glTexGend(coord:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glTexGendv</strong>
</p>
<p>
<code>opengl.glTexGendv(coord:number, pname:number, params:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexGenf</strong>
</p>
<p>
<code>opengl.glTexGenf(coord:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glTexGenfv</strong>
</p>
<p>
<code>opengl.glTexGenfv(coord:number, pname:number, params:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexGeni</strong>
</p>
<p>
<code>opengl.glTexGeni(coord:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glTexGeniv</strong>
</p>
<p>
<code>opengl.glTexGeniv(coord:number, pname:number, params:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexImage1D</strong>
</p>
<p>
<code>opengl.glTexImage1D(target:number, level:number, internalformat:number, width:number, border:number, format:number, type:number, pixels):map:void</code>
</p>
<p>
<strong>opengl.glTexImage1DFromImage</strong>
</p>
<p>
<code>opengl.glTexImage1DFromImage(target:number, level:number, internalformat:number, border:number, image:image):map:void</code>
</p>
<p>
<strong>opengl.glTexImage2D</strong>
</p>
<p>
<code>opengl.glTexImage2D(target:number, level:number, internalformat:number, width:number, height:number, border:number, format:number, type:number, pixels):map:void</code>
</p>
<p>
<strong>opengl.glTexImage2DFromImage</strong>
</p>
<p>
<code>opengl.glTexImage2DFromImage(target:number, level:number, internalformat:number, border:number, image:image):map:void</code>
</p>
<p>
<strong>opengl.glTexParameterf</strong>
</p>
<p>
<code>opengl.glTexParameterf(target:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glTexParameterfv</strong>
</p>
<p>
<code>opengl.glTexParameterfv(target:number, pname:number, params:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexParameteri</strong>
</p>
<p>
<code>opengl.glTexParameteri(target:number, pname:number, param:number):map:void</code>
</p>
<p>
<strong>opengl.glTexParameteriv</strong>
</p>
<p>
<code>opengl.glTexParameteriv(target:number, pname:number, params:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glTexSubImage1D</strong>
</p>
<p>
<code>opengl.glTexSubImage1D(target:number, level:number, xoffset:number, width:number, format:number, type:number, pixels):map:void</code>
</p>
<p>
<strong>opengl.glTexSubImage1DFromImage</strong>
</p>
<p>
<code>opengl.glTexSubImage1DFromImage(target:number, level:number, xoffset:number, image:image):map:void</code>
</p>
<p>
<strong>opengl.glTexSubImage2D</strong>
</p>
<p>
<code>opengl.glTexSubImage2D(target:number, level:number, xoffset:number, yoffset:number, width:number, height:number, format:number, type:number, pixels):map:void</code>
</p>
<p>
<strong>opengl.glTexSubImage2DFromImage</strong>
</p>
<p>
<code>opengl.glTexSubImage2DFromImage(target:number, level:number, xoffset:number, yoffset:number, image:image):map:void</code>
</p>
<p>
<strong>opengl.glTranslated</strong>
</p>
<p>
<code>opengl.glTranslated(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glTranslatef</strong>
</p>
<p>
<code>opengl.glTranslatef(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex2d</strong>
</p>
<p>
<code>opengl.glVertex2d(x:number, y:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex2dv</strong>
</p>
<p>
<code>opengl.glVertex2dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex2f</strong>
</p>
<p>
<code>opengl.glVertex2f(x:number, y:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex2fv</strong>
</p>
<p>
<code>opengl.glVertex2fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex2i</strong>
</p>
<p>
<code>opengl.glVertex2i(x:number, y:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex2iv</strong>
</p>
<p>
<code>opengl.glVertex2iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex2s</strong>
</p>
<p>
<code>opengl.glVertex2s(x:number, y:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex2sv</strong>
</p>
<p>
<code>opengl.glVertex2sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex3d</strong>
</p>
<p>
<code>opengl.glVertex3d(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex3dv</strong>
</p>
<p>
<code>opengl.glVertex3dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex3f</strong>
</p>
<p>
<code>opengl.glVertex3f(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex3fv</strong>
</p>
<p>
<code>opengl.glVertex3fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex3i</strong>
</p>
<p>
<code>opengl.glVertex3i(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex3iv</strong>
</p>
<p>
<code>opengl.glVertex3iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex3s</strong>
</p>
<p>
<code>opengl.glVertex3s(x:number, y:number, z:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex3sv</strong>
</p>
<p>
<code>opengl.glVertex3sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex4d</strong>
</p>
<p>
<code>opengl.glVertex4d(x:number, y:number, z:number, w:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex4dv</strong>
</p>
<p>
<code>opengl.glVertex4dv(v:array@double:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex4f</strong>
</p>
<p>
<code>opengl.glVertex4f(x:number, y:number, z:number, w:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex4fv</strong>
</p>
<p>
<code>opengl.glVertex4fv(v:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex4i</strong>
</p>
<p>
<code>opengl.glVertex4i(x:number, y:number, z:number, w:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex4iv</strong>
</p>
<p>
<code>opengl.glVertex4iv(v:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glVertex4s</strong>
</p>
<p>
<code>opengl.glVertex4s(x:number, y:number, z:number, w:number):map:void</code>
</p>
<p>
<strong>opengl.glVertex4sv</strong>
</p>
<p>
<code>opengl.glVertex4sv(v:array@short:nomap):map:void</code>
</p>
<p>
<strong>opengl.glViewport</strong>
</p>
<p>
<code>opengl.glViewport(x:number, y:number, width:number, height:number):map:void</code>
</p>
<p>
<strong>opengl.glGetAttachedShaders</strong>
</p>
<p>
<code>opengl.glGetAttachedShaders(program:number, maxCount:number, count[]:number, shaders:array@uint:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetShaderInfoLog</strong>
</p>
<p>
<code>opengl.glGetShaderInfoLog(shader:number, bufSize:number, length[]:number, infoLog:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetProgramInfoLog</strong>
</p>
<p>
<code>opengl.glGetProgramInfoLog(program:number, bufSize:number, length[]:number, infoLog:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetUniformLocation</strong>
</p>
<p>
<code>opengl.glGetUniformLocation(program:number, name:array@char:nomap):map {block?}</code>
</p>
<p>
<strong>opengl.glGetActiveUniform</strong>
</p>
<p>
<code>opengl.glGetActiveUniform(program:number, index:number, bufSize:number, length[]:number, size:array@int:nomap, type[]:number, name:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetUniformfv</strong>
</p>
<p>
<code>opengl.glGetUniformfv(program:number, location:number, params:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetUniformiv</strong>
</p>
<p>
<code>opengl.glGetUniformiv(program:number, location:number, params:array@int:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetShaderSource</strong>
</p>
<p>
<code>opengl.glGetShaderSource(shader:number, bufSize:number, length[]:number, source:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glBindAttribLocation</strong>
</p>
<p>
<code>opengl.glBindAttribLocation(program:number, index:number, name:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetActiveAttrib</strong>
</p>
<p>
<code>opengl.glGetActiveAttrib(program:number, index:number, bufSize:number, length[]:number, size:array@int:nomap, type[]:number, name:array@char:nomap):map:void</code>
</p>
<p>
<strong>opengl.glGetAttribLocation</strong>
</p>
<p>
<code>opengl.glGetAttribLocation(program:number, name:array@char:nomap):map {block?}</code>
</p>
<p>
<strong>opengl.glUniformMatrix2x3fv</strong>
</p>
<p>
<code>opengl.glUniformMatrix2x3fv(location:number, count:number, transpose:boolean, value:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glUniformMatrix3x2fv</strong>
</p>
<p>
<code>opengl.glUniformMatrix3x2fv(location:number, count:number, transpose:boolean, value:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glUniformMatrix2x4fv</strong>
</p>
<p>
<code>opengl.glUniformMatrix2x4fv(location:number, count:number, transpose:boolean, value:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glUniformMatrix4x2fv</strong>
</p>
<p>
<code>opengl.glUniformMatrix4x2fv(location:number, count:number, transpose:boolean, value:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glUniformMatrix3x4fv</strong>
</p>
<p>
<code>opengl.glUniformMatrix3x4fv(location:number, count:number, transpose:boolean, value:array@float:nomap):map:void</code>
</p>
<p>
<strong>opengl.glUniformMatrix4x3fv</strong>
</p>
<p>
<code>opengl.glUniformMatrix4x3fv(location:number, count:number, transpose:boolean, value:array@float:nomap):map:void</code>
</p>
<h1><span class="caption-index-1">33</span><a name="caption-33"></a>os Module</h1>
<p>
The <code>os</code> module provides functions that are specific to each OS environment. This is a built-in module, so you can use it without being imported.
</p>
<h2><span class="caption-index-2">33.1</span><a name="caption-33-1"></a>Module Functions</h2>
<p>
<strong>os.clock</strong>
</p>
<p>
<code>os.clock()</code>
</p>
<p>
<strong>os.exec</strong>
</p>
<p>
<code>os.exec(pathname:string, args*:string):map:[fork]</code>
</p>
<p>
Executes the specified executable file.
</p>
<p>
<strong>os.fromnative</strong>
</p>
<p>
<code>os.fromnative(buff:binary):map</code>
</p>
<p>
Converts binary data that includes OS's native string into Gura's regulated string.
</p>
<p>
<strong>os.getenv</strong>
</p>
<p>
<code>os.getenv(name:string, default?:string):map</code>
</p>
<p>
Returns the value of an environment variable.
</p>
<p>
<strong>os.putenv</strong>
</p>
<p>
<code>os.putenv(name:string, value:string):void</code>
</p>
<p>
Set the value of an environment variable.
</p>
<p>
<strong>os.redirect</strong>
</p>
<p>
<code>os.redirect(stdin:stream:nil:r, stdout:stream:nil:w, stderr?:stream:w) {block?}</code>
</p>
<p>
Modifies variables <code>os.stdin</code>, <code>os.stdout</code> and <code>os.stderr</code> with values of arguments. When <code>block</code> is specified, the modification only has effect within the block.
</p>
<p>
<strong>os.sleep</strong>
</p>
<p>
<code>os.sleep(secs:number)</code>
</p>
<p>
Sleeps for a time specified in seconds.
</p>
<p>
<strong>os.symlink</strong>
</p>
<p>
<code>os.symlink(src:string, tgt:string):map:void</code>
</p>
<p>
Creates a symbol link.
</p>
<p>
<strong>os.tonative</strong>
</p>
<p>
<code>os.tonative(str:string):map</code>
</p>
<p>
Converts Gura's regulated string into binary data that includes OS's native string.
</p>
<p>
<strong>os.unsetenv</strong>
</p>
<p>
<code>os.unsetenv(name:string):void</code>
</p>
<p>
Unset an environment variable.
</p>
<h1><span class="caption-index-1">34</span><a name="caption-34"></a>path Module</h1>
<p>
The <code>path</code> module provides functions related to path operations. This is a built-in module, so you can use it without being imported.
</p>
<p>
Below is an example to list path names that exist in the current directory.
</p>
<pre><code>println(path.dir('.'))
</code></pre>
<p>
Below is an example to list path names that exist in the current directory and its child directories.
</p>
<pre><code>println(path.walk('.'))
</code></pre>
<p>
Below is an example to list path names that matches a wild card pattern "<code>*.txt</code>".
</p>
<pre><code>println(path.glob('*.txt'))
</code></pre>
<h2><span class="caption-index-2">34.1</span><a name="caption-34-1"></a>Module Functions</h2>
<p>
<strong>path.absname</strong>
</p>
<p>
<code>path.absname(name:string):map:[uri]</code>
</p>
<p>
Returns an absolute path name of the given name.
</p>
<p>
<strong>path.basename</strong>
</p>
<p>
<code>path.basename(pathname:string):map</code>
</p>
<p>
Removes a suffix part of a path name.
</p>
<p>
<strong>path.bottom</strong>
</p>
<p>
<code>path.bottom(pathname:string):map</code>
</p>
<p>
Returns the last part of a path name.
</p>
<p>
<strong>path.cutbottom</strong>
</p>
<p>
<code>path.cutbottom(pathname:string):map</code>
</p>
<p>
Returns a path name after eliminating its bottom part.
</p>
<p>
<strong>path.dir</strong>
</p>
<p>
<code>path.dir(directory?:directory, pattern*:string):map:flat:[dir,file,stat] {block?}</code>
</p>
<p>
Creates an iterator that lists item names in the specified directory. If pathname is omitted, the current directory shall be listed. If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
<strong>path.dirname</strong>
</p>
<p>
<code>path.dirname(pathname:string):map</code>
</p>
<p>
Splits a pathname by a directory separator and returns a directory name part.
</p>
<p>
<strong>path.exists</strong>
</p>
<p>
<code>path.exists(pathname:string):map</code>
</p>
<p>
Returns true if the specified file exists in a file system.
</p>
<p>
<strong>path.extname</strong>
</p>
<p>
<code>path.extname(pathname:string):map</code>
</p>
<p>
Extracts a suffix part of a path name.
</p>
<p>
<strong>path.filename</strong>
</p>
<p>
<code>path.filename(pathname:string):map</code>
</p>
<p>
Splits a pathname by a directory separator and returns a file name part.
</p>
<p>
<strong>path.glob</strong>
</p>
<p>
<code>path.glob(pattern:string):map:flat:[dir,file,stat] {block?}</code>
</p>
<p>
Creates an iterator for item names that match with a pattern supporting UNIX shell-style wild cards. In default, case of characters is distinguished. If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<p>
<strong>path.join</strong>
</p>
<p>
<code>path.join(paths+:string):map:[uri]</code>
</p>
<p>
Returns a path name that joins given strings with directory separators.
</p>
<p>
<strong>path.match</strong>
</p>
<p>
<code>path.match(pattern:string, name:string):map</code>
</p>
<p>
Returns true if a name matches with a pattern that supports UNIX shell-style wild cards. In default, case of characters is distinguished.
</p>
<p>
<strong>path.regulate</strong>
</p>
<p>
<code>path.regulate(name:string):map:[uri]</code>
</p>
<p>
Returns a regulated path name of the given name.
</p>
<p>
<strong>path.split</strong>
</p>
<p>
<code>path.split(pathname:string):map:[bottom]</code>
</p>
<p>
Splits a pathname by a directory separator and returns a list containing a directory name as the first element and a base name as the second one. This has the same result as calling path.dirname() and path.filename().
</p>
<p>
<strong>path.splitext</strong>
</p>
<p>
<code>path.splitext(pathname:string):map</code>
</p>
<p>
Splits a pathname by a dot character indicating a beginning of an extension and returns a list containing a path name without an extention and an extention part.
</p>
<p>
<strong>path.stat</strong>
</p>
<p>
<code>path.stat(directory:directory):map</code>
</p>
<p>
Returns a stat object associated with the specified item.
</p>
<p>
<strong>path.walk</strong>
</p>
<p>
<code>path.walk(directory?:directory, maxdepth?:number, pattern*:string):map:flat:[dir,file,stat] {block?}</code>
</p>
<p>
Creates an iterator that recursively lists item names under the specified directory. If pathname is omitted, search starts at the current directory If a block is specified, it executes the block while evaluating the iterator and returns the last evaluated value in the block as its own result. Otherwise, it returns an iterator or a list according to the attribute
</p>
<p>
In default, it returns an iterator. If attribute <code>:xiter</code> is specified, it returns an iterator that eliminates <code>nil</code> value from the iterated result.
</p>
<p>
If one of attributes <code>:list</code>, <code>:xlist</code>, <code>:set</code> and <code>:xset</code> is specified, it would create the following value:
</p>
<ul>
<li><code>:list</code> .. a list of values</li>
<li><code>:xlist</code> .. a list of values except for <code>nil</code></li>
<li><code>:set</code> ..  a list of unique values</li>
<li><code>:xset</code> .. a list of unique values except for <code>nil</code></li>
</ul>
<h1><span class="caption-index-1">35</span><a name="caption-35"></a>png Module</h1>
<p>
The <code>png</code> module provides measures to read/write image data in PNG format. To utilize it, import the <code>png</code> module using <code>import</code> function.
</p>
<p>
This uses <code>libpng</code> library that is published in the URL: http://www.libpng.org/pub/png/libpng.html.
</p>
<p>
Below is an example to read a PNG file:
</p>
<pre><code>import(png)
img = image('foo.png')
</code></pre>
<h2><span class="caption-index-2">35.1</span><a name="caption-35-1"></a>Exntension of Function's Capability</h2>
<p>
This module extends the capability of function <code>image()</code> and instance method <code>image#write()</code> so that they can read/write PNG files.
</p>
<p>
When function <code>image()</code> is provided with a stream that satisfies the following conditions, it would recognize the stream as a PNG file.
</p>
<ul>
<li>The identifier of the stream ends with a suffix <code>.png</code>.</li>
<li>The stream data begins with a byte sequence <code>0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a</code>.</li>
</ul>
<p>
When instance method <code>image#write()</code> is provided with a stream that satisfies the following condition, it would write image data in PNG format.
</p>
<ul>
<li>The identifier of the stream ends with a suffix <code>.png</code>.</li>
</ul>
<h2><span class="caption-index-2">35.2</span><a name="caption-35-2"></a>Module Functions</h2>
<h2><span class="caption-index-2">35.3</span><a name="caption-35-3"></a>Methods Added to image Class</h2>
<p>
<strong>image#read@png</strong>
</p>
<p>
<code>image#read@png(stream:stream:r):reduce</code>
</p>
<p>
Reads a PNG image from a stream.
</p>
<p>
<strong>image#write@png</strong>
</p>
<p>
<code>image#write@png(stream:stream:w):reduce</code>
</p>
<p>
Writes a PNG image to a stream.
</p>
<h1><span class="caption-index-1">36</span><a name="caption-36"></a>postgresql Module</h1>
<h2><span class="caption-index-2">36.1</span><a name="caption-36-1"></a>Module Functions</h2>
<h1><span class="caption-index-1">37</span><a name="caption-37"></a>ppm Module</h1>
<p>
The <code>ppm</code> module provides measures to read/write image data in PPM format. To utilize it, import the <code>ppm</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read a PPM file:
</p>
<pre><code>import(ppm)
img = image('foo.ppm')
</code></pre>
<h2><span class="caption-index-2">37.1</span><a name="caption-37-1"></a>Module Functions</h2>
<h2><span class="caption-index-2">37.2</span><a name="caption-37-2"></a>Methods Added to image Class</h2>
<p>
<strong>image#read@ppm</strong>
</p>
<p>
<code>image#read@ppm(stream:stream:r):reduce</code>
</p>
<p>
Reads a PPM/PGM image from a stream.
</p>
<p>
<strong>image#write@ppm</strong>
</p>
<p>
<code>image#write@ppm(stream:stream:w):reduce:[gray]</code>
</p>
<p>
Writes a PPM/PGM image to a stream.
</p>
<h1><span class="caption-index-1">38</span><a name="caption-38"></a>re Module</h1>
<p>
The <code>re</code> module provides measures to operate strings with a regular expression. To utilize it, import the <code>re</code> module using <code>import</code> function.
</p>
<h2><span class="caption-index-2">38.1</span><a name="caption-38-1"></a>Module Functions</h2>
<p>
<strong>re.match</strong>
</p>
<p>
<code>re.match(pattern:re.pattern, str:string, pos:number =&gt; 0, endpos?:number):map {block?}</code>
</p>
<p>
<strong>re.sub</strong>
</p>
<p>
<code>re.sub(pattern:re.pattern, replace, str:string, count?:number):map {block?}</code>
</p>
<p>
<strong>re.split</strong>
</p>
<p>
<code>re.split(pattern:re.pattern, str:string, count?:number):map {block?}</code>
</p>
<p>
<strong>re.scan</strong>
</p>
<p>
<code>re.scan(pattern:re.pattern, str:string, pos:number =&gt; 0, endpos?:number):map {block?}</code>
</p>
<h2><span class="caption-index-2">38.2</span><a name="caption-38-2"></a>re.pattern Class</h2>
<p>
<strong>re.pattern</strong>
</p>
<p>
<code>re.pattern(pattern:string):map:[icase,multiline] {block?}</code>
</p>
<p>
<strong>re.pattern#match</strong>
</p>
<p>
<code>re.pattern#match(str:string, pos:number =&gt; 0, endpos?:number):map {block?}</code>
</p>
<p>
Applies a pattern matching to a string and returns a match object.
</p>
<p>
<strong>re.pattern#sub</strong>
</p>
<p>
<code>re.pattern#sub(replace, str:string, count?:number):map {block?}</code>
</p>
<p>
<strong>re.pattern#split</strong>
</p>
<p>
<code>re.pattern#split(str:string, count?:number):map {block?}</code>
</p>
<p>
<strong>re.pattern#scan</strong>
</p>
<p>
<code>re.pattern#scan(str:string, pos:number =&gt; 0, endpos?:number):map {block?}</code>
</p>
<h2><span class="caption-index-2">38.3</span><a name="caption-38-3"></a>Extension of string Class</h2>
<p>
<strong>string#match</strong>
</p>
<p>
<code>string#match(pattern:re.pattern, pos:number =&gt; 0, endpos?:number):map {block?}</code>
</p>
<p>
<strong>string#sub</strong>
</p>
<p>
<code>string#sub(pattern:re.pattern, replace, count?:number):map {block?}</code>
</p>
<p>
<strong>string#splitreg</strong>
</p>
<p>
<code>string#splitreg(pattern:re.pattern, count?:number):map {block?}</code>
</p>
<p>
<strong>string#scan</strong>
</p>
<p>
<code>string#scan(pattern:re.pattern, pos:number =&gt; 0, endpos?:number):map {block?}</code>
</p>
<h2><span class="caption-index-2">38.4</span><a name="caption-38-4"></a>Extension of list Class</h2>
<p>
<strong>list#grep</strong>
</p>
<p>
<code>list#grep(pattern:re.pattern):map {block?}</code>
</p>
<h2><span class="caption-index-2">38.5</span><a name="caption-38-5"></a>Extension of iterator Class</h2>
<p>
<strong>iterator#grep</strong>
</p>
<p>
<code>iterator#grep(pattern:re.pattern):map {block?}</code>
</p>
<h1><span class="caption-index-1">39</span><a name="caption-39"></a>sdl2 Module</h1>
<p>
The <code>sdl2</code> module provices functions of SDL2 library.
</p>
<h2><span class="caption-index-2">39.1</span><a name="caption-39-1"></a>Module Functions</h2>
<p>
<strong>sdl2.Init</strong>
</p>
<p>
<code>sdl2.Init(flags:number):void</code>
</p>
<p>
Use this function to initialize the SDL library. This must be called before using any other SDL function.
</p>
<p>
The Event Handling, File I/O, and Threading subsystems are initialized by default. You must specifically initialize other subsystems if you use them in your application.
</p>
<p>
<code>flags</code> may be any of the following OR'd together:
</p>
<ul>
<li><code>sdl2.INIT_TIMER</code> .. timer subsystem</li>
<li><code>sdl2.INIT_AUDIO</code> .. audio subsystem</li>
<li><code>sdl2.INIT_VIDEO</code> .. video subsystem</li>
<li><code>sdl2.INIT_JOYSTICK</code> .. joystick subsystem</li>
<li><code>sdl2.INIT_HAPTIC</code> .. haptic (force feedback) subsystem</li>
<li><code>sdl2.INIT_GAMECONTROLLER</code> .. controller subsystem</li>
<li><code>sdl2.INIT_EVENTS</code> .. events subsystem</li>
<li><code>sdl2.INIT_EVERYTHING</code> .. all of the above subsystems</li>
<li><code>sdl2.INIT_NOPARACHUTE</code> .. compatibility; this flag is ignored</li>
</ul>
<p>
If you want to initialize subsystems separately you would call <code>SDL_Init(0)</code> followed by <code>SDL_InitSubSystem()</code> with the desired subsystem flag.
</p>
<p>
<strong>sdl2.InitSubSystem</strong>
</p>
<p>
<code>sdl2.InitSubSystem(flags:number):void</code>
</p>
<p>
Use this function to initialize specific SDL subsystems.
</p>
<p>
After SDL has been initialized with <code>SDL_Init()</code> you may initialize uninitialized subsystems with <code>SDL_InitSubSystem()</code>.
</p>
<p>
These are the flags which may be passed to <code>SDL_InitSubSystem()</code> and may be OR'd together to initialize multiple subsystems simultaneously.
</p>
<ul>
<li><code>sdl2.INIT_TIMER</code> .. timer subsystem</li>
<li><code>sdl2.INIT_AUDIO</code> .. audio subsystem</li>
<li><code>sdl2.INIT_VIDEO</code> .. video subsystem</li>
<li><code>sdl2.INIT_JOYSTICK</code> .. joystick subsystem</li>
<li><code>sdl2.INIT_HAPTIC</code> .. haptic (force feedback) subsystem</li>
<li><code>sdl2.INIT_GAMECONTROLLER</code> .. controller subsystem</li>
<li><code>sdl2.INIT_EVENTS</code> .. events subsystem</li>
<li><code>sdl2.INIT_EVERYTHING</code> .. all of the above subsystems</li>
<li><code>sdl2.INIT_NOPARACHUTE</code> .. compatibility; this flag is ignored</li>
</ul>
<p>
If you want to initialize subsystems separately you would call <code>SDL_Init(0)</code> followed by <code>SDL_InitSubSystem()</code> with the desired subsystem flag.
</p>
<p>
<strong>sdl2.Quit</strong>
</p>
<p>
<code>sdl2.Quit():void</code>
</p>
<p>
Use this function to clean up all initialized subsystems. You should call it upon all exit conditions.
</p>
<p>
You should call this function even if you have already shutdown each initialized subsystem with <code>SDL_QuitSubSystem()</code>.
</p>
<p>
If you start a subsystem using a call to that subsystem's init function (for example <code>SDL_VideoInit()</code>) instead of <code>SDL_Init()</code> or <code>SDL_InitSubSystem()</code>, then you must use that subsystem's quit function (<code>SDL_VideoQuit()</code>) to shut it down before calling <code>SDL_Quit()</code>.
</p>
<p>
You can use this function with <code>atexit()</code> to ensure that it is run when your application is shutdown, but it is not wise to do this from a library or other dynamically loaded code.
</p>
<p>
<strong>sdl2.QuitSubSystem</strong>
</p>
<p>
<code>sdl2.QuitSubSystem(flags:number):void</code>
</p>
<p>
Use this function to shut down specific SDL subsystems.
</p>
<p>
These are the flags which may be passed to <code>SDL_QuitSubSystem()</code> and may be OR'd together to quit multiple subsystems simultaneously.
</p>
<ul>
<li><code>sdl2.INIT_TIMER</code> .. timer subsystem</li>
<li><code>sdl2.INIT_AUDIO</code> .. audio subsystem</li>
<li><code>sdl2.INIT_VIDEO</code> .. video subsystem</li>
<li><code>sdl2.INIT_JOYSTICK</code> .. joystick subsystem</li>
<li><code>sdl2.INIT_HAPTIC</code> .. haptic (force feedback) subsystem</li>
<li><code>sdl2.INIT_GAMECONTROLLER</code> .. controller subsystem</li>
<li><code>sdl2.INIT_EVENTS</code> .. events subsystem</li>
<li><code>sdl2.INIT_EVERYTHING</code> .. all of the above subsystems</li>
<li><code>sdl2.INIT_NOPARACHUTE</code> .. compatibility; this flag is ignored</li>
</ul>
<p>
If you want to initialize subsystems separately you would call <code>SDL_Init(0)</code> followed by <code>SDL_InitSubSystem()</code> with the desired subsystem flag.
</p>
<p>
<strong>sdl2.SetMainReady</strong>
</p>
<p>
<code>sdl2.SetMainReady():void</code>
</p>
<p>
Use this function to circumvent failure of <code>SDL_Init()</code> when not using <code>SDL_main()</code> as an entry point.
</p>
<p>
This function is defined in SDL<em>main.h, along with the preprocessor</em>rule to redefine <code>main()</code> as <code>SDL_main()</code>. Thus to ensure that your <code>main()</code> function will not be changed it is necessary to define <code>SDL_MAIN_HANDLED</code> before including SDL.h.
</p>
<p>
<strong>sdl2.WasInit</strong>
</p>
<p>
<code>sdl2.WasInit(flags:number) {block?}</code>
</p>
<p>
Use this function to return a mask of the specified subsystems which have previously been initialized.
</p>
<p>
These are the flags which may be passed to <code>SDL_WasInit()</code> and may be OR'd together to query multiple subsystems simultaneously.
</p>
<ul>
<li><code>sdl2.INIT_TIMER</code> .. timer subsystem</li>
<li><code>sdl2.INIT_AUDIO</code> .. audio subsystem</li>
<li><code>sdl2.INIT_VIDEO</code> .. video subsystem</li>
<li><code>sdl2.INIT_JOYSTICK</code> .. joystick subsystem</li>
<li><code>sdl2.INIT_HAPTIC</code> .. haptic (force feedback) subsystem</li>
<li><code>sdl2.INIT_GAMECONTROLLER</code> .. controller subsystem</li>
<li><code>sdl2.INIT_EVENTS</code> .. events subsystem</li>
<li><code>sdl2.INIT_EVERYTHING</code> .. all of the above subsystems</li>
<li><code>sdl2.INIT_NOPARACHUTE</code> .. compatibility; this flag is ignored</li>
</ul>
<p>
If you want to initialize subsystems separately you would call <code>SDL_Init(0)</code> followed by <code>SDL_InitSubSystem()</code> with the desired subsystem flag.
</p>
<p>
<strong>sdl2.AddHintCallback</strong>
</p>
<p>
<code>sdl2.AddHintCallback():void</code>
</p>
<p>
<strong>sdl2.ClearHints</strong>
</p>
<p>
<code>sdl2.ClearHints():void</code>
</p>
<p>
<strong>sdl2.DelhintCallback</strong>
</p>
<p>
<code>sdl2.DelhintCallback():void</code>
</p>
<p>
<strong>sdl2.GetHint</strong>
</p>
<p>
<code>sdl2.GetHint():void</code>
</p>
<p>
<strong>sdl2.SetHint</strong>
</p>
<p>
<code>sdl2.SetHint():void</code>
</p>
<p>
<strong>sdl2.SetHintWithPriority</strong>
</p>
<p>
<code>sdl2.SetHintWithPriority():void</code>
</p>
<p>
<strong>sdl2.ClearError</strong>
</p>
<p>
<code>sdl2.ClearError():void</code>
</p>
<p>
Use this function to clear any previous error message.
</p>
<p>
<strong>sdl2.GetError</strong>
</p>
<p>
<code>sdl2.GetError() {block?}</code>
</p>
<p>
Use this function to retrieve a message about the last error that occurred.
</p>
<p>
Returns a message with information about the specific error that occurred, or an empty string if there hasn't been an error since the last call to <code>SDL_ClearError()</code>. Without calling <code>SDL_ClearError()</code>, the message is only applicable when an SDL function has signaled an error. You must check the return values of SDL function calls to determine when to appropriately call <code>SDL_GetError()</code>.
</p>
<p>
This string is statically allocated and must not be freed by the application.
</p>
<p>
It is possible for multiple errors to occur before calling <code>SDL_GetError()</code>. Only the last error is returned.
</p>
<p>
<strong>sdl2.SetError</strong>
</p>
<p>
<code>sdl2.SetError():void</code>
</p>
<p>
<strong>sdl2.Log</strong>
</p>
<p>
<code>sdl2.Log():void</code>
</p>
<p>
<strong>sdl2.LogCritical</strong>
</p>
<p>
<code>sdl2.LogCritical():void</code>
</p>
<p>
<strong>sdl2.LogDebug</strong>
</p>
<p>
<code>sdl2.LogDebug():void</code>
</p>
<p>
<strong>sdl2.LogError</strong>
</p>
<p>
<code>sdl2.LogError():void</code>
</p>
<p>
<strong>sdl2.LogGetOutputFunction</strong>
</p>
<p>
<code>sdl2.LogGetOutputFunction():void</code>
</p>
<p>
<strong>sdl2.LogGetPriority</strong>
</p>
<p>
<code>sdl2.LogGetPriority():void</code>
</p>
<p>
<strong>sdl2.LogInfo</strong>
</p>
<p>
<code>sdl2.LogInfo():void</code>
</p>
<p>
<strong>sdl2.LogMessage</strong>
</p>
<p>
<code>sdl2.LogMessage():void</code>
</p>
<p>
<strong>sdl2.LogMessageV</strong>
</p>
<p>
<code>sdl2.LogMessageV():void</code>
</p>
<p>
<strong>sdl2.LogResetPriorities</strong>
</p>
<p>
<code>sdl2.LogResetPriorities():void</code>
</p>
<p>
<strong>sdl2.LogSetAllPriority</strong>
</p>
<p>
<code>sdl2.LogSetAllPriority():void</code>
</p>
<p>
<strong>sdl2.LogSetOutputFunction</strong>
</p>
<p>
<code>sdl2.LogSetOutputFunction():void</code>
</p>
<p>
<strong>sdl2.LogSetPriority</strong>
</p>
<p>
<code>sdl2.LogSetPriority():void</code>
</p>
<p>
<strong>sdl2.LogVerbose</strong>
</p>
<p>
<code>sdl2.LogVerbose():void</code>
</p>
<p>
<strong>sdl2.LogWarn</strong>
</p>
<p>
<code>sdl2.LogWarn():void</code>
</p>
<p>
<strong>sdl2.GetAssertionHandler</strong>
</p>
<p>
<code>sdl2.GetAssertionHandler():void</code>
</p>
<p>
<strong>sdl2.GetAssertionReport</strong>
</p>
<p>
<code>sdl2.GetAssertionReport():void</code>
</p>
<p>
<strong>sdl2.GetDefaultAssertionHandler</strong>
</p>
<p>
<code>sdl2.GetDefaultAssertionHandler():void</code>
</p>
<p>
<strong>sdl2.ResetAssertionReport</strong>
</p>
<p>
<code>sdl2.ResetAssertionReport():void</code>
</p>
<p>
<strong>sdl2.SetAssertionHandler</strong>
</p>
<p>
<code>sdl2.SetAssertionHandler():void</code>
</p>
<p>
<strong>sdl2.TriggerBreakpoint</strong>
</p>
<p>
<code>sdl2.TriggerBreakpoint():void</code>
</p>
<p>
<strong>sdl2.assert</strong>
</p>
<p>
<code>sdl2.assert():void</code>
</p>
<p>
<strong>sdl2.assert_paranoid</strong>
</p>
<p>
<code>sdl2.assert_paranoid():void</code>
</p>
<p>
<strong>sdl2.assert_release</strong>
</p>
<p>
<code>sdl2.assert_release():void</code>
</p>
<p>
<strong>sdl2.GetRevision</strong>
</p>
<p>
<code>sdl2.GetRevision() {block?}</code>
</p>
<p>
<strong>sdl2.GetRevisionNumber</strong>
</p>
<p>
<code>sdl2.GetRevisionNumber() {block?}</code>
</p>
<p>
<strong>sdl2.GetVersion</strong>
</p>
<p>
<code>sdl2.GetVersion() {block?}</code>
</p>
<p>
<strong>sdl2.VERSION</strong>
</p>
<p>
<code>sdl2.VERSION() {block?}</code>
</p>
<p>
<strong>sdl2.VERSION_ATLEAST</strong>
</p>
<p>
<code>sdl2.VERSION_ATLEAST(X:number, Y:number, Z:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateWindow</strong>
</p>
<p>
<code>sdl2.CreateWindow(title:string, x:number, y:number, w:number, h:number, flags:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateWindowAndRenderer</strong>
</p>
<p>
<code>sdl2.CreateWindowAndRenderer(width:number, height:number, window_flags:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateWindowFrom</strong>
</p>
<p>
<code>sdl2.CreateWindowFrom():void</code>
</p>
<p>
<strong>sdl2.DestroyWindow</strong>
</p>
<p>
<code>sdl2.DestroyWindow(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.DisableScreenSaver</strong>
</p>
<p>
<code>sdl2.DisableScreenSaver():void</code>
</p>
<p>
<strong>sdl2.EnableScreenSaver</strong>
</p>
<p>
<code>sdl2.EnableScreenSaver():void</code>
</p>
<p>
<strong>sdl2.GL_CreateContext</strong>
</p>
<p>
<code>sdl2.GL_CreateContext(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GL_DeleteContext</strong>
</p>
<p>
<code>sdl2.GL_DeleteContext(context:sdl2.GLContext):void</code>
</p>
<p>
<strong>sdl2.GL_ExtensionSupported</strong>
</p>
<p>
<code>sdl2.GL_ExtensionSupported(extension:string) {block?}</code>
</p>
<p>
<strong>sdl2.GL_GetAttribute</strong>
</p>
<p>
<code>sdl2.GL_GetAttribute(attr:number) {block?}</code>
</p>
<p>
<strong>sdl2.GL_GetCurrentContext</strong>
</p>
<p>
<code>sdl2.GL_GetCurrentContext() {block?}</code>
</p>
<p>
<strong>sdl2.GL_GetCurrentWindow</strong>
</p>
<p>
<code>sdl2.GL_GetCurrentWindow() {block?}</code>
</p>
<p>
<strong>sdl2.GL_GetDrawableSize</strong>
</p>
<p>
<code>sdl2.GL_GetDrawableSize(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GL_GetProcAddress</strong>
</p>
<p>
<code>sdl2.GL_GetProcAddress():void</code>
</p>
<p>
<strong>sdl2.GL_GetSwapInterval</strong>
</p>
<p>
<code>sdl2.GL_GetSwapInterval() {block?}</code>
</p>
<p>
<strong>sdl2.GL_LoadLibrary</strong>
</p>
<p>
<code>sdl2.GL_LoadLibrary(path:string):void</code>
</p>
<p>
<strong>sdl2.GL_MakeCurrent</strong>
</p>
<p>
<code>sdl2.GL_MakeCurrent(window:sdl2.Window, context:sdl2.GLContext):void</code>
</p>
<p>
<strong>sdl2.GL_ResetAttributes</strong>
</p>
<p>
<code>sdl2.GL_ResetAttributes():void</code>
</p>
<p>
<strong>sdl2.GL_SetAttribute</strong>
</p>
<p>
<code>sdl2.GL_SetAttribute(attr:number, value:number):void</code>
</p>
<p>
<strong>sdl2.GL_SetSwapInterval</strong>
</p>
<p>
<code>sdl2.GL_SetSwapInterval(interval:number):void</code>
</p>
<p>
<strong>sdl2.GL_SwapWindow</strong>
</p>
<p>
<code>sdl2.GL_SwapWindow(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.GL_UnloadLibrary</strong>
</p>
<p>
<code>sdl2.GL_UnloadLibrary():void</code>
</p>
<p>
<strong>sdl2.GetClosestDisplayMode</strong>
</p>
<p>
<code>sdl2.GetClosestDisplayMode(displayIndex:number, mode:sdl2.DisplayMode) {block?}</code>
</p>
<p>
<strong>sdl2.GetCurrentDisplayMode</strong>
</p>
<p>
<code>sdl2.GetCurrentDisplayMode(displayIndex:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetCurrentVideoDriver</strong>
</p>
<p>
<code>sdl2.GetCurrentVideoDriver() {block?}</code>
</p>
<p>
<strong>sdl2.GetDesktopDisplayMode</strong>
</p>
<p>
<code>sdl2.GetDesktopDisplayMode(displayIndex:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetDisplayBounds</strong>
</p>
<p>
<code>sdl2.GetDisplayBounds(displayIndex:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetDisplayMode</strong>
</p>
<p>
<code>sdl2.GetDisplayMode(displayIndex:number, modeIndex:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetDisplayName</strong>
</p>
<p>
<code>sdl2.GetDisplayName(dipslayIndex:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetNumDisplayModes</strong>
</p>
<p>
<code>sdl2.GetNumDisplayModes(displayIndex:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetNumVideoDisplays</strong>
</p>
<p>
<code>sdl2.GetNumVideoDisplays() {block?}</code>
</p>
<p>
<strong>sdl2.GetNumVideoDrivers</strong>
</p>
<p>
<code>sdl2.GetNumVideoDrivers() {block?}</code>
</p>
<p>
<strong>sdl2.GetVideoDriver</strong>
</p>
<p>
<code>sdl2.GetVideoDriver(index:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowBrightness</strong>
</p>
<p>
<code>sdl2.GetWindowBrightness(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowData</strong>
</p>
<p>
<code>sdl2.GetWindowData(window:sdl2.Window, name:string):void</code>
</p>
<p>
<strong>sdl2.GetWindowDisplayIndex</strong>
</p>
<p>
<code>sdl2.GetWindowDisplayIndex(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowDisplayMode</strong>
</p>
<p>
<code>sdl2.GetWindowDisplayMode(window:sdl2.Window, mode:sdl2.DisplayMode):void</code>
</p>
<p>
<strong>sdl2.GetWindowFlags</strong>
</p>
<p>
<code>sdl2.GetWindowFlags(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowFromID</strong>
</p>
<p>
<code>sdl2.GetWindowFromID(id:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowGammaRamp</strong>
</p>
<p>
<code>sdl2.GetWindowGammaRamp(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowGrab</strong>
</p>
<p>
<code>sdl2.GetWindowGrab(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowID</strong>
</p>
<p>
<code>sdl2.GetWindowID(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowMaximumSize</strong>
</p>
<p>
<code>sdl2.GetWindowMaximumSize(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowMinimumSize</strong>
</p>
<p>
<code>sdl2.GetWindowMinimumSize(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowPixelFormat</strong>
</p>
<p>
<code>sdl2.GetWindowPixelFormat(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowPosition</strong>
</p>
<p>
<code>sdl2.GetWindowPosition(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowSize</strong>
</p>
<p>
<code>sdl2.GetWindowSize(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowSurface</strong>
</p>
<p>
<code>sdl2.GetWindowSurface(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowTitle</strong>
</p>
<p>
<code>sdl2.GetWindowTitle(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetWindowWMInfo</strong>
</p>
<p>
<code>sdl2.GetWindowWMInfo(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.HideWindow</strong>
</p>
<p>
<code>sdl2.HideWindow(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.IsScreenSaverEnabled</strong>
</p>
<p>
<code>sdl2.IsScreenSaverEnabled() {block?}</code>
</p>
<p>
<strong>sdl2.MaximizeWindow</strong>
</p>
<p>
<code>sdl2.MaximizeWindow(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.MinimizeWindow</strong>
</p>
<p>
<code>sdl2.MinimizeWindow(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.RaiseWindow</strong>
</p>
<p>
<code>sdl2.RaiseWindow(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.RestoreWindow</strong>
</p>
<p>
<code>sdl2.RestoreWindow(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.SetWindowBordered</strong>
</p>
<p>
<code>sdl2.SetWindowBordered(window:sdl2.Window, bordered:boolean):void</code>
</p>
<p>
<strong>sdl2.SetWindowBrightness</strong>
</p>
<p>
<code>sdl2.SetWindowBrightness(window:sdl2.Window, brightness:number):void</code>
</p>
<p>
<strong>sdl2.SetWindowData</strong>
</p>
<p>
<code>sdl2.SetWindowData(window:sdl2.Window, name:string):void</code>
</p>
<p>
<strong>sdl2.SetWindowDisplayMode</strong>
</p>
<p>
<code>sdl2.SetWindowDisplayMode(window:sdl2.Window, mode:sdl2.DisplayMode):void</code>
</p>
<p>
<strong>sdl2.SetWindowFullscreen</strong>
</p>
<p>
<code>sdl2.SetWindowFullscreen(window:sdl2.Window, flags:number):void</code>
</p>
<p>
<strong>sdl2.SetWindowGammaRamp</strong>
</p>
<p>
<code>sdl2.SetWindowGammaRamp(window:sdl2.Window, red[]:number, green[]:number, blue[]:number):void</code>
</p>
<p>
<strong>sdl2.SetWindowGrab</strong>
</p>
<p>
<code>sdl2.SetWindowGrab(window:sdl2.Window, grabbed:boolean):void</code>
</p>
<p>
<strong>sdl2.SetWindowHitTest</strong>
</p>
<p>
<code>sdl2.SetWindowHitTest(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.SetWindowIcon</strong>
</p>
<p>
<code>sdl2.SetWindowIcon(window:sdl2.Window, icon:sdl2.Surface):void</code>
</p>
<p>
<strong>sdl2.SetWindowMaximumSize</strong>
</p>
<p>
<code>sdl2.SetWindowMaximumSize(window:sdl2.Window, max_w:number, max_h:number):void</code>
</p>
<p>
<strong>sdl2.SetWindowMinimumSize</strong>
</p>
<p>
<code>sdl2.SetWindowMinimumSize(window:sdl2.Window, min_w:number, min_h:number):void</code>
</p>
<p>
<strong>sdl2.SetWindowPosition</strong>
</p>
<p>
<code>sdl2.SetWindowPosition(window:sdl2.Window, x:number, y:number):void</code>
</p>
<p>
<strong>sdl2.SetWindowSize</strong>
</p>
<p>
<code>sdl2.SetWindowSize(window:sdl2.Window, w:number, h:number):void</code>
</p>
<p>
<strong>sdl2.SetWindowTitle</strong>
</p>
<p>
<code>sdl2.SetWindowTitle(window:sdl2.Window, title:string):void</code>
</p>
<p>
<strong>sdl2.ShowMessageBox</strong>
</p>
<p>
<code>sdl2.ShowMessageBox():void</code>
</p>
<p>
<strong>sdl2.ShowSimpleMessageBox</strong>
</p>
<p>
<code>sdl2.ShowSimpleMessageBox(flags:number, title:string, message:string, window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.ShowWindow</strong>
</p>
<p>
<code>sdl2.ShowWindow(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.UpdateWindowSurface</strong>
</p>
<p>
<code>sdl2.UpdateWindowSurface(window:sdl2.Window):void</code>
</p>
<p>
<strong>sdl2.UpdateWindowSurfaceRects</strong>
</p>
<p>
<code>sdl2.UpdateWindowSurfaceRects(window:sdl2.Window, rects[]:sdl2.Rect):void</code>
</p>
<p>
<strong>sdl2.VideoInit</strong>
</p>
<p>
<code>sdl2.VideoInit(driver_name:string):void</code>
</p>
<p>
<strong>sdl2.VideoQuit</strong>
</p>
<p>
<code>sdl2.VideoQuit():void</code>
</p>
<p>
<strong>sdl2.CreateRenderer</strong>
</p>
<p>
<code>sdl2.CreateRenderer(window:sdl2.Window, index:number, flags:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateSoftwareRenderer</strong>
</p>
<p>
<code>sdl2.CreateSoftwareRenderer(surface:sdl2.Surface) {block?}</code>
</p>
<p>
<strong>sdl2.CreateTexture</strong>
</p>
<p>
<code>sdl2.CreateTexture(renderer:sdl2.Renderer, format:number, access:number, w:number, h:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateTextureFromSurface</strong>
</p>
<p>
<code>sdl2.CreateTextureFromSurface(renderer:sdl2.Renderer, surface:sdl2.Surface) {block?}</code>
</p>
<p>
<strong>sdl2.DestroyRenderer</strong>
</p>
<p>
<code>sdl2.DestroyRenderer(renderer:sdl2.Renderer):void</code>
</p>
<p>
<strong>sdl2.DestroyTexture</strong>
</p>
<p>
<code>sdl2.DestroyTexture(texture:sdl2.Texture):void</code>
</p>
<p>
<strong>sdl2.GL_BindTexture</strong>
</p>
<p>
<code>sdl2.GL_BindTexture(texture:sdl2.Texture) {block?}</code>
</p>
<p>
<strong>sdl2.GL_UnbindTexture</strong>
</p>
<p>
<code>sdl2.GL_UnbindTexture(texture:sdl2.Texture):void</code>
</p>
<p>
<strong>sdl2.GetNumRenderDrivers</strong>
</p>
<p>
<code>sdl2.GetNumRenderDrivers() {block?}</code>
</p>
<p>
<strong>sdl2.GetRenderDrawBlendMode</strong>
</p>
<p>
<code>sdl2.GetRenderDrawBlendMode(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.GetRenderDrawColor</strong>
</p>
<p>
<code>sdl2.GetRenderDrawColor(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.GetRenderDriverInfo</strong>
</p>
<p>
<code>sdl2.GetRenderDriverInfo(index:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetRenderTarget</strong>
</p>
<p>
<code>sdl2.GetRenderTarget(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.GetRenderer</strong>
</p>
<p>
<code>sdl2.GetRenderer(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.GetRendererInfo</strong>
</p>
<p>
<code>sdl2.GetRendererInfo(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.GetRenderOutputSize</strong>
</p>
<p>
<code>sdl2.GetRenderOutputSize(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.GetTextureAlphaMod</strong>
</p>
<p>
<code>sdl2.GetTextureAlphaMod(texture:sdl2.Texture) {block?}</code>
</p>
<p>
<strong>sdl2.GetTextureBlendMode</strong>
</p>
<p>
<code>sdl2.GetTextureBlendMode(texture:sdl2.Texture) {block?}</code>
</p>
<p>
<strong>sdl2.GetTextureColorMod</strong>
</p>
<p>
<code>sdl2.GetTextureColorMod(texture:sdl2.Texture) {block?}</code>
</p>
<p>
<strong>sdl2.LockTexture</strong>
</p>
<p>
<code>sdl2.LockTexture(texture:sdl2.Texture, rect:sdl2.Rect):void</code>
</p>
<p>
<strong>sdl2.QueryTexture</strong>
</p>
<p>
<code>sdl2.QueryTexture(texture:sdl2.Texture) {block?}</code>
</p>
<p>
<strong>sdl2.RenderClear</strong>
</p>
<p>
<code>sdl2.RenderClear(renderer:sdl2.Renderer):void</code>
</p>
<p>
<strong>sdl2.RenderCopy</strong>
</p>
<p>
<code>sdl2.RenderCopy(renderer:sdl2.Renderer, texture:sdl2.Texture, srcrect:sdl2.Rect:nil, dstrect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.RenderCopyEx</strong>
</p>
<p>
<code>sdl2.RenderCopyEx(renderer:sdl2.Renderer, texture:sdl2.Texture, srcrect:sdl2.Rect:nil, dstrect:sdl2.Rect:nil, angle:number, center:sdl2.Point:nil, flip:number):void</code>
</p>
<p>
<strong>sdl2.RenderDrawLine</strong>
</p>
<p>
<code>sdl2.RenderDrawLine(renderer:sdl2.Renderer, x1:number, y1:number, x2:number, y2:number):void</code>
</p>
<p>
<strong>sdl2.RenderDrawLines</strong>
</p>
<p>
<code>sdl2.RenderDrawLines(renderer:sdl2.Renderer, points[]:sdl2.Point):void</code>
</p>
<p>
<strong>sdl2.RenderDrawPoint</strong>
</p>
<p>
<code>sdl2.RenderDrawPoint(renderer:sdl2.Renderer, x:number, y:number):void</code>
</p>
<p>
<strong>sdl2.RenderDrawPoints</strong>
</p>
<p>
<code>sdl2.RenderDrawPoints(renderer:sdl2.Renderer, points[]:sdl2.Point):void</code>
</p>
<p>
<strong>sdl2.RenderDrawRect</strong>
</p>
<p>
<code>sdl2.RenderDrawRect(renderer:sdl2.Renderer, rect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.RenderDrawRects</strong>
</p>
<p>
<code>sdl2.RenderDrawRects(renderer:sdl2.Renderer, rects[]:sdl2.Rect):void</code>
</p>
<p>
<strong>sdl2.RenderFillRect</strong>
</p>
<p>
<code>sdl2.RenderFillRect(renderer:sdl2.Renderer, rect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.RenderFillRects</strong>
</p>
<p>
<code>sdl2.RenderFillRects(renderer:sdl2.Renderer, rects[]:sdl2.Rect):void</code>
</p>
<p>
<strong>sdl2.RenderGetClipRect</strong>
</p>
<p>
<code>sdl2.RenderGetClipRect(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.RenderGetLogicalSize</strong>
</p>
<p>
<code>sdl2.RenderGetLogicalSize(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.RenderGetScale</strong>
</p>
<p>
<code>sdl2.RenderGetScale(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.RenderGetViewport</strong>
</p>
<p>
<code>sdl2.RenderGetViewport(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.RenderIsClipEnabled</strong>
</p>
<p>
<code>sdl2.RenderIsClipEnabled(renderer:sdl2.Renderer)</code>
</p>
<p>
<strong>sdl2.RenderPresent</strong>
</p>
<p>
<code>sdl2.RenderPresent(renderer:sdl2.Renderer):void</code>
</p>
<p>
<strong>sdl2.RenderReadPixels</strong>
</p>
<p>
<code>sdl2.RenderReadPixels(renderer:sdl2.Renderer, rect:sdl2.Rect:nil, format:symbol) {block?}</code>
</p>
<p>
<strong>sdl2.RenderSetClipRect</strong>
</p>
<p>
<code>sdl2.RenderSetClipRect(renderer:sdl2.Renderer, rect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.RenderSetLogicalSize</strong>
</p>
<p>
<code>sdl2.RenderSetLogicalSize(renderer:sdl2.Renderer, w:number, h:number):void</code>
</p>
<p>
<strong>sdl2.RenderSetScale</strong>
</p>
<p>
<code>sdl2.RenderSetScale(renderer:sdl2.Renderer, scaleX:number, scaleY:number):void</code>
</p>
<p>
<strong>sdl2.RenderSetViewport</strong>
</p>
<p>
<code>sdl2.RenderSetViewport(renderer:sdl2.Renderer, rect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.RenderTargetSupported</strong>
</p>
<p>
<code>sdl2.RenderTargetSupported(renderer:sdl2.Renderer) {block?}</code>
</p>
<p>
<strong>sdl2.SetRenderDrawBlendMode</strong>
</p>
<p>
<code>sdl2.SetRenderDrawBlendMode(renderer:sdl2.Renderer, blendMode:number):void</code>
</p>
<p>
<strong>sdl2.SetRenderDrawColor</strong>
</p>
<p>
<code>sdl2.SetRenderDrawColor(renderer:sdl2.Renderer, r:number, g:number, b:number, a:number):void</code>
</p>
<p>
<strong>sdl2.SetRenderTarget</strong>
</p>
<p>
<code>sdl2.SetRenderTarget(renderer:sdl2.Renderer, texture:sdl2.Texture:nil):void</code>
</p>
<p>
<strong>sdl2.SetTextureAlphaMod</strong>
</p>
<p>
<code>sdl2.SetTextureAlphaMod(texture:sdl2.Texture, alpha:number):void</code>
</p>
<p>
<strong>sdl2.SetTextureBlendMode</strong>
</p>
<p>
<code>sdl2.SetTextureBlendMode(texture:sdl2.Texture, blendMode:number):void</code>
</p>
<p>
<strong>sdl2.SetTextureColorMod</strong>
</p>
<p>
<code>sdl2.SetTextureColorMod(texture:sdl2.Texture, r:number, g:number, b:number):void</code>
</p>
<p>
<strong>sdl2.UnlockTexture</strong>
</p>
<p>
<code>sdl2.UnlockTexture(texture:sdl2.Texture):void</code>
</p>
<p>
<strong>sdl2.UpdateTexture</strong>
</p>
<p>
<code>sdl2.UpdateTexture(texture:sdl2.Texture, rect:sdl2.Rect:nil, pitch:number):void</code>
</p>
<p>
<strong>sdl2.UpdateYUVTexture</strong>
</p>
<p>
<code>sdl2.UpdateYUVTexture():void</code>
</p>
<p>
<strong>sdl2.AllocFormat</strong>
</p>
<p>
<code>sdl2.AllocFormat(pixel_format:number) {block?}</code>
</p>
<p>
<strong>sdl2.AllocPalette</strong>
</p>
<p>
<code>sdl2.AllocPalette(ncolors:number) {block?}</code>
</p>
<p>
<strong>sdl2.CalculateGammaRamp</strong>
</p>
<p>
<code>sdl2.CalculateGammaRamp(gamma:number) {block?}</code>
</p>
<p>
<strong>sdl2.FreeFormat</strong>
</p>
<p>
<code>sdl2.FreeFormat(format:sdl2.PixelFormat):void</code>
</p>
<p>
<strong>sdl2.FreePalette</strong>
</p>
<p>
<code>sdl2.FreePalette(palette:sdl2.Palette):void</code>
</p>
<p>
<strong>sdl2.GetPixelFormatName</strong>
</p>
<p>
<code>sdl2.GetPixelFormatName(format:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetRGB</strong>
</p>
<p>
<code>sdl2.GetRGB(pixel:number, format:sdl2.PixelFormat) {block?}</code>
</p>
<p>
<strong>sdl2.GetRGBA</strong>
</p>
<p>
<code>sdl2.GetRGBA(pixel:number, format:sdl2.PixelFormat) {block?}</code>
</p>
<p>
<strong>sdl2.MapRGB</strong>
</p>
<p>
<code>sdl2.MapRGB(format:sdl2.PixelFormat, r:number, g:number, b:number) {block?}</code>
</p>
<p>
<strong>sdl2.MapRGBA</strong>
</p>
<p>
<code>sdl2.MapRGBA(format:sdl2.PixelFormat, r:number, g:number, b:number, a:number) {block?}</code>
</p>
<p>
<strong>sdl2.MasksToPixelFormatEnum</strong>
</p>
<p>
<code>sdl2.MasksToPixelFormatEnum(bpp:number, Rmask:number, Gmask:number, Bmask:number, Amask:number) {block?}</code>
</p>
<p>
<strong>sdl2.PixelFormatEnumToMasks</strong>
</p>
<p>
<code>sdl2.PixelFormatEnumToMasks(format:number) {block?}</code>
</p>
<p>
<strong>sdl2.SetPaletteColors</strong>
</p>
<p>
<code>sdl2.SetPaletteColors(palette:sdl2.Palette, colors[]:sdl2.Color, firstcolor:number, ncolors:number):void</code>
</p>
<p>
<strong>sdl2.SetPixelFormatPalette</strong>
</p>
<p>
<code>sdl2.SetPixelFormatPalette(format:sdl2.PixelFormat, palette:sdl2.Palette):void</code>
</p>
<p>
<strong>sdl2.EnclosePoints</strong>
</p>
<p>
<code>sdl2.EnclosePoints(points[]:sdl2.Point, clip:sdl2.Rect) {block?}</code>
</p>
<p>
<strong>sdl2.HasIntersection</strong>
</p>
<p>
<code>sdl2.HasIntersection(A:sdl2.Rect, B:sdl2.Rect) {block?}</code>
</p>
<p>
<strong>sdl2.IntersectRect</strong>
</p>
<p>
<code>sdl2.IntersectRect(A:sdl2.Rect, B:sdl2.Rect) {block?}</code>
</p>
<p>
<strong>sdl2.IntersectRectAndLine</strong>
</p>
<p>
<code>sdl2.IntersectRectAndLine(rect:sdl2.Rect, X1:number, Y1:number, X2:number, Y2:number)</code>
</p>
<p>
<strong>sdl2.PointInRect</strong>
</p>
<p>
<code>sdl2.PointInRect(p:sdl2.Point, r:sdl2.Rect)</code>
</p>
<p>
<strong>sdl2.RectEmpty</strong>
</p>
<p>
<code>sdl2.RectEmpty(r:sdl2.Rect) {block?}</code>
</p>
<p>
<strong>sdl2.RectEquals</strong>
</p>
<p>
<code>sdl2.RectEquals(a:sdl2.Rect, b:sdl2.Rect) {block?}</code>
</p>
<p>
<strong>sdl2.UnionRect</strong>
</p>
<p>
<code>sdl2.UnionRect(A:sdl2.Rect, B:sdl2.Rect) {block?}</code>
</p>
<p>
<strong>sdl2.BlitScaled</strong>
</p>
<p>
<code>sdl2.BlitScaled(src:sdl2.Surface, srcrect:sdl2.Rect:nil, dst:sdl2.Surface, dstrect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.BlitSurface</strong>
</p>
<p>
<code>sdl2.BlitSurface(src:sdl2.Surface, srcrect:sdl2.Rect:nil, dst:sdl2.Surface, dstrect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.ConvertPixels</strong>
</p>
<p>
<code>sdl2.ConvertPixels(width:number, height:number, src_format:number, dst_format:number):void</code>
</p>
<p>
<strong>sdl2.ConvertSurface</strong>
</p>
<p>
<code>sdl2.ConvertSurface(src:sdl2.Surface, fmt:sdl2.PixelFormat, flags:number) {block?}</code>
</p>
<p>
<strong>sdl2.ConvertSurfaceFormat</strong>
</p>
<p>
<code>sdl2.ConvertSurfaceFormat(src:sdl2.Surface, pixel_format:number, flags:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateRGBSurface</strong>
</p>
<p>
<code>sdl2.CreateRGBSurface(flags:number, width:number, height:number, depth:number, Rmask:number, Gmask:number, Bmask:number, Amask:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateRGBSurfaceFrom</strong>
</p>
<p>
<code>sdl2.CreateRGBSurfaceFrom(pixels, width:number, height:number, depth:number, pitch:number, Rmask:number, Gmask:number, Bmask:number, Amask:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateRGBSurfaceFromImage</strong>
</p>
<p>
<code>sdl2.CreateRGBSurfaceFromImage(image:image) {block?}</code>
</p>
<p>
<strong>sdl2.FillRect</strong>
</p>
<p>
<code>sdl2.FillRect(dst:sdl2.Surface, rect:sdl2.Rect:nil, color:number):void</code>
</p>
<p>
<strong>sdl2.FillRects</strong>
</p>
<p>
<code>sdl2.FillRects(dst:sdl2.Surface, rects[]:sdl2.Rect, color:number):void</code>
</p>
<p>
<strong>sdl2.FreeSurface</strong>
</p>
<p>
<code>sdl2.FreeSurface(surface:sdl2.Surface):void</code>
</p>
<p>
<strong>sdl2.GetClipRect</strong>
</p>
<p>
<code>sdl2.GetClipRect(surface:sdl2.Surface) {block?}</code>
</p>
<p>
<strong>sdl2.GetColorKey</strong>
</p>
<p>
<code>sdl2.GetColorKey(surface:sdl2.Surface) {block?}</code>
</p>
<p>
<strong>sdl2.GetSurfaceAlphaMod</strong>
</p>
<p>
<code>sdl2.GetSurfaceAlphaMod(surface:sdl2.Surface) {block?}</code>
</p>
<p>
<strong>sdl2.GetSurfaceBlendMode</strong>
</p>
<p>
<code>sdl2.GetSurfaceBlendMode(surface:sdl2.Surface) {block?}</code>
</p>
<p>
<strong>sdl2.GetSurfaceColorMod</strong>
</p>
<p>
<code>sdl2.GetSurfaceColorMod(surface:sdl2.Surface) {block?}</code>
</p>
<p>
<strong>sdl2.LoadBMP</strong>
</p>
<p>
<code>sdl2.LoadBMP(src:stream) {block?}</code>
</p>
<p>
<strong>sdl2.LoadBMP_RW</strong>
</p>
<p>
<code>sdl2.LoadBMP_RW():void</code>
</p>
<p>
<strong>sdl2.LockSurface</strong>
</p>
<p>
<code>sdl2.LockSurface(surface:sdl2.Surface):void</code>
</p>
<p>
<strong>sdl2.LowerBlit</strong>
</p>
<p>
<code>sdl2.LowerBlit(src:sdl2.Surface, srcrect:sdl2.Rect:nil, dst:sdl2.Surface, dstrect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.LowerBlitScaled</strong>
</p>
<p>
<code>sdl2.LowerBlitScaled(src:sdl2.Surface, srcrect:sdl2.Rect:nil, dst:sdl2.Surface, dstrect:sdl2.Rect:nil):void</code>
</p>
<p>
<strong>sdl2.MUSTLOCK</strong>
</p>
<p>
<code>sdl2.MUSTLOCK(surface:sdl2.Surface) {block?}</code>
</p>
<p>
<strong>sdl2.SaveBMP</strong>
</p>
<p>
<code>sdl2.SaveBMP(surface:sdl2.Surface, dst:stream) {block?}</code>
</p>
<p>
<strong>sdl2.SaveBMP_RW</strong>
</p>
<p>
<code>sdl2.SaveBMP_RW():void</code>
</p>
<p>
<strong>sdl2.SetClipRect</strong>
</p>
<p>
<code>sdl2.SetClipRect(surface:sdl2.Surface, rect:sdl2.Rect) {block?}</code>
</p>
<p>
<strong>sdl2.SetColorKey</strong>
</p>
<p>
<code>sdl2.SetColorKey(surface:sdl2.Surface, flag:number, key:number):void</code>
</p>
<p>
<strong>sdl2.SetSurfaceAlphaMod</strong>
</p>
<p>
<code>sdl2.SetSurfaceAlphaMod(surface:sdl2.Surface, alpha:number):void</code>
</p>
<p>
<strong>sdl2.SetSurfaceBlendMode</strong>
</p>
<p>
<code>sdl2.SetSurfaceBlendMode(surface:sdl2.Surface, blendMode:number):void</code>
</p>
<p>
<strong>sdl2.SetSurfaceColorMod</strong>
</p>
<p>
<code>sdl2.SetSurfaceColorMod(surface:sdl2.Surface, r:number, g:number, b:number):void</code>
</p>
<p>
<strong>sdl2.SetSurfacePalette</strong>
</p>
<p>
<code>sdl2.SetSurfacePalette(surface:sdl2.Surface, palette:sdl2.Palette):void</code>
</p>
<p>
<strong>sdl2.SetSurfaceRLE</strong>
</p>
<p>
<code>sdl2.SetSurfaceRLE(surface:sdl2.Surface, flag:number):void</code>
</p>
<p>
<strong>sdl2.UnlockSurface</strong>
</p>
<p>
<code>sdl2.UnlockSurface(surface:sdl2.Surface):void</code>
</p>
<p>
<strong>sdl2.GetClipboardText</strong>
</p>
<p>
<code>sdl2.GetClipboardText() {block?}</code>
</p>
<p>
<strong>sdl2.HasClipboardText</strong>
</p>
<p>
<code>sdl2.HasClipboardText() {block?}</code>
</p>
<p>
<strong>sdl2.SetClipboardText</strong>
</p>
<p>
<code>sdl2.SetClipboardText(text:string):void</code>
</p>
<p>
<strong>sdl2.AddEventWatch</strong>
</p>
<p>
<code>sdl2.AddEventWatch():void</code>
</p>
<p>
<strong>sdl2.DelEventWatch</strong>
</p>
<p>
<code>sdl2.DelEventWatch():void</code>
</p>
<p>
<strong>sdl2.EventState</strong>
</p>
<p>
<code>sdl2.EventState(type:number, state:number) {block?}</code>
</p>
<p>
<strong>sdl2.FilterEvents</strong>
</p>
<p>
<code>sdl2.FilterEvents():void</code>
</p>
<p>
<strong>sdl2.FlushEvent</strong>
</p>
<p>
<code>sdl2.FlushEvent(type:number):void</code>
</p>
<p>
<strong>sdl2.FlushEvents</strong>
</p>
<p>
<code>sdl2.FlushEvents(minType:number, maxType:number):void</code>
</p>
<p>
<strong>sdl2.GetEventFilter</strong>
</p>
<p>
<code>sdl2.GetEventFilter():void</code>
</p>
<p>
<strong>sdl2.GetNumTouchDevices</strong>
</p>
<p>
<code>sdl2.GetNumTouchDevices() {block?}</code>
</p>
<p>
<strong>sdl2.GetNumTouchFingers</strong>
</p>
<p>
<code>sdl2.GetNumTouchFingers(touchId:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetTouchDevice</strong>
</p>
<p>
<code>sdl2.GetTouchDevice(index:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetTouchFinger</strong>
</p>
<p>
<code>sdl2.GetTouchFinger(touchId:number, index:number) {block?}</code>
</p>
<p>
<strong>sdl2.HasEvent</strong>
</p>
<p>
<code>sdl2.HasEvent(type:number) {block?}</code>
</p>
<p>
<strong>sdl2.HasEvents</strong>
</p>
<p>
<code>sdl2.HasEvents(minType:number, maxType:number) {block?}</code>
</p>
<p>
<strong>sdl2.LoadDollarTemplates</strong>
</p>
<p>
<code>sdl2.LoadDollarTemplates(touchId:number, src:stream) {block?}</code>
</p>
<p>
<strong>sdl2.AddEvents</strong>
</p>
<p>
<code>sdl2.AddEvents(events[]:sdl2.Event) {block?}</code>
</p>
<p>
<strong>sdl2.PeekEvents</strong>
</p>
<p>
<code>sdl2.PeekEvents(numevents:number, minType:number, maxType:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetEvents</strong>
</p>
<p>
<code>sdl2.GetEvents(numevents:number, minType:number, maxType:number) {block?}</code>
</p>
<p>
<strong>sdl2.PollEvent</strong>
</p>
<p>
<code>sdl2.PollEvent() {block?}</code>
</p>
<p>
<strong>sdl2.PumpEvents</strong>
</p>
<p>
<code>sdl2.PumpEvents():void</code>
</p>
<p>
<strong>sdl2.PushEvent</strong>
</p>
<p>
<code>sdl2.PushEvent(event:sdl2.Event) {block?}</code>
</p>
<p>
<strong>sdl2.QuitRequested</strong>
</p>
<p>
<code>sdl2.QuitRequested() {block?}</code>
</p>
<p>
<strong>sdl2.RecordGesture</strong>
</p>
<p>
<code>sdl2.RecordGesture(touchId:number) {block?}</code>
</p>
<p>
<strong>sdl2.RegisterEvents</strong>
</p>
<p>
<code>sdl2.RegisterEvents(numevents:number) {block?}</code>
</p>
<p>
<strong>sdl2.SaveAllDollarTemplates</strong>
</p>
<p>
<code>sdl2.SaveAllDollarTemplates(dst:stream) {block?}</code>
</p>
<p>
<strong>sdl2.SaveDollarTemplate</strong>
</p>
<p>
<code>sdl2.SaveDollarTemplate(gestureId:number, dst:stream):void</code>
</p>
<p>
<strong>sdl2.SetEventFilter</strong>
</p>
<p>
<code>sdl2.SetEventFilter():void</code>
</p>
<p>
<strong>sdl2.WaitEvent</strong>
</p>
<p>
<code>sdl2.WaitEvent() {block?}</code>
</p>
<p>
<strong>sdl2.WaitEventTimeout</strong>
</p>
<p>
<code>sdl2.WaitEventTimeout(timeout:number) {block?}</code>
</p>
<p>
<strong>sdl2.CheckKeyboardState</strong>
</p>
<p>
<code>sdl2.CheckKeyboardState(scancode:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetKeyFromName</strong>
</p>
<p>
<code>sdl2.GetKeyFromName(name:string) {block?}</code>
</p>
<p>
<strong>sdl2.GetKeyFromScancode</strong>
</p>
<p>
<code>sdl2.GetKeyFromScancode(scancode:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetKeyName</strong>
</p>
<p>
<code>sdl2.GetKeyName(key:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetKeyboardFocus</strong>
</p>
<p>
<code>sdl2.GetKeyboardFocus() {block?}</code>
</p>
<p>
<strong>sdl2.GetKeyboardState</strong>
</p>
<p>
<code>sdl2.GetKeyboardState() {block?}</code>
</p>
<p>
<strong>sdl2.GetModState</strong>
</p>
<p>
<code>sdl2.GetModState() {block?}</code>
</p>
<p>
<strong>sdl2.GetScancodeFromKey</strong>
</p>
<p>
<code>sdl2.GetScancodeFromKey(key:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetScancodeFromName</strong>
</p>
<p>
<code>sdl2.GetScancodeFromName(name:string) {block?}</code>
</p>
<p>
<strong>sdl2.GetScancodeName</strong>
</p>
<p>
<code>sdl2.GetScancodeName(scancode:number) {block?}</code>
</p>
<p>
<strong>sdl2.HasScreenKeyboardSupport</strong>
</p>
<p>
<code>sdl2.HasScreenKeyboardSupport() {block?}</code>
</p>
<p>
<strong>sdl2.IsScreenKeyboardShown</strong>
</p>
<p>
<code>sdl2.IsScreenKeyboardShown(window:sdl2.Window) {block?}</code>
</p>
<p>
<strong>sdl2.IsTextInputActive</strong>
</p>
<p>
<code>sdl2.IsTextInputActive() {block?}</code>
</p>
<p>
<strong>sdl2.SetModState</strong>
</p>
<p>
<code>sdl2.SetModState(modstate:number):void</code>
</p>
<p>
<strong>sdl2.SetTextInputRect</strong>
</p>
<p>
<code>sdl2.SetTextInputRect(rect:sdl2.Rect):void</code>
</p>
<p>
<strong>sdl2.StartTextInput</strong>
</p>
<p>
<code>sdl2.StartTextInput():void</code>
</p>
<p>
<strong>sdl2.StopTextInput</strong>
</p>
<p>
<code>sdl2.StopTextInput():void</code>
</p>
<p>
<strong>sdl2.CaptureMouse</strong>
</p>
<p>
<code>sdl2.CaptureMouse(enalbed:boolean):void</code>
</p>
<p>
<strong>sdl2.CreateColorCursor</strong>
</p>
<p>
<code>sdl2.CreateColorCursor(surface:sdl2.Surface, hot_x:number, hot_y:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateCursor</strong>
</p>
<p>
<code>sdl2.CreateCursor(data:array@uchar:nomap, mask:array@uchar:nomap, w:number, h:number, hot_x:number, hot_y:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateSystemCursor</strong>
</p>
<p>
<code>sdl2.CreateSystemCursor(id:number) {block?}</code>
</p>
<p>
<strong>sdl2.FreeCursor</strong>
</p>
<p>
<code>sdl2.FreeCursor(cursor:sdl2.Cursor):void</code>
</p>
<p>
<strong>sdl2.GetCursor</strong>
</p>
<p>
<code>sdl2.GetCursor() {block?}</code>
</p>
<p>
<strong>sdl2.GetDefaultCursor</strong>
</p>
<p>
<code>sdl2.GetDefaultCursor() {block?}</code>
</p>
<p>
<strong>sdl2.GetGlobalMouseState</strong>
</p>
<p>
<code>sdl2.GetGlobalMouseState():void</code>
</p>
<p>
<strong>sdl2.GetMouseFocus</strong>
</p>
<p>
<code>sdl2.GetMouseFocus() {block?}</code>
</p>
<p>
<strong>sdl2.GetMouseState</strong>
</p>
<p>
<code>sdl2.GetMouseState() {block?}</code>
</p>
<p>
<strong>sdl2.GetRelativeMouseMode</strong>
</p>
<p>
<code>sdl2.GetRelativeMouseMode() {block?}</code>
</p>
<p>
<strong>sdl2.GetRelativeMouseState</strong>
</p>
<p>
<code>sdl2.GetRelativeMouseState() {block?}</code>
</p>
<p>
<strong>sdl2.SetCursor</strong>
</p>
<p>
<code>sdl2.SetCursor(cursor:sdl2.Cursor):void</code>
</p>
<p>
<strong>sdl2.SetRelativeMouseMode</strong>
</p>
<p>
<code>sdl2.SetRelativeMouseMode(enabled:boolean):void</code>
</p>
<p>
<strong>sdl2.ShowCursor</strong>
</p>
<p>
<code>sdl2.ShowCursor(toggle:number):void</code>
</p>
<p>
<strong>sdl2.WarpMouseGlobal</strong>
</p>
<p>
<code>sdl2.WarpMouseGlobal(x:number, y:number):void</code>
</p>
<p>
<strong>sdl2.WarpMouseInWindow</strong>
</p>
<p>
<code>sdl2.WarpMouseInWindow(window:sdl2.Window, x:number, y:number):void</code>
</p>
<p>
<strong>sdl2.JoystickClose</strong>
</p>
<p>
<code>sdl2.JoystickClose(joystick:sdl2.Joystick):void</code>
</p>
<p>
<strong>sdl2.JoystickEventState</strong>
</p>
<p>
<code>sdl2.JoystickEventState(state:number) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetAttached</strong>
</p>
<p>
<code>sdl2.JoystickGetAttached(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetAxis</strong>
</p>
<p>
<code>sdl2.JoystickGetAxis(joystick:sdl2.Joystick, axis:number) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetBall</strong>
</p>
<p>
<code>sdl2.JoystickGetBall(joystick:sdl2.Joystick, ball:number) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetButton</strong>
</p>
<p>
<code>sdl2.JoystickGetButton(joystick:sdl2.Joystick, button:number) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetDeviceGUID</strong>
</p>
<p>
<code>sdl2.JoystickGetDeviceGUID(device_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetGUID</strong>
</p>
<p>
<code>sdl2.JoystickGetGUID(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetGUIDFromString</strong>
</p>
<p>
<code>sdl2.JoystickGetGUIDFromString(pchGUID:string) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetGUIDString</strong>
</p>
<p>
<code>sdl2.JoystickGetGUIDString(guid:sdl2.JoystickGUID) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickGetHat</strong>
</p>
<p>
<code>sdl2.JoystickGetHat(joystick:sdl2.Joystick, hat:number) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickInstanceID</strong>
</p>
<p>
<code>sdl2.JoystickInstanceID(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickName</strong>
</p>
<p>
<code>sdl2.JoystickName(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickNameForIndex</strong>
</p>
<p>
<code>sdl2.JoystickNameForIndex(device_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickNumAxes</strong>
</p>
<p>
<code>sdl2.JoystickNumAxes(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickNumBalls</strong>
</p>
<p>
<code>sdl2.JoystickNumBalls(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickNumButtons</strong>
</p>
<p>
<code>sdl2.JoystickNumButtons(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickNumHats</strong>
</p>
<p>
<code>sdl2.JoystickNumHats(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickOpen</strong>
</p>
<p>
<code>sdl2.JoystickOpen(device_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.JoystickUpdate</strong>
</p>
<p>
<code>sdl2.JoystickUpdate():void</code>
</p>
<p>
<strong>sdl2.NumJoysticks</strong>
</p>
<p>
<code>sdl2.NumJoysticks() {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerAddMapping</strong>
</p>
<p>
<code>sdl2.GameControllerAddMapping(mappingString:string) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerAddMappingsFromFile</strong>
</p>
<p>
<code>sdl2.GameControllerAddMappingsFromFile(file:stream) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerAddMappingsFromRW</strong>
</p>
<p>
<code>sdl2.GameControllerAddMappingsFromRW():void</code>
</p>
<p>
<strong>sdl2.GameControllerClose</strong>
</p>
<p>
<code>sdl2.GameControllerClose(gamecontroller:sdl2.GameController):void</code>
</p>
<p>
<strong>sdl2.GameControllerEventState</strong>
</p>
<p>
<code>sdl2.GameControllerEventState(state:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetAttached</strong>
</p>
<p>
<code>sdl2.GameControllerGetAttached(gamecontroller:sdl2.GameController) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetAxis</strong>
</p>
<p>
<code>sdl2.GameControllerGetAxis(gamecontroller:sdl2.GameController, axis:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetAxisFromString</strong>
</p>
<p>
<code>sdl2.GameControllerGetAxisFromString(pchString:string) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetBindForAxis</strong>
</p>
<p>
<code>sdl2.GameControllerGetBindForAxis(gamecontroller:sdl2.GameController, axis:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetBindForButton</strong>
</p>
<p>
<code>sdl2.GameControllerGetBindForButton(gamecontroller:sdl2.GameController, button:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetButton</strong>
</p>
<p>
<code>sdl2.GameControllerGetButton(gamecontroller:sdl2.GameController, button:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetButtonFromString</strong>
</p>
<p>
<code>sdl2.GameControllerGetButtonFromString(pchString:string) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetJoystick</strong>
</p>
<p>
<code>sdl2.GameControllerGetJoystick(gamecontroller:sdl2.GameController) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetStringForAxis</strong>
</p>
<p>
<code>sdl2.GameControllerGetStringForAxis(axis:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerGetStringForButton</strong>
</p>
<p>
<code>sdl2.GameControllerGetStringForButton(button:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerMapping</strong>
</p>
<p>
<code>sdl2.GameControllerMapping(gamecontroller:sdl2.GameController) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerMappingForGUID</strong>
</p>
<p>
<code>sdl2.GameControllerMappingForGUID(guid:sdl2.JoystickGUID) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerName</strong>
</p>
<p>
<code>sdl2.GameControllerName(gamecontroller:sdl2.GameController) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerNameForIndex</strong>
</p>
<p>
<code>sdl2.GameControllerNameForIndex(joystick_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerOpen</strong>
</p>
<p>
<code>sdl2.GameControllerOpen(joystick_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.GameControllerUpdate</strong>
</p>
<p>
<code>sdl2.GameControllerUpdate():void</code>
</p>
<p>
<strong>sdl2.IsGameController</strong>
</p>
<p>
<code>sdl2.IsGameController(joystick_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.HapticClose</strong>
</p>
<p>
<code>sdl2.HapticClose(haptic:sdl2.Haptic):void</code>
</p>
<p>
<strong>sdl2.HapticDestroyEffect</strong>
</p>
<p>
<code>sdl2.HapticDestroyEffect(haptic:sdl2.Haptic, effect:number):void</code>
</p>
<p>
<strong>sdl2.HapticEffectSupported</strong>
</p>
<p>
<code>sdl2.HapticEffectSupported(haptic:sdl2.Haptic, effect:sdl2.HapticEffect) {block?}</code>
</p>
<p>
<strong>sdl2.HapticGetEffectStatus</strong>
</p>
<p>
<code>sdl2.HapticGetEffectStatus(haptic:sdl2.Haptic, effect:number) {block?}</code>
</p>
<p>
<strong>sdl2.HapticIndex</strong>
</p>
<p>
<code>sdl2.HapticIndex(haptic:sdl2.Haptic) {block?}</code>
</p>
<p>
<strong>sdl2.HapticName</strong>
</p>
<p>
<code>sdl2.HapticName(device_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.HapticNewEffect</strong>
</p>
<p>
<code>sdl2.HapticNewEffect(haptic:sdl2.Haptic, effect:sdl2.HapticEffect) {block?}</code>
</p>
<p>
<strong>sdl2.HapticNumAxes</strong>
</p>
<p>
<code>sdl2.HapticNumAxes(haptic:sdl2.Haptic) {block?}</code>
</p>
<p>
<strong>sdl2.HapticNumEffects</strong>
</p>
<p>
<code>sdl2.HapticNumEffects(haptic:sdl2.Haptic) {block?}</code>
</p>
<p>
<strong>sdl2.HapticNumEffectsPlaying</strong>
</p>
<p>
<code>sdl2.HapticNumEffectsPlaying(haptic:sdl2.Haptic) {block?}</code>
</p>
<p>
<strong>sdl2.HapticOpen</strong>
</p>
<p>
<code>sdl2.HapticOpen(device_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.HapticOpenFromJoystick</strong>
</p>
<p>
<code>sdl2.HapticOpenFromJoystick(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.HapticOpenFromMouse</strong>
</p>
<p>
<code>sdl2.HapticOpenFromMouse() {block?}</code>
</p>
<p>
<strong>sdl2.HapticOpened</strong>
</p>
<p>
<code>sdl2.HapticOpened(device_index:number) {block?}</code>
</p>
<p>
<strong>sdl2.HapticPause</strong>
</p>
<p>
<code>sdl2.HapticPause(haptic:sdl2.Haptic):void</code>
</p>
<p>
<strong>sdl2.HapticQuery</strong>
</p>
<p>
<code>sdl2.HapticQuery(haptic:sdl2.Haptic) {block?}</code>
</p>
<p>
<strong>sdl2.HapticRumbleInit</strong>
</p>
<p>
<code>sdl2.HapticRumbleInit(haptic:sdl2.Haptic):void</code>
</p>
<p>
<strong>sdl2.HapticRumblePlay</strong>
</p>
<p>
<code>sdl2.HapticRumblePlay(haptic:sdl2.Haptic, strength:number, length:number):void</code>
</p>
<p>
<strong>sdl2.HapticRumbleStop</strong>
</p>
<p>
<code>sdl2.HapticRumbleStop(haptic:sdl2.Haptic):void</code>
</p>
<p>
<strong>sdl2.HapticRumbleSupported</strong>
</p>
<p>
<code>sdl2.HapticRumbleSupported(haptic:sdl2.Haptic) {block?}</code>
</p>
<p>
<strong>sdl2.HapticRunEffect</strong>
</p>
<p>
<code>sdl2.HapticRunEffect(haptic:sdl2.Haptic, effect:number, iterations:number):void</code>
</p>
<p>
<strong>sdl2.HapticSetAutocenter</strong>
</p>
<p>
<code>sdl2.HapticSetAutocenter(haptic:sdl2.Haptic, autocenter:number):void</code>
</p>
<p>
<strong>sdl2.HapticSetGain</strong>
</p>
<p>
<code>sdl2.HapticSetGain(haptic:sdl2.Haptic, gain:number):void</code>
</p>
<p>
<strong>sdl2.HapticStopAll</strong>
</p>
<p>
<code>sdl2.HapticStopAll(haptic:sdl2.Haptic):void</code>
</p>
<p>
<strong>sdl2.HapticStopEffect</strong>
</p>
<p>
<code>sdl2.HapticStopEffect(haptic:sdl2.Haptic, effect:number):void</code>
</p>
<p>
<strong>sdl2.HapticUnpause</strong>
</p>
<p>
<code>sdl2.HapticUnpause(haptic:sdl2.Haptic):void</code>
</p>
<p>
<strong>sdl2.HapticUpdateEffect</strong>
</p>
<p>
<code>sdl2.HapticUpdateEffect(haptic:sdl2.Haptic, effect:number, data:sdl2.HapticEffect):void</code>
</p>
<p>
<strong>sdl2.JoystickIsHaptic</strong>
</p>
<p>
<code>sdl2.JoystickIsHaptic(joystick:sdl2.Joystick) {block?}</code>
</p>
<p>
<strong>sdl2.MouseIsHaptic</strong>
</p>
<p>
<code>sdl2.MouseIsHaptic() {block?}</code>
</p>
<p>
<strong>sdl2.NumHaptics</strong>
</p>
<p>
<code>sdl2.NumHaptics() {block?}</code>
</p>
<p>
<strong>sdl2.AudioInit</strong>
</p>
<p>
<code>sdl2.AudioInit(driver_name:string):void</code>
</p>
<p>
<strong>sdl2.AudioQuit</strong>
</p>
<p>
<code>sdl2.AudioQuit():void</code>
</p>
<p>
<strong>sdl2.BuildAudioCVT</strong>
</p>
<p>
<code>sdl2.BuildAudioCVT(cvt:sdl2.AudioCVT, src_format:number, src_channels:number, src_rate:number, dst_format:number, dst_channels:number, dst_rate:number) {block?}</code>
</p>
<p>
<strong>sdl2.ClearQueuedAudio</strong>
</p>
<p>
<code>sdl2.ClearQueuedAudio(dev:number):void</code>
</p>
<p>
<strong>sdl2.CloseAudio</strong>
</p>
<p>
<code>sdl2.CloseAudio():void</code>
</p>
<p>
<strong>sdl2.CloseAudioDevice</strong>
</p>
<p>
<code>sdl2.CloseAudioDevice(dev:number):void</code>
</p>
<p>
<strong>sdl2.ConvertAudio</strong>
</p>
<p>
<code>sdl2.ConvertAudio(cvt:sdl2.AudioCVT):void</code>
</p>
<p>
<strong>sdl2.FreeWAV</strong>
</p>
<p>
<code>sdl2.FreeWAV(wav:sdl2.Wav):void</code>
</p>
<p>
<strong>sdl2.GetAudioDeviceName</strong>
</p>
<p>
<code>sdl2.GetAudioDeviceName(index:number, iscapture:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetAudioDeviceStatus</strong>
</p>
<p>
<code>sdl2.GetAudioDeviceStatus(dev:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetAudioDriver</strong>
</p>
<p>
<code>sdl2.GetAudioDriver(index:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetAudioStatus</strong>
</p>
<p>
<code>sdl2.GetAudioStatus() {block?}</code>
</p>
<p>
<strong>sdl2.GetCurrentAudioDriver</strong>
</p>
<p>
<code>sdl2.GetCurrentAudioDriver() {block?}</code>
</p>
<p>
<strong>sdl2.GetNumAudioDevices</strong>
</p>
<p>
<code>sdl2.GetNumAudioDevices(iscapture:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetNumAudioDrivers</strong>
</p>
<p>
<code>sdl2.GetNumAudioDrivers() {block?}</code>
</p>
<p>
<strong>sdl2.GetQueuedAudioSize</strong>
</p>
<p>
<code>sdl2.GetQueuedAudioSize(dev:number)</code>
</p>
<p>
<strong>sdl2.LoadWAV</strong>
</p>
<p>
<code>sdl2.LoadWAV(file:stream) {block?}</code>
</p>
<p>
<strong>sdl2.LoadWAV_RW</strong>
</p>
<p>
<code>sdl2.LoadWAV_RW():void</code>
</p>
<p>
<strong>sdl2.LockAudio</strong>
</p>
<p>
<code>sdl2.LockAudio():void</code>
</p>
<p>
<strong>sdl2.LockAudioDevice</strong>
</p>
<p>
<code>sdl2.LockAudioDevice(dev:number):void</code>
</p>
<p>
<strong>sdl2.MixAudio</strong>
</p>
<p>
<code>sdl2.MixAudio(volume:number):void</code>
</p>
<p>
<strong>sdl2.MixAudioFormat</strong>
</p>
<p>
<code>sdl2.MixAudioFormat(format:number, volume:number):void</code>
</p>
<p>
<strong>sdl2.OpenAudio</strong>
</p>
<p>
<code>sdl2.OpenAudio(desired:sdl2.AudioSpec) {block?}</code>
</p>
<p>
<strong>sdl2.OpenAudioDevice</strong>
</p>
<p>
<code>sdl2.OpenAudioDevice(device:string, iscapture:number, desired:sdl2.AudioSpec, allowed_changes:number)</code>
</p>
<p>
<strong>sdl2.PauseAudio</strong>
</p>
<p>
<code>sdl2.PauseAudio(pause_on:number):void</code>
</p>
<p>
<strong>sdl2.PauseAudioDevice</strong>
</p>
<p>
<code>sdl2.PauseAudioDevice(dev:number, pause_on:number):void</code>
</p>
<p>
<strong>sdl2.QueueAudio</strong>
</p>
<p>
<code>sdl2.QueueAudio(dev:number):void</code>
</p>
<p>
<strong>sdl2.UnlockAudio</strong>
</p>
<p>
<code>sdl2.UnlockAudio():void</code>
</p>
<p>
<strong>sdl2.UnlockAudioDevice</strong>
</p>
<p>
<code>sdl2.UnlockAudioDevice(dev:number):void</code>
</p>
<p>
<strong>sdl2.AUDIO_BITSIZE</strong>
</p>
<p>
<code>sdl2.AUDIO_BITSIZE(x:number) {block?}</code>
</p>
<p>
<strong>sdl2.AUDIO_ISFLOAT</strong>
</p>
<p>
<code>sdl2.AUDIO_ISFLOAT(x:number) {block?}</code>
</p>
<p>
<strong>sdl2.AUDIO_ISBIGENDIAN</strong>
</p>
<p>
<code>sdl2.AUDIO_ISBIGENDIAN(x:number) {block?}</code>
</p>
<p>
<strong>sdl2.AUDIO_ISSIGNED</strong>
</p>
<p>
<code>sdl2.AUDIO_ISSIGNED(x:number) {block?}</code>
</p>
<p>
<strong>sdl2.AUDIO_ISINT</strong>
</p>
<p>
<code>sdl2.AUDIO_ISINT(x:number) {block?}</code>
</p>
<p>
<strong>sdl2.AUDIO_ISLITTLEENDIAN</strong>
</p>
<p>
<code>sdl2.AUDIO_ISLITTLEENDIAN(x:number) {block?}</code>
</p>
<p>
<strong>sdl2.AUDIO_ISUNSIGNED</strong>
</p>
<p>
<code>sdl2.AUDIO_ISUNSIGNED(x:number) {block?}</code>
</p>
<p>
<strong>sdl2.CreateThread</strong>
</p>
<p>
<code>sdl2.CreateThread():void</code>
</p>
<p>
<strong>sdl2.DetachThread</strong>
</p>
<p>
<code>sdl2.DetachThread():void</code>
</p>
<p>
<strong>sdl2.GetThreadID</strong>
</p>
<p>
<code>sdl2.GetThreadID():void</code>
</p>
<p>
<strong>sdl2.GetThreadName</strong>
</p>
<p>
<code>sdl2.GetThreadName():void</code>
</p>
<p>
<strong>sdl2.GetThreadPriority</strong>
</p>
<p>
<code>sdl2.GetThreadPriority():void</code>
</p>
<p>
<strong>sdl2.TLSCreate</strong>
</p>
<p>
<code>sdl2.TLSCreate():void</code>
</p>
<p>
<strong>sdl2.TLSGet</strong>
</p>
<p>
<code>sdl2.TLSGet():void</code>
</p>
<p>
<strong>sdl2.TLSSet</strong>
</p>
<p>
<code>sdl2.TLSSet():void</code>
</p>
<p>
<strong>sdl2.ThreadID</strong>
</p>
<p>
<code>sdl2.ThreadID():void</code>
</p>
<p>
<strong>sdl2.WaitThread</strong>
</p>
<p>
<code>sdl2.WaitThread():void</code>
</p>
<p>
<strong>sdl2.CondBroadcast</strong>
</p>
<p>
<code>sdl2.CondBroadcast():void</code>
</p>
<p>
<strong>sdl2.CondSignal</strong>
</p>
<p>
<code>sdl2.CondSignal():void</code>
</p>
<p>
<strong>sdl2.CondWait</strong>
</p>
<p>
<code>sdl2.CondWait():void</code>
</p>
<p>
<strong>sdl2.CondWaitTimeout</strong>
</p>
<p>
<code>sdl2.CondWaitTimeout():void</code>
</p>
<p>
<strong>sdl2.CreateCond</strong>
</p>
<p>
<code>sdl2.CreateCond():void</code>
</p>
<p>
<strong>sdl2.CreateMutex</strong>
</p>
<p>
<code>sdl2.CreateMutex():void</code>
</p>
<p>
<strong>sdl2.CreateSemaphore</strong>
</p>
<p>
<code>sdl2.CreateSemaphore():void</code>
</p>
<p>
<strong>sdl2.DestroyCond</strong>
</p>
<p>
<code>sdl2.DestroyCond():void</code>
</p>
<p>
<strong>sdl2.DestroyMutex</strong>
</p>
<p>
<code>sdl2.DestroyMutex():void</code>
</p>
<p>
<strong>sdl2.DestroySemaphore</strong>
</p>
<p>
<code>sdl2.DestroySemaphore():void</code>
</p>
<p>
<strong>sdl2.LockMutex</strong>
</p>
<p>
<code>sdl2.LockMutex():void</code>
</p>
<p>
<strong>sdl2.SemPost</strong>
</p>
<p>
<code>sdl2.SemPost():void</code>
</p>
<p>
<strong>sdl2.SemTryWait</strong>
</p>
<p>
<code>sdl2.SemTryWait():void</code>
</p>
<p>
<strong>sdl2.SemValue</strong>
</p>
<p>
<code>sdl2.SemValue():void</code>
</p>
<p>
<strong>sdl2.SemWait</strong>
</p>
<p>
<code>sdl2.SemWait():void</code>
</p>
<p>
<strong>sdl2.SemWaitTimeout</strong>
</p>
<p>
<code>sdl2.SemWaitTimeout():void</code>
</p>
<p>
<strong>sdl2.TryLockMutex</strong>
</p>
<p>
<code>sdl2.TryLockMutex():void</code>
</p>
<p>
<strong>sdl2.UnlockMutex</strong>
</p>
<p>
<code>sdl2.UnlockMutex():void</code>
</p>
<p>
<strong>sdl2.AtomicAdd</strong>
</p>
<p>
<code>sdl2.AtomicAdd():void</code>
</p>
<p>
<strong>sdl2.AtomicCAS</strong>
</p>
<p>
<code>sdl2.AtomicCAS():void</code>
</p>
<p>
<strong>sdl2.AtomicCASPtr</strong>
</p>
<p>
<code>sdl2.AtomicCASPtr():void</code>
</p>
<p>
<strong>sdl2.AtomicDecRef</strong>
</p>
<p>
<code>sdl2.AtomicDecRef():void</code>
</p>
<p>
<strong>sdl2.AtomicGet</strong>
</p>
<p>
<code>sdl2.AtomicGet():void</code>
</p>
<p>
<strong>sdl2.AtomicGetPtr</strong>
</p>
<p>
<code>sdl2.AtomicGetPtr():void</code>
</p>
<p>
<strong>sdl2.AtomicIncRef</strong>
</p>
<p>
<code>sdl2.AtomicIncRef():void</code>
</p>
<p>
<strong>sdl2.AtomicLock</strong>
</p>
<p>
<code>sdl2.AtomicLock():void</code>
</p>
<p>
<strong>sdl2.AtomicSet</strong>
</p>
<p>
<code>sdl2.AtomicSet():void</code>
</p>
<p>
<strong>sdl2.AtomicSetPtr</strong>
</p>
<p>
<code>sdl2.AtomicSetPtr():void</code>
</p>
<p>
<strong>sdl2.AtomicTryLock</strong>
</p>
<p>
<code>sdl2.AtomicTryLock():void</code>
</p>
<p>
<strong>sdl2.AtomicUnlock</strong>
</p>
<p>
<code>sdl2.AtomicUnlock():void</code>
</p>
<p>
<strong>sdl2.CompilerBarrier</strong>
</p>
<p>
<code>sdl2.CompilerBarrier():void</code>
</p>
<p>
<strong>sdl2.AddTimer</strong>
</p>
<p>
<code>sdl2.AddTimer(interval:number)</code>
</p>
<p>
<strong>sdl2.Delay</strong>
</p>
<p>
<code>sdl2.Delay(ms:number):void</code>
</p>
<p>
<strong>sdl2.GetPerformanceCounter</strong>
</p>
<p>
<code>sdl2.GetPerformanceCounter() {block?}</code>
</p>
<p>
<strong>sdl2.GetPerformanceFrequency</strong>
</p>
<p>
<code>sdl2.GetPerformanceFrequency() {block?}</code>
</p>
<p>
<strong>sdl2.GetTicks</strong>
</p>
<p>
<code>sdl2.GetTicks() {block?}</code>
</p>
<p>
<strong>sdl2.RemoveTimer</strong>
</p>
<p>
<code>sdl2.RemoveTimer(id:number) {block?}</code>
</p>
<p>
<strong>sdl2.TICKS_PASSED</strong>
</p>
<p>
<code>sdl2.TICKS_PASSED(A:number, B:number) {block?}</code>
</p>
<p>
<strong>sdl2.GetBasePath</strong>
</p>
<p>
<code>sdl2.GetBasePath()</code>
</p>
<p>
<strong>sdl2.GetPrefPath</strong>
</p>
<p>
<code>sdl2.GetPrefPath(org:string, app:string)</code>
</p>
<p>
<strong>sdl2.AllocRW</strong>
</p>
<p>
<code>sdl2.AllocRW():void</code>
</p>
<p>
<strong>sdl2.FreeRW</strong>
</p>
<p>
<code>sdl2.FreeRW():void</code>
</p>
<p>
<strong>sdl2.RWFromConstMem</strong>
</p>
<p>
<code>sdl2.RWFromConstMem():void</code>
</p>
<p>
<strong>sdl2.RWFromFP</strong>
</p>
<p>
<code>sdl2.RWFromFP():void</code>
</p>
<p>
<strong>sdl2.RWFromFile</strong>
</p>
<p>
<code>sdl2.RWFromFile():void</code>
</p>
<p>
<strong>sdl2.RWFromMem</strong>
</p>
<p>
<code>sdl2.RWFromMem():void</code>
</p>
<p>
<strong>sdl2.RWclose</strong>
</p>
<p>
<code>sdl2.RWclose():void</code>
</p>
<p>
<strong>sdl2.RWread</strong>
</p>
<p>
<code>sdl2.RWread():void</code>
</p>
<p>
<strong>sdl2.RWseek</strong>
</p>
<p>
<code>sdl2.RWseek():void</code>
</p>
<p>
<strong>sdl2.RWtell</strong>
</p>
<p>
<code>sdl2.RWtell():void</code>
</p>
<p>
<strong>sdl2.RWwrite</strong>
</p>
<p>
<code>sdl2.RWwrite():void</code>
</p>
<p>
<strong>sdl2.ReadBE16</strong>
</p>
<p>
<code>sdl2.ReadBE16():void</code>
</p>
<p>
<strong>sdl2.ReadBE32</strong>
</p>
<p>
<code>sdl2.ReadBE32():void</code>
</p>
<p>
<strong>sdl2.ReadBE64</strong>
</p>
<p>
<code>sdl2.ReadBE64():void</code>
</p>
<p>
<strong>sdl2.ReadLE16</strong>
</p>
<p>
<code>sdl2.ReadLE16():void</code>
</p>
<p>
<strong>sdl2.ReadLE32</strong>
</p>
<p>
<code>sdl2.ReadLE32():void</code>
</p>
<p>
<strong>sdl2.ReadLE64</strong>
</p>
<p>
<code>sdl2.ReadLE64():void</code>
</p>
<p>
<strong>sdl2.WriteBE16</strong>
</p>
<p>
<code>sdl2.WriteBE16():void</code>
</p>
<p>
<strong>sdl2.WriteBE32</strong>
</p>
<p>
<code>sdl2.WriteBE32():void</code>
</p>
<p>
<strong>sdl2.WriteBE64</strong>
</p>
<p>
<code>sdl2.WriteBE64():void</code>
</p>
<p>
<strong>sdl2.WriteLE16</strong>
</p>
<p>
<code>sdl2.WriteLE16():void</code>
</p>
<p>
<strong>sdl2.WriteLE32</strong>
</p>
<p>
<code>sdl2.WriteLE32():void</code>
</p>
<p>
<strong>sdl2.WriteLE64</strong>
</p>
<p>
<code>sdl2.WriteLE64():void</code>
</p>
<p>
<strong>sdl2.GetPlatform</strong>
</p>
<p>
<code>sdl2.GetPlatform() {block?}</code>
</p>
<p>
<strong>sdl2.GetCPUCacheLineSize</strong>
</p>
<p>
<code>sdl2.GetCPUCacheLineSize() {block?}</code>
</p>
<p>
<strong>sdl2.GetCPUCount</strong>
</p>
<p>
<code>sdl2.GetCPUCount() {block?}</code>
</p>
<p>
<strong>sdl2.GetSystemRAM</strong>
</p>
<p>
<code>sdl2.GetSystemRAM() {block?}</code>
</p>
<p>
<strong>sdl2.Has3DNow</strong>
</p>
<p>
<code>sdl2.Has3DNow() {block?}</code>
</p>
<p>
<strong>sdl2.HasAVX</strong>
</p>
<p>
<code>sdl2.HasAVX() {block?}</code>
</p>
<p>
<strong>sdl2.HasAVX2</strong>
</p>
<p>
<code>sdl2.HasAVX2()</code>
</p>
<p>
<strong>sdl2.HasAltiVec</strong>
</p>
<p>
<code>sdl2.HasAltiVec() {block?}</code>
</p>
<p>
<strong>sdl2.HasMMX</strong>
</p>
<p>
<code>sdl2.HasMMX() {block?}</code>
</p>
<p>
<strong>sdl2.HasRDTSC</strong>
</p>
<p>
<code>sdl2.HasRDTSC() {block?}</code>
</p>
<p>
<strong>sdl2.HasSSE</strong>
</p>
<p>
<code>sdl2.HasSSE() {block?}</code>
</p>
<p>
<strong>sdl2.HasSSE2</strong>
</p>
<p>
<code>sdl2.HasSSE2() {block?}</code>
</p>
<p>
<strong>sdl2.HasSSE3</strong>
</p>
<p>
<code>sdl2.HasSSE3() {block?}</code>
</p>
<p>
<strong>sdl2.HasSSE41</strong>
</p>
<p>
<code>sdl2.HasSSE41() {block?}</code>
</p>
<p>
<strong>sdl2.HasSSE42</strong>
</p>
<p>
<code>sdl2.HasSSE42() {block?}</code>
</p>
<p>
<strong>sdl2.Swap16</strong>
</p>
<p>
<code>sdl2.Swap16():void</code>
</p>
<p>
<strong>sdl2.Swap32</strong>
</p>
<p>
<code>sdl2.Swap32():void</code>
</p>
<p>
<strong>sdl2.Swap64</strong>
</p>
<p>
<code>sdl2.Swap64():void</code>
</p>
<p>
<strong>sdl2.SwapBE16</strong>
</p>
<p>
<code>sdl2.SwapBE16():void</code>
</p>
<p>
<strong>sdl2.SwapBE32</strong>
</p>
<p>
<code>sdl2.SwapBE32():void</code>
</p>
<p>
<strong>sdl2.SwapBE64</strong>
</p>
<p>
<code>sdl2.SwapBE64():void</code>
</p>
<p>
<strong>sdl2.SwapFloat</strong>
</p>
<p>
<code>sdl2.SwapFloat():void</code>
</p>
<p>
<strong>sdl2.SwapFloatBE</strong>
</p>
<p>
<code>sdl2.SwapFloatBE():void</code>
</p>
<p>
<strong>sdl2.SwapFloatLE</strong>
</p>
<p>
<code>sdl2.SwapFloatLE():void</code>
</p>
<p>
<strong>sdl2.SwapLE16</strong>
</p>
<p>
<code>sdl2.SwapLE16():void</code>
</p>
<p>
<strong>sdl2.SwapLE32</strong>
</p>
<p>
<code>sdl2.SwapLE32():void</code>
</p>
<p>
<strong>sdl2.SwapLE64</strong>
</p>
<p>
<code>sdl2.SwapLE64():void</code>
</p>
<p>
<strong>sdl2.MostSignificantBitIndex32</strong>
</p>
<p>
<code>sdl2.MostSignificantBitIndex32(x:number)</code>
</p>
<p>
<strong>sdl2.GetPowerInfo</strong>
</p>
<p>
<code>sdl2.GetPowerInfo() {block?}</code>
</p>
<p>
<strong>sdl2.AndroidGetActivity</strong>
</p>
<p>
<code>sdl2.AndroidGetActivity():void</code>
</p>
<p>
<strong>sdl2.AndroidGetExternalStoragePath</strong>
</p>
<p>
<code>sdl2.AndroidGetExternalStoragePath():void</code>
</p>
<p>
<strong>sdl2.AndroidGetExternalStorageState</strong>
</p>
<p>
<code>sdl2.AndroidGetExternalStorageState():void</code>
</p>
<p>
<strong>sdl2.AndroidGetInternalStoragePath</strong>
</p>
<p>
<code>sdl2.AndroidGetInternalStoragePath():void</code>
</p>
<p>
<strong>sdl2.AndroidGetJNIEnv</strong>
</p>
<p>
<code>sdl2.AndroidGetJNIEnv():void</code>
</p>
<p>
<strong>sdl2.acos</strong>
</p>
<p>
<code>sdl2.acos(x:number) {block?}</code>
</p>
<h2><span class="caption-index-2">39.2</span><a name="caption-39-2"></a>sdl2.Window Class</h2>
<h2><span class="caption-index-2">39.3</span><a name="caption-39-3"></a>sdl2.Renderer Class</h2>
<h2><span class="caption-index-2">39.4</span><a name="caption-39-4"></a>sdl2.Texture Class</h2>
<h2><span class="caption-index-2">39.5</span><a name="caption-39-5"></a>sdl2.Event Class</h2>
<h2><span class="caption-index-2">39.6</span><a name="caption-39-6"></a>sdl2.Point Class</h2>
<h2><span class="caption-index-2">39.7</span><a name="caption-39-7"></a>sdl2.Rect Class</h2>
<h2><span class="caption-index-2">39.8</span><a name="caption-39-8"></a>sdl2.Color Class</h2>
<h2><span class="caption-index-2">39.9</span><a name="caption-39-9"></a>sdl2.Palette Class</h2>
<h2><span class="caption-index-2">39.10</span><a name="caption-39-10"></a>sdl2.PixelFormat Class</h2>
<h2><span class="caption-index-2">39.11</span><a name="caption-39-11"></a>sdl2.Keysym Class</h2>
<h2><span class="caption-index-2">39.12</span><a name="caption-39-12"></a>sdl2.Cursor Class</h2>
<h2><span class="caption-index-2">39.13</span><a name="caption-39-13"></a>sdl2.Joystick Class</h2>
<h2><span class="caption-index-2">39.14</span><a name="caption-39-14"></a>sdl2.JoystickGUID Class</h2>
<h2><span class="caption-index-2">39.15</span><a name="caption-39-15"></a>sdl2.GameController Class</h2>
<h2><span class="caption-index-2">39.16</span><a name="caption-39-16"></a>sdl2.GameControllerButtonBind Class</h2>
<h2><span class="caption-index-2">39.17</span><a name="caption-39-17"></a>sdl2.AudioCVT Class</h2>
<h2><span class="caption-index-2">39.18</span><a name="caption-39-18"></a>sdl2.AudioSpec Class</h2>
<h2><span class="caption-index-2">39.19</span><a name="caption-39-19"></a>sdl2.Wav Class</h2>
<h2><span class="caption-index-2">39.20</span><a name="caption-39-20"></a>sdl2.RendererInfo Class</h2>
<h2><span class="caption-index-2">39.21</span><a name="caption-39-21"></a>sdl2.DisplayMode Class</h2>
<h2><span class="caption-index-2">39.22</span><a name="caption-39-22"></a>sdl2.GLContext Class</h2>
<h2><span class="caption-index-2">39.23</span><a name="caption-39-23"></a>sdl2.HapticEffect Class</h2>
<h2><span class="caption-index-2">39.24</span><a name="caption-39-24"></a>sdl2.Surface Class</h2>
<h2><span class="caption-index-2">39.25</span><a name="caption-39-25"></a>sdl2.Finger Class</h2>
<h1><span class="caption-index-1">40</span><a name="caption-40"></a>sqlite3 Module</h1>
<p>
The <code>sqlite3</code> module provices measures to access SQLite3 database. To utilize it, import the <code>sqlite3</code> module using <code>import</code> function.
</p>
<h2><span class="caption-index-2">40.1</span><a name="caption-40-1"></a>Module Functions</h2>
<h2><span class="caption-index-2">40.2</span><a name="caption-40-2"></a>sqlite3.db Class</h2>
<p>
<strong>sqlite3.db</strong>
</p>
<p>
<code>sqlite3.db(filename:string) {block?}</code>
</p>
<p>
Opens an sqlite3 database file. If block is not specified, it returns a connection handle with an sqlite3 server. If block is specified, it executes the program in the block with a connection handle as a block parameter, and returns the result afterwards. The connection handle will automatically closed when the block finishes.
</p>
<p>
Block parameter format: <code>|db:sqlite3|</code>
</p>
<p>
<strong>sqlite3.db#close</strong>
</p>
<p>
<code>sqlite3.db#close()</code>
</p>
<p>
Shuts down the connection with an sqlite3 server.
</p>
<p>
<strong>sqlite3.db#exec</strong>
</p>
<p>
<code>sqlite3.db#exec(sql:string):map</code>
</p>
<p>
Executes an SQL statement and returns the result as a list.
</p>
<p>
<strong>sqlite3.db#getcolnames</strong>
</p>
<p>
<code>sqlite3.db#getcolnames(sql:string):map {block?}</code>
</p>
<p>
<strong>sqlite3.db#query</strong>
</p>
<p>
<code>sqlite3.db#query(sql:string):map {block?}</code>
</p>
<p>
Executes an SQL statement and returns the result as an iterator. You should use <code>sqlite3.db#query()</code> instead of <code>sqlite3.db#exec()</code> when it's likely that you get a large size of data as the result.
</p>
<p>
<strong>sqlite3.db#transaction</strong>
</p>
<p>
<code>sqlite3.db#transaction() {block}</code>
</p>
<p>
Executes the block within a transaction. The process is like following:
</p>
<ol>
<li>Executes a sqlit3 command 'BEGIN TRANSACTION'</li>
<li>Executes code in the block</li>
<li>Executes a sqlite3 command 'END TRANSACTION'</li>
</ol>
<h1><span class="caption-index-1">41</span><a name="caption-41"></a>sys Module</h1>
<p>
The <code>sys</code> module provides system-related information. This is a built-in module, so you can use it without being imported.
</p>
<h2><span class="caption-index-2">41.1</span><a name="caption-41-1"></a>Module Variables</h2>
<ul>
<li><code>sys.argv</code></li>
<li><code>sys.path</code></li>
<li><code>sys.maindir</code></li>
<li><code>sys.version</code></li>
<li><code>sys.banner</code></li>
<li><code>sys.build</code></li>
<li><code>sys.platform</code></li>
<li><code>sys.ps1</code></li>
<li><code>sys.ps2</code></li>
<li><code>sys.langcode</code></li>
<li><code>sys.executable</code></li>
<li><code>sys.incdir</code></li>
<li><code>sys.libdir</code></li>
<li><code>sys.datadir</code></li>
<li><code>sys.moddir</code></li>
<li><code>sys.localdir</code></li>
<li><code>sys.appdir</code></li>
<li><code>sys.cfgdir</code></li>
<li><code>sys.workdir</code></li>
</ul>
<h2><span class="caption-index-2">41.2</span><a name="caption-41-2"></a>Module Functions</h2>
<p>
<strong>sys.echo</strong>
</p>
<p>
<code>sys.echo(flag:boolean)</code>
</p>
<p>
Enables or disables echo-back functionality according to flag.
</p>
<p>
<strong>sys.exit</strong>
</p>
<p>
<code>sys.exit(status?:number)</code>
</p>
<p>
Terminates the program with a specified status number.
</p>
<p>
<strong>sys.required_version</strong>
</p>
<p>
<code>sys.required_version(major:number, minor:number, patch:number)</code>
</p>
<p>
Raises an error if the running interpreter doesn't satisfy the required version.
</p>
<h1><span class="caption-index-1">42</span><a name="caption-42"></a>tar Module</h1>
<p>
The <code>tar</code> module provides measures to read/write TAR files. To utilize it, import the <code>tar</code> module using <code>import</code> function.
</p>
<h2><span class="caption-index-2">42.1</span><a name="caption-42-1"></a>tar.reader Class</h2>
<p>
<strong>tar.reader</strong>
</p>
<p>
<code>tar.reader(stream:stream:r, compression?:symbol) {block?}</code>
</p>
<p>
<strong>tar.reader#entries</strong>
</p>
<p>
<code>tar.reader#entries() {block?}</code>
</p>
<h2><span class="caption-index-2">42.2</span><a name="caption-42-2"></a>tar.writer Class</h2>
<p>
<strong>tar.writer</strong>
</p>
<p>
<code>tar.writer(stream:stream:w, compression?:symbol) {block?}</code>
</p>
<p>
<strong>tar.writer#add</strong>
</p>
<p>
<code>tar.writer#add(stream:stream:r, filename?:string):map:reduce</code>
</p>
<p>
<strong>tar.writer#close</strong>
</p>
<p>
<code>tar.writer#close():reduce</code>
</p>
<h1><span class="caption-index-1">43</span><a name="caption-43"></a>tester Module</h1>
<h2><span class="caption-index-2">43.1</span><a name="caption-43-1"></a>Module Functions</h2>
<h1><span class="caption-index-1">44</span><a name="caption-44"></a>tiff Module</h1>
<p>
The <code>tiff</code> module provides measures to read/write image data in TIFF format. To utilize it, import the <code>tiff</code> module using <code>import</code> function.
</p>
<p>
Below is an example to read a TIFF file:
</p>
<pre><code>import(tiff)
img = image('foo.tiff')
</code></pre>
<h2><span class="caption-index-2">44.1</span><a name="caption-44-1"></a>Module Functions</h2>
<h2><span class="caption-index-2">44.2</span><a name="caption-44-2"></a>Methods Added to image Class</h2>
<p>
<strong>image#read@tiff</strong>
</p>
<p>
<code>image#read@tiff(stream:stream:r):reduce</code>
</p>
<p>
Reads a TIFF image from a stream.
</p>
<h1><span class="caption-index-1">45</span><a name="caption-45"></a>uuid Module</h1>
<p>
The <code>uuid</code> module provides functions to generate UUIDs. To utilize it, import the <code>uuid</code> module using <code>import</code> function.
</p>
<h2><span class="caption-index-2">45.1</span><a name="caption-45-1"></a>Module Functions</h2>
<p>
<strong>uuid.generate</strong>
</p>
<p>
<code>uuid.generate():[upper]</code>
</p>
<p>
Generates a Universal Unique Identifier (UUID). In default, results are output in lower-case characters. Specifying :upper would generates it in upper-case characters.
</p>
<h1><span class="caption-index-1">46</span><a name="caption-46"></a>wav Module</h1>
<h2><span class="caption-index-2">46.1</span><a name="caption-46-1"></a>Module Functions</h2>
<h2><span class="caption-index-2">46.2</span><a name="caption-46-2"></a>Extension of audio Class</h2>
<p>
<strong>audio#read@wav</strong>
</p>
<p>
<code>audio#read@wav(stream:stream:r):reduce</code>
</p>
<p>
Reads WAV audio from a stream.
</p>
<p>
<strong>audio#write@wav</strong>
</p>
<p>
<code>audio#write@wav(stream:stream:w):reduce</code>
</p>
<p>
Writes WAV audio to a stream.
</p>
<h1><span class="caption-index-1">47</span><a name="caption-47"></a>wx Module</h1>
<p>
The <code>wx</code> module provides functions and methods of wxWidgets library.
</p>
<h3><span class="caption-index-3">47.0.1</span><a name="caption-47-0-1"></a>Module Functions</h3>
<h1><span class="caption-index-1">48</span><a name="caption-48"></a>xml Module</h1>
<h2><span class="caption-index-2">48.1</span><a name="caption-48-1"></a>Module Functions</h2>
<p>
<strong>xml.comment</strong>
</p>
<p>
<code>xml.comment(comment:string)</code>
</p>
<h2><span class="caption-index-2">48.2</span><a name="caption-48-2"></a>xml.attribute Class</h2>
<h2><span class="caption-index-2">48.3</span><a name="caption-48-3"></a>xml.document Class</h2>
<p>
<strong>xml.document</strong>
</p>
<p>
<code>xml.document(stream?:stream:r) {block?}</code>
</p>
<p>
<strong>xml.document#parse</strong>
</p>
<p>
<code>xml.document#parse(str:string):void</code>
</p>
<p>
<strong>xml.document#read</strong>
</p>
<p>
<code>xml.document#read(stream:stream:r):void</code>
</p>
<p>
<strong>xml.document#textize</strong>
</p>
<p>
<code>xml.document#textize(fancy?:boolean, tabs?:number)</code>
</p>
<p>
<strong>xml.document#write</strong>
</p>
<p>
<code>xml.document#write(stream:stream:w, fancy?:boolean, tabs?:number):void</code>
</p>
<h2><span class="caption-index-2">48.4</span><a name="caption-48-4"></a>xml.element Class</h2>
<p>
<strong>xml.element</strong>
</p>
<p>
<code>xml.element(_tagname_:string, attrs%):map {block?}</code>
</p>
<p>
<strong>xml.element#addchild</strong>
</p>
<p>
<code>xml.element#addchild(value):map:void</code>
</p>
<p>
<strong>xml.element#gettext</strong>
</p>
<p>
<code>xml.element#gettext()</code>
</p>
<p>
<strong>xml.element#textize</strong>
</p>
<p>
<code>xml.element#textize(fancy?:boolean, indentLevel?:number, tabs?:number)</code>
</p>
<p>
<strong>xml.element#write</strong>
</p>
<p>
<code>xml.element#write(stream:stream:w, fancy?:boolean, indentLevel?:number, tabs?:number):void</code>
</p>
<h2><span class="caption-index-2">48.5</span><a name="caption-48-5"></a>xml.parser Class</h2>
<p>
<strong>xml.parser</strong>
</p>
<p>
<code>xml.parser() {block?}</code>
</p>
<p>
<strong>xml.parser#parse</strong>
</p>
<p>
<code>xml.parser#parse(stream:stream:r):void</code>
</p>
<h1><span class="caption-index-1">49</span><a name="caption-49"></a>xpm Module</h1>
<p>
The <code>xpm</code> module provides measures to write image data in XPM format and to parse a list of strings that is described in the format. To utilize it, import the <code>xpm</code> module using <code>import</code> function.
</p>
<p>
Below is an example to parse a list of strings described in XPM format.
</p>
<pre><code>import(xpm)
foo_xpm = @{
"13 13 2 2 0 0",
"   c #000000",
"#  c #ffffff",
"          #               ",
"          #               ",
"  # # # # # # # # # #     ",
"          #               ",
"          #     #         ",
"        # # # # # #       ",
"      #   #     #   #     ",
"    #     #   #       #   ",
"  #       #   #       #   ",
"  #       #   #       #   ",
"  #       # #         #   ",
"    # # #           #     ",
"                # #       ",
}
img = image(`rgba).xpmdata(foo_xpm)
</code></pre>
<h2><span class="caption-index-2">49.1</span><a name="caption-49-1"></a>Module Functions</h2>
<h2><span class="caption-index-2">49.2</span><a name="caption-49-2"></a>Methods Added to image Class</h2>
<p>
<strong>image#write@xpm</strong>
</p>
<p>
<code>image#write@xpm(stream:stream:w):reduce</code>
</p>
<p>
Writes a xpm image to a stream.
</p>
<p>
<strong>image#xpmdata</strong>
</p>
<p>
<code>image#xpmdata(xpm[]:string):reduce</code>
</p>
<p>
Read xpm data from a string list.
</p>
<h1><span class="caption-index-1">50</span><a name="caption-50"></a>yaml Module</h1>
<p>
The <code>yaml</code> module provides measures to read/write YAML files.
</p>
<h2><span class="caption-index-2">50.1</span><a name="caption-50-1"></a>Module Functions</h2>
<p>
<strong>yaml.compose</strong>
</p>
<p>
<code>yaml.compose(obj)</code>
</p>
<p>
<strong>yaml.parse</strong>
</p>
<p>
<code>yaml.parse(str:string)</code>
</p>
<p>
<strong>yaml.read</strong>
</p>
<p>
<code>yaml.read(stream:stream:r)</code>
</p>
<p>
<strong>yaml.write</strong>
</p>
<p>
<code>yaml.write(stream:stream:w, obj):reduce</code>
</p>
<h1><span class="caption-index-1">51</span><a name="caption-51"></a>zip Module</h1>
<p>
The <code>zip</code> module provides measures to read/write ZIP files.
</p>
<p>
Below is an example to reads entries from an archive file:
</p>
<pre><code>import(zip)
zip.reader('foo.zip') {|r|
    println(r.entries():*stat:*filename)
}
</code></pre>
<p>
Below is an exapmple to create a ZIP archive file:
</p>
<pre><code>import(zip)
zip.writer('foo.zip') {|w|
    w.add('file1.txt')
    w.add('file2.txt')
    w.add('file3.txt')
    w.close()
}		
</code></pre>
<h2><span class="caption-index-2">51.1</span><a name="caption-51-1"></a>zip.reader Class</h2>
<p>
<strong>zip.reader</strong>
</p>
<p>
<code>zip.reader(stream:stream:r) {block?}</code>
</p>
<p>
Creates <code>zip.reader</code> instance from the stream.
</p>
<p>
<strong>zip.reader#entry</strong>
</p>
<p>
<code>zip.reader#entry(name:string) {block?}</code>
</p>
<p>
Seeks entry in the zip file that matches the specified name and returns the stream instance.
</p>
<p>
<strong>zip.reader#entries</strong>
</p>
<p>
<code>zip.reader#entries() {block?}</code>
</p>
<p>
Creates an iterator that returns stream instances for each entry in the zip file.
</p>
<h2><span class="caption-index-2">51.2</span><a name="caption-51-2"></a>zip.writer Class</h2>
<p>
<strong>zip.writer</strong>
</p>
<p>
<code>zip.writer(stream:stream:w, compression?:symbol) {block?}</code>
</p>
<p>
Creates <code>zip.writer</code> instance from the stream.
</p>
<p>
Argument <code>compression</code> specifies the compression method and takes one of the following symbol.
</p>
<ul>
<li><code>`store</code></li>
<li><code>`deflate</code></li>
<li><code>`bzip2</code></li>
</ul>
<p>
<strong>zip.writer#add</strong>
</p>
<p>
<code>zip.writer#add(stream:stream:r, filename?:string, compression?:symbol):map:reduce</code>
</p>
<p>
Reads data from <code>stream</code> and adds it to the zip file. Entry name is decided by the file name associated with the stream unless it's specified by argument <code>filename</code>.
</p>
<p>
Argument <code>compression</code> specifies the compression method and takes one of the following symbol.
</p>
<ul>
<li><code>`store</code></li>
<li><code>`deflate</code></li>
<li><code>`bzip2</code></li>
</ul>
<p>
<strong>zip.writer#close</strong>
</p>
<p>
<code>zip.writer#close():void</code>
</p>
<p>
Closes the zip file after flushing cached data.
</p>
</body>
</html>
