#!/usr/bin/env gura
//-----------------------------------------------------------------------------
// argopt.gura
// This module provides a parser of argument options.
// example)
//   import(argopt)
// 	 argopt.Parser {|p|
//       p.addParam('text', 't')
//       p.addFlag('bold', 'b')
//       [cfg, argv] = p.parse(sys.argv)
//   }
//-----------------------------------------------------------------------------
Entry = struct(type:symbol, longName:string, shortName:string:nil,
							help:string:nil, helpValue:string:nil, defValue) {
	makeHelpIndex(longNameFlag:boolean, shortNameFlag:boolean) = {
		str = ''
		if (!shortNameFlag) {
			strSep = ''
		} elsif (this.shortName) {
			str += '-' + this.shortName
			strSep = ', '
		} else {
			str += '  '
			strSep = '  '
		}
		if (longNameFlag &&  this.longName) {
			str += strSep
			str += '--'
			str += this.longName
		}
		if (this.type == `flag) {
			// nothing to do
		} elsif (this.helpValue) {
			str += '='
			str += this.helpValue
		} else {
			str += '=X'
		}
		str
	}
}

Parser = class {
	__init__() = {
		this.entries = []
	} % {`en, 'markdown', R'''
	Create an `argopt.Parser` instance.
	'''}
	parse(argv[]:string) = {
		cfg = %{}
		cfg[this.entries:*longName] = this.entries:*defValue
		argvRest = []
		i = argv.offset(1)
		while (arg = i.next()) {
			[entry, value] = [nil, nil]
			if (arg.startswith('--')) {
				if (arg.len() == 2) {
					argvRest.add(arg)
					continue
				}
				fields = arg.mid(2).split('='):list
				if (fields.len() == 1) {
					longName = fields[0]
				} else {
					[longName, value] = fields
				}
				entry = this.entries.find(this.entries:*longName == longName)
				!entry && raise(error.ArgumentError, 'unknown option --' + longName)
			} elsif (arg.startswith('-')) {
				if (arg.len() == 1) {
					argvRest.add(arg)
					continue
				}
				shortName = arg.mid(1, 1)
				if (arg.len() > 2) {
					//value = arg.mid(2)
					raise(error.ArgumentError, 'unknown option -' + arg.mid(1))
				}
				entry = this.entries.find(this.entries:*shortName == shortName)
				!entry && raise(error.ArgumentError, 'unknown option -' + shortName)
				if (entry.type != `flag && !value) {
					value = i.next()
				}
			} else {
				argvRest.add(arg)
				continue
			}
			if (entry.type == `flag) {
				if (!value) {
					value = true
				} else {
					str = value.lower()
					if (str in ['t', 'true', 'on']) {
						value = true
					} elsif (str in ['f', 'false', 'off', 'nil']) {
						value = false
					} else {
						raise(error.ArgumentError, 'invalid value for flag: ' + value)
					}
				}
				cfg[entry.longName] = value
			} elsif (value) {
				cfg[entry.longName] = value
			} else {
				raise(error.ArgumentError, 'value is necessary')
			}
		}
		[cfg, argvRest]
	} % {`en, 'markdown', R'''
	Parses an argument list which is usually the value of `sys.argv` given by `sys` module.

	It returns the result in a format `[cfg, argv]` where `cfg` is a `dict` instance
	containing parameter values and `argv` a list of arguments that have not been
	parsed as options.
	'''}
	addParam(longName:string, shortName?:string, help?:string, helpValue?:string, defValue?:string) = {
		this.entries.add(Entry(`param, longName, shortName, help, helpValue, defValue))
	} % {`en, 'markdown', R'''
	
	'''}
	addFlag(longName:string, shortName?:string, help?:string) = {
		this.entries.add(Entry(`flag, longName, shortName, help, nil, false))
	} % {`en, 'markdown', R'''
	'''}
	formatHelp(longNameFlag:boolean => true, shortNameFlag:boolean => true):[linefeed] = {
		helpIndices = this.entries:*makeHelpIndex(longNameFlag, shortNameFlag)
		str = format('%-*s  %s%s', helpIndices:*len().max(), helpIndices,
					this.entries:*help, cond(__arg__.isset(`linefeed), '\n', ''))
	} % {`en, 'markdown', R'''
	'''}
}

if (__name__ == '__main__') {
	Parser {|p|
		p.addParam('text', 't')
		p.addFlag('test')
		p.addFlag('bold', 'b')
		try {
			[cfg, argv] = p.parse(sys.argv)
		} catch {|e|
			println(e.text)
			sys.exit(1)
		}
	}
	println(cfg)
}
