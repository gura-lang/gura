#!/usr/bin/env gura
import(argopt)

//-----------------------------------------------------------------------------
// BuilderBase
//-----------------------------------------------------------------------------
BuilderBase = class {
	public {
		errorFlag
		debFiles
		rpmFiles
		incDirs
		cflags
		ldflags
		libs
		dlls
		precompile
	}
	__init__(outDir:string) = {
		argopt.Parser {|p|
			p.addFlag('verbose',	'v', 'verbose mode')
			p.addFlag('debug',		'd', 'build module with debug information')
			p.addFlag('progress',	'p', 'print building progress')
			p.addFlag('here',		'h', 'output files in the current directory')
			p.addFlag('hint',		'H', 'print hint')
			p.addFlag('rebuild',	'r', 'clean output files before building')
			p.addParam('basedir',	'b', 'specify basement output directory', 'DIR', '')
			p.addParam('incdir',	'I', 'specify include directory', 'DIR')
			try {
				[this.cfg, argv] = p.parse(sys.argv)
			} catch {|e|
				sys.stderr.println(e.text)
				sys.exit(1)
			}
			this.command = if (argv.len() == 0) {
				`build
			} elsif (argv[0] == 'help') {
				this.printHelp(p)
				sys.exit(1)
			} elsif (argv[0] == 'clean') {
				`clean
			} elsif (argv[0] == 'build-install') {
				`build_install
			} elsif (argv[0] == 'build-install-root') {
				`build_install_root
			} elsif (argv[0] == 'install') {
				`install
			} elsif (argv[0] == 'install-root') {
				`install_root
			} else {
				sys.stderr.println('unknown command: ', argv[0])
				sys.exit(1)
			}
		}
		this.errorFlag = false
		this.debFiles = nil
		this.rpmFiles = nil
		this.incDirs = []
		this.cfg['incdir'] && this.incDirs.append(this.cfg['incdir'])
		this.hint = nil
		this.skipErrorFlag = false
		this.verboseFlag = this.cfg['verbose']
		this.debugFlag = this.cfg['debug']
		this.progressFlag = this.cfg['progress']
		baseDir = this.cfg['basedir']
		this.outDir = (this.cfg['here'] && baseDir) || path.join(baseDir, outDir)
	}
	build(target:string, srcs[]:string) = {
		if (this.cfg['hint']) {
			this.printHint()
			return(this)
		}
		target = target.replace('/', path.sep_file)
		if (!target.endswith('.gurd')) {
			target = target + '.gurd'
		}
		if (this.command == `clean) {
			this.doClean(target)
			return(this)
		}
		if (this.command == `install) {
			this.doInstall(target, true)
			return(this)
		}
		if (this.command == `install_root) {
			this.doInstall(target, false)
			return(this)
		}
		if (this.cfg['rebuild']) {
			this.doClean(target)
		}
		outDir = path.join(this.outDir, path.dirname(target))
		!path.exists(outDir) && fs.mkdir(outDir):tree
		(this.precompile && !this.doPrecompile()) && this.printHint() && return(this)
		srcs.each() {|src, idx|
			!this.doCompile(src, idx, srcs.len()) && \
				(this.skipErrorFlag || this.printHint() && return(this))
		}
		objs = this.makeObjName(srcs)
		!this.doLink(target, objs) && this.printHint() && return(this)
		(this.command == `build_install) && this.doInstall(target, true)
		(this.command == `build_install_root) && this.doInstall(target, false)
		this
	}
	execute(pathname:string, args*:string) = {
		this.verboseFlag && println(pathname, ' ', args.join(' '))
		buff = binary()
		os.redirect(nil, buff) {
			result = (os.exec(pathname, args*) == 0)
			!result && sys.stderr.print(os.fromnative(buff))
			result
		}
	}
	printHint() = {
		this.hint && print(this.hint)
		if (this.debFiles || this.rpmFiles) {
			println('See the following steps to install necessary packages.')
			if (this.debFiles) {
				println('- Install Debian packages:')
				println('  $ sudo apt-get install -y ', this.debFiles.join(' '))
			}
			if (this.rpmFiles) {
				println('- Install RPM packages:')
				println('  $ sudo yum install -y ', this.rpmFiles.join(' '))
			}
		}
		true
	}
	doInstall(target:string, siteFlag:boolean) = {
		if (siteFlag) {
			targetPath = path.join(sys.moddir, 'site', target)
		} else {
			targetPath = path.join(sys.moddir, target)
		}
		dirName = path.dirname(targetPath)
		!path.exists(dirName) && fs.mkdir(dirName):tree
		try {
			stream.copy(path.join(this.outDir, target), targetPath):finalize
		} catch {
			println('-- failed to install: ', targetPath)
			return
		}
		println('-- installed: ', targetPath)
	}
	printHelp(p:argopt.Parser) = {
		sys.stderr.printf('usage: %s [options] command\n', path.filename(sys.argv[0]))
		sys.stderr.println('command:')
		sys.stderr.println(' clean              clean output files')
		sys.stderr.println(' install            install built files')
		sys.stderr.println(' install-root       install built files to root directory')
		sys.stderr.println(' build-install      build and install files')
		sys.stderr.println(' build-install-root build and install files to root directory')
		sys.stderr.println('options:')
		sys.stderr.println(' ', p.formatHelp())
	}
}

//-----------------------------------------------------------------------------
// Builder
//-----------------------------------------------------------------------------
if (sys.build == `msc) {
	guraDir:local = sys.datadir
	guestDir:public = path.join(guraDir, 'gura-guest')
	Builder = class(BuilderBase) {
		__init__() = {|'msc'|
			this.cflags = [
				'/nologo', '/DGURA_MODULE_SEPARATED'
				'/EHsc', '/MD'
				'/I' + sys.incdir
				'/I' + path.join(guestDir, 'include')
			]
			this.ldflags = [
				'/INCREMENTAL:NO', '/NOLOGO', '/DLL',
				'/SUBSYSTEM:WINDOWS', '/OPT:REF', '/OPT:ICF', '/DYNAMICBASE:NO',
				'/MACHINE:X86', '/ERRORREPORT:PROMPT'
			]
			this.libs = [
				path.join(guraDir, 'lib', cond(this.debugFlag, 'libguracored-x86.lib', 'libguracore-x86.lib')),
				'kernel32.lib', 'user32.lib', 'gdi32.lib', 'winspool.lib', 'comdlg32.lib',
				'advapi32.lib', 'shell32.lib', 'ole32.lib', 'oleaut32.lib', 'uuid.lib',
				'odbc32.lib', 'odbccp32.lib', 'ws2_32.lib', 'opengl32.lib', 'glu32.lib',
				'comctl32.lib', 'winmm.lib', 'rpcrt4.lib'
			]
			this.dlls = []
			this.precompile = nil
		}
		makeObjName(src:string):map = {
			path.join(this.outDir, path.filename(src).\
				replace('.cpp', '.obj').replace('.c', '.obj').replace('.h', '.obj').replace('.rc', '.res'))
		}
		makeLibPath(lib:string):map = {
			if (lib.find('/') || lib.find('\\')) {
				libPath = lib
			} else {
				candList = path.join(os.getenv('PATH').split(';'), lib)
				candList = candList.filter(path.exists(candList)):list
				if (candList.isempty()) {
					sys.stderr.println(lib, ' has not been found in search paths\n')
					sys.exit(1)
				}
				libPath = candList.first()
			}
			libPath
		}
		doPrecompile() = {
			src = this.precompile.replace('.h', '.cpp')
			obj = this.makeObjName(src)
			cflags = []
			cflags.append('/I' + this.incDirs)
			cflags.append(this.cflags)
			this.debugFlag && cflags.append('/ZI')
			cflags.append('/Yc' + this.precompile)
			if (!path.exists(obj) || path.stat(obj).mtime < path.stat(src).mtime) {
				this.progressFlag && println('-- compiling: ', src)
				if (!this.execute('cl', cflags*, '/Fo' + obj, '/c', src)) {
					this.errorFlag = true
					return(false)
				}
			}
			true
		}
		doCompile(src:string, idx:number, cnt:number):map = {
			if (src.endswith('.rc'):icase) {
				obj = this.makeObjName(src)
				rcflags = []
				rcflags.append('/I' + this.incDirs)
				if (!path.exists(obj) || path.stat(obj).mtime < path.stat(src).mtime) {
					this.progressFlag && printf('-- compiling: %*d/%d %s\n',
										format('%d', cnt).len(), idx + 1, cnt, src)
					if (!this.execute('rc', rcflags*, '/fo' + obj, src)) {
						this.errorFlag = true
						return(false)
					}
				}
			} else {
				firstFlag = (idx == 0)
				obj = this.makeObjName(src)
				cflags = []
				cflags.append('/I' + this.incDirs)
				cflags.append(this.cflags)
				this.debugFlag && cflags.append('/ZI')
				if (firstFlag) {
					cflags.append('/DGURA_MODULE_MAIN')
				} else {
					this.precompile && cflags.append('/Yu' + this.precompile)
				}
				if (!path.exists(obj) || path.stat(obj).mtime < path.stat(src).mtime) {
					this.progressFlag && printf('-- compiling: %*d/%d %s\n',
										format('%d', cnt).len(), idx + 1, cnt, src)
					if (!this.execute('cl', cflags*, '/Fo' + obj, '/c', src)) {
						this.errorFlag = true
						return(false)
					}
				}
			}
			true
		}
		doLink(target:string, objs[]:string) = {
			target = path.join(this.outDir, target)
			ldflags = this.ldflags.clone()
			libs = this.libs.clone()
			objsEx = []
			this.precompile && objsEx.append(this.makeObjName(this.precompile))
			libs.append(this.makeLibPath(this.dlls::replace('.dll', '.lib'):icase))
			this.debugFlag && ldflags.append(['/DEBUG'])
			if (!path.exists(target) || (path.stat(target).mtime < path.stat(objs):*mtime).or()) {
				fileNameCmd = path.join(this.outDir, 'linker.cmd')
				open(fileNameCmd, 'w').println(objs)
				if (!this.execute('link', ldflags*,
							'/OUT:' + target, '@' + fileNameCmd, objsEx*, libs*)) {
					this.errorFlag = true
					return(false)
				}
				println('-- generated: ', target)
			}
			true
		}
		doClean(target:string) = {
			!path.exists(this.outDir) && return
			fileNames = path.dir(this.outDir, target, '*.obj', '*.exp', '*.lib', '*.cmd'):list
			fileNames.isempty() && return
			fileNames.each {|fileName|
				fs.remove(fileName)
				this.verboseFlag && println('-- deleted: ', fileName)
			}
			println('-- cleaned')
		}
	}
} elsif (sys.build == `gnuc) {
	Builder = class(BuilderBase) {
		__init__() = {|'gnuc'|
			this.cflags = [
				'-DGURA_MODULE_SEPARATED', '-fPIC',
				'-I' + sys.incdir
			]
			this.ldflags = ['-shared']
			this.libs = []
			this.precompile = nil
		}
		makeObjName(src:string):map = {
			path.join(this.outDir, path.filename(src). \
					  replace('.cpp', '.o').replace('.c', '.o'))
		}
		doPrecompile() = {
			src = this.precompile
			obj = src + '.gch'
			cflags = this.cflags.clone()
			cflags.append('-I' + this.incDirs)
			this.debugFlag && cflags.append('-g')
			if (!path.exists(obj) || path.stat(obj).mtime < path.stat(src).mtime) {
				this.progressFlag && println('-- compiling: ', src)
				if (!this.execute('gcc', cflags*, '-x', 'c++-header', src)) {
					this.errorFlag = true
					return(false)
				}
			}
			true
		}
		doCompile(src:string, idx:number, cnt:number):map = {
			firstFlag = (idx == 0)
			obj = this.makeObjName(src)
			cflags = this.cflags.clone()
			cflags.append('-I' + this.incDirs)
			this.debugFlag && cflags.append('-g')
			firstFlag && cflags.append('-DGURA_MODULE_MAIN')
			if (!path.exists(obj) || path.stat(obj).mtime < path.stat(src).mtime) {
				this.progressFlag && printf('-- compiling: %*d/%d %s\n',
									format('%d', cnt).len(), idx + 1, cnt, src)
				if (!this.execute('gcc', cflags*, '-o', obj, '-c', src)) {
					this.errorFlag = true
					return(false)
				}
			}
			true
		}
		doLink(target:string, objs[]:string) = {
			target = path.join(this.outDir, target)
			ldflags = this.ldflags.clone()
			libs = '-l' + this.libs.clone()
			objsEx = []
			this.precompile && objsEx.append(this.makeObjName(this.precompile))
			this.debugFlag && ldflags.append('-g')
			if (!path.exists(target) || (path.stat(target).mtime < path.stat(objs):*mtime).or()) {
				fileNameCmd = path.join(this.outDir, 'linker.cmd')
				open(fileNameCmd, 'w').println(objs)
				if (!this.execute('gcc', ldflags*,
								'-o' + target, '@' + fileNameCmd, libs*)) {
					this.errorFlag = true
					return(false)
				}
				println('-- generated: ', target)
			}
			true
		}
		doClean(target:string) = {
			if (path.exists(this.outDir)) {
				fileNames = path.dir(this.outDir, target, '*.o', '*.cmd'):list
			} else {
				fileNames = []
			}
			fileNames.append(path.dir('.', '*.gch'))
			fileNames.isempty() && return
			fileNames.each {|fileName|
				fs.remove(fileName)
				this.verboseFlag && println('-- deleted: ', fileName)
			}
			println('-- cleaned')
		}
	}
} else {
	sys.stderr.println('unsupported build system')
	sys.exit(1)
}
