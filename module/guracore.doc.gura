#!/usr/bin/env gura
import(markdown)
import(arrayt)

text@en = R'''
# Built-in Class

## argument Class

The `argument` class provides measures to access argument information that is passed to a function.
One of its purposes is to check if an attribute is specified in the function call.
It also provides a method to control a leader-trailer sequence,
a mechanism that flow controls such as `if-elsif-else` and `try-catch` utilize.

There's no constructor to realize an instance of `argument` class.
Its instance is implicitly created when a function is called,
and you can refer to it by a variable named `__arg__`.

Below is an example to use `argument` class:

    func(v0, v1, v2):[attr1,attr2] = {
        printf('arg#%d %s\n', 0.., __arg__.values)
        printf('attr1:%s attr2:%s\n', __arg__.isset(`attr1), __arg__.isset(`attr2))
    }

### Property

An `argument` instance has the following properties:

${markdown.makedoc@property(`en, argument)}


### Method

${markdown.makedoc@function(`en
argument.finalize_trailer
argument.isset
argument.quit_trailer
)}


## array Class

An instance of the `array` class stores multiple numeric values in a seamless binary sequence.
It can directly be passed to functions in C libraries without any modification
that expect arrays of `char`, `short`, `int`, `float`, `double` and so on.

There are several `array` classes that deal with different element types as shown below:

<table>
<tr><th>Class Name</th><th>Element Type</th></tr>
<tr><td><code>array@int8</code></td><td><code>Int8</code></td></tr>
<tr><td><code>array@uint8</code></td><td><code>Uint8</code></td></tr>
<tr><td><code>array@int16</code></td><td><code>Int16</code></td></tr>
<tr><td><code>array@uint16</code></td><td><code>Uint16</code></td></tr>
<tr><td><code>array@int32</code></td><td><code>Int32</code></td></tr>
<tr><td><code>array@uint32</code></td><td><code>Uint32</code></td></tr>
<tr><td><code>array@int64</code></td><td><code>Int64</code></td></tr>
<tr><td><code>array@uint64</code></td><td><code>Uint64</code></td></tr>
<tr><td><code>array@half</code></td><td><code>Half</code></td></tr>
<tr><td><code>array@float</code></td><td><code>Float</code></td></tr>
<tr><td><code>array@double</code></td><td><code>Double</code></td></tr>
<tr><td><code>array@complex</code></td><td><code>Complex</code></td></tr>
</table>

In the specification described here, the class name is is represented as `array@T`
where `T` means its element type.

Most of methods in `array` class are implemented in `arrayt` module
while the class itself is provided by the intepreter.
This is because array features cost much code size
and it would be preferable to reduce the size of the intepreter body
by separating the implementation of array methods.
So, you have to import `arrayt` module before using the `array` class in your program.

### Property

An `array` instance has the following properties:

${markdown.makedoc@property(`en, array)}


### Constructor

${markdown.makedoc@function(`en
array
array.identity
array.interval
array.ones
array.rands
array.rands@normal
array.range
array.rotation
array.rotation@x
array.rotation@y
array.rotation@z
array.scaling
array.translation
array.zeros
)}

### Method

${markdown.makedoc@function(`en
array.argmax
array.argmin
array.dot
array.dump
array.each
array.elemcast
array.fill
array.flatten
array.head
array.invert
array.iselemsame
array.issquare
array.max
array.mean
array.min
array.offset
array.paste
array.reshape
array.roundoff
array.std
array.sum
array.tail
array.transpose
array.var
)}


## audio Class

The `audio` class provides measures to work on audio data.

### Method

${markdown.makedoc@function(`en
audio.each
audio.get
audio.put
audio.sinewave
audio.store
)}


## binary Class

The `binary` class provides measures to work on binary data
that is a byte sequence without any format.

You can create a `binary` instance by calling `binary()` function.

You can also create the instance by specifying `b` prefix before a string literal.
For example, the code below creates a `binary` instance that contains a sequence
`0x41, 0x42, 0xfe, 0x03, 0x43, 0x44`.

    b'AB\xfe\x03CD'

### Property

A `binary` instance has the following properties:

${markdown.makedoc@property(`en, binary)}


### Constructor

${markdown.makedoc@function(`en
binary
)}

### Method

${markdown.makedoc@function(`en
binary.alloc
binary.dump
binary.pointer
binary.reader
binary.writer
)}


## boolean Class

The `boolean` class represents a boolean data type that is used in logical operations
including NOT, AND, OR and XOR.

The `boolean` type provides two values: `true` and `false`.
The other types of values can also be calculated in logical operations
according to the following general rule:

- The `nil` value is evaluated as `false` value.
- Other values are evaluated as `true`.

Note that the number `0` is treated as `true` in logical operations.


## codec Class

The `codec` class has features to decoding/encoding character codes stored in `string` and `binary`.
Following measures are provided:

- Decode .. Converts specific character codes stored in `binary` into UTF-8 code
  and generages `string` containing the result.
  It can also delete a CR code (`0x0d`) before a LF code (`0x0d`) at each end of line
  so that lines in the result are joined with LF code.
- Encode .. Converts UTF-8 character codes stored in `string` into specific codes
  and generates `binary` containing the result.
  It can also add a CR code (`0x0d`) before a LF code (`0x0a`) at each end of line
  so that lines in the result are joined with CR-LF sequence.

You can utilize these functions using `codec` class's methods `codec#decode()` and `codec#encode()`
as well as using `stream` class's method to read/write text by specifying `codec` instance
when creating its instance.

The actual functions for encoding and decoding are provided by sub modules under `codecs` module.
Each module provides following codecs:

- `codecs.basic` .. `us-ascii`, `utf-8`, `utf-16`, `utf-16le`, `utf-16be`
- `codecs.iso8859`.. `iso-8859-1`, `iso-8859-2`, `iso-8859-3`, `iso-8859-4`, `iso-8859-5`,
  `iso-8859-6`, `iso-8859-7`, `iso-8859-8`, `iso-8859-9`, `iso-8859-10`, `iso-8859-11`,
  `iso-8859-13`, `iso-8859-14`, `iso-8859-15`, `iso-8859-16
- `codecs.korean` .. `cp949`, `euc-kr`
- `codecs.chinese` .. `cp936`, `gb2312`, `gbk`, `cp950`, `big5`
- `codecs.japanese` .. `euc-jp`, `cp932`, `shift_jis`, `ms_kanji`, `jis`, `iso-2022-jp`

Importing other codec modules would expand available codecs.
You can call `codecs.dir()` to get a list of codec names currently available.


### Predefined Variable

<table>
<tr><th>Variable</th><th>Type</th><th>Explanation</th></tr>

<tr><td><code>codec.bom@utf8</code></td><td><code>binary</code></td>
<td>BOM for UTF-8: <code>b'\xef\xbb\xbf'</code></td></tr>

<tr><td><code>codec.bom@utf16le</code></td><td><code>binary</code></td>
<td>BOM for UTF-16 little endian: <code>b'\xff\xfe'</code></td></tr>

<tr><td><code>codec.bom@utf16be</code></td><td><code>binary</code></td>
<td>BOM for UTF-16 big endian: <code>b'\xfe\xff'</code></td></tr>

<tr><td><code>codec.bom@utf32le</code></td><td><code>binary</code></td>
<td>BOM for UTF-32 little endian: <code>b'\xff\xfe\x00\x00'</code></td></tr>

<tr><td><code>codec.bom@utf32be</code></td><td><code>binary</code></td>
<td>BOM for UTF-32 big endian: <code>b'\x00\x00\xfe\xff'</code></td></tr>

</table>

### Constructor

${markdown.makedoc@function(`en
codec
)}

### Method

${markdown.makedoc@function(`en
codec.addcr
codec.decode
codec.delcr
codec.encode
)}

### Cast Operation

A function that expects a `codec` instance in its argument can also take a value of
`string` that is recognized as a codec name.

With the above casting feature, you can call a function `f(codec:codec)`
that takes a `codec` instance in its argument as below:

- ``f(codec('utf-16'))`` .. The most explicit way.
- `f('utf-16')` .. Implicit casting: from `string` to `codec`.


## color Class

An instance of the `color` class represents a color data that consists of red, green, blue and alpha elements.

You can create a `color` instance by calling `color()` function.

There are class variables as shown below:

### Predefined Variable

<table>
<tr><th>Variable</th><th>Type</th><th>Explanation</th></tr>

<tr><td><code>color.names</code></td><td><code>string[]</code></td>
<td>A list of color names that can be passed to <code>color()</code> function.</td></tr>

<tr><td><code>color.zero</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(0, 0, 0, 0)</code></td></tr>

<tr><td><code>color.black</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(0, 0, 0, 255)</code></td></tr>

<tr><td><code>color.maroon</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(128, 0, 0, 255)</code></td></tr>

<tr><td><code>color.green</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(0, 128, 0, 255)</code></td></tr>

<tr><td><code>color.olive</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(128, 128, 0, 255)</code></td></tr>

<tr><td><code>color.navy</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(0, 0, 128, 255)</code></td></tr>

<tr><td><code>color.purple</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(128, 0, 128, 255)</code></td></tr>

<tr><td><code>color.teal</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(0, 128, 128, 255)</code></td></tr>

<tr><td><code>color.gray</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(128, 128, 128, 255)</code></td></tr>

<tr><td><code>color.silver</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(192, 192, 192, 255)</code></td></tr>

<tr><td><code>color.red</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(255, 0, 0, 255)</code></td></tr>

<tr><td><code>color.lime</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(0, 255, 0, 255)</code></td></tr>

<tr><td><code>color.yellow</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(255, 255, 0, 255)</code></td></tr>

<tr><td><code>color.blue</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(0, 0, 255, 255)</code></td></tr>

<tr><td><code>color.fuchsia</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(255, 0, 255, 255)</code></td></tr>

<tr><td><code>color.aqua</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(0, 255, 255, 255)</code></td></tr>

<tr><td><code>color.white</code></td><td><code>color</code></td>
<td>Color instance equivalent with <code>color(255, 255, 255, 255)</code></td></tr>

</table>


### Property

A `color` instance has the following properties:

${markdown.makedoc@property(`en, color)}


### Cast Operation

A function that expects a `color` instance in its argument can also take a value of
`symbol`, `string` and `list` as below:

- `symbol` .. Recognized as a color name to look up the color table.
- `string` .. Recognized as a color name to look up the color table.
- `list` .. Expected to contain elements in a format `[red, green, blue]` or
  `[red, green, blue, alpha]`.

With the above casting feature, you can call a function `f(c:color)`
that takes a `color` instance in its argument as below:

- ``f(color(`purple))`` .. The most explicit way.
- ``f(`purple)`` .. Implicit casting: from `symbol` to `color`.
- `f('purple')` .. Implicit casting: from `string` to `color`.
- `f([128, 0, 128])` .. Implicit casting: from `list` to `color`.


### Constructor

${markdown.makedoc@function(`en
color
)}

### Method

${markdown.makedoc@function(`en
color.getgray
color.html
color.list
)}


## complex Class

The `complex` class provides measures to calculate complex numbers.

You can create a `complex` instance by following ways:

- Calls `complex()` function with a real and imaginary part of numbers. e.g., `complex(2, 3)`
- Calls `complex.polar()` function with an absolute value and an argument in radius.
  e.g., `complex.polar(5, math.pi / 6)`
- Appending `j` suffix after a number literal would create an imaginal part of a complex numbrer.
  e.g., `2 + 3j`


### Constructor

${markdown.makedoc@function(`en
complex
)}

### Method

${markdown.makedoc@function(`en
complex.polar
complex.roundoff
)}


## datetime Class

The `datetime` class provides measures to handle date and time information.

You can create a `datetime` instance by calling following functions:

- `datetime()` .. Creates an intance from specified date and time.
- `datetime.now()` .. Creates an instance with its date and time fields set as the current one.
- `datetime.today()` .. Creates an instance with its date field set as the current one.
  Its time fields, `hour`, `min`, `sec` and `usec`, are set to zero.

You can calculate a `datetime` with a `timedelta` to
put its date and time values forward and backward.

### Predefined Variable

<table>
<tr><th>Variable</th><th>Type</th><th>Explanation</th></tr>

<tr><td><code>datetime.Sunday</code></td><td><code>number</code></td>
<td>Assigned with number 0 that represents Sunday.</td></tr>

<tr><td><code>datetime.Monday</code></td><td><code>number</code></td>
<td>Assigned with number 1 that represents Monday.</td></tr>

<tr><td><code>datetime.Tuesday</code></td><td><code>number</code></td>
<td>Assigned with number 2 that represents Tuesday.</td></tr>

<tr><td><code>datetime.Wednesday</code></td><td><code>number</code></td>
<td>Assigned with number 3 that represents Wednesday.</td></tr>

<tr><td><code>datetime.Thursday</code></td><td><code>number</code></td>
<td>Assigned with number 4 that represents Thursday.</td></tr>

<tr><td><code>datetime.Friday</code></td><td><code>number</code></td>
<td>Assigned with number 5 that represents Friday.</td></tr>

<tr><td><code>datetime.Saturday</code></td><td><code>number</code></td>
<td>Assigned with number 6 that represents Saturday.</td></tr>

</table>

### Property

A `datetime` instance has the following properties:

${markdown.makedoc@property(`en, datetime)}


### Constructor

${markdown.makedoc@function(`en
datetime
)}

### Method

${markdown.makedoc@function(`en
datetime.clrtzoff
datetime.format
datetime.isleap
datetime.monthdays
datetime.now
datetime.parse
datetime.settzoff
datetime.time
datetime.today
datetime.utc
datetime.weekday
)}


## declaration Class

The `declaration` class provides information about argument\'s declaration defined in a function.
You can get an iterator of `declaration` instances with the following measures
that the `function` class provides:

- A property value: `function#decls`
- An instance method: `function.getdecls()`

Below is an example to print argument names declared in a function.

    f(a, b, c, d) = {}
	println(f.decls:*name)


### Property

A `declaration` instance has the following properties:

${markdown.makedoc@property(`en, declaration)}


### Method

${markdown.makedoc@function(`en
declaration.istype
)}


## dict Class

The `dict` class provides measures to handle dictionary data
that can seek values by indexing with their associated keys.
You can specify values of `string`, `number` and `symbol` as a dictionary key.

You can create a `dict` instance by following measures:

- Calls `dict()` constructor.
- Calls a function named `%` that is an alias of `dict()` constructor.

Below are examples to create a `dict` instance:

    dict {'first' => 1, 'second' => 2, 'third' => 3}
    dict {{'first', 1}, {'second', 2}, {'third', 3}}
    dict {'first', 1, 'second', 2, 'third', 3}

    dict(['first' => 1, 'second' => 2, 'third' => 3])
    dict([['first', 1], ['second', 2], ['third', 3]])
    dict(['first', 1, 'second', 2, 'third', 3])

    %{'first' => 1, 'second' => 2, 'third' => 3}
    %{{'first', 1}, {'second', 2}, {'third', 3}}
    %{'first', 1, 'second', 2, 'third', 3}

You can specify different type of values for keys in the same dictionary.
In this case, values of different types are just recognized as different values.


#### Index Access

You can read and write element values in a `dict` with an indexer
by giving it a key value which type is `string`, `number` or `symbol`.
Below is an example:

    x = %{'first' => 1, 'second' => 2, 'third' => 3}

    println(x['second']) // prints `2`
    x['third'] = 33      // replaces `3` with `33`


### Constructor

${markdown.makedoc@function(`en
dict
)}

### Method

${markdown.makedoc@function(`en
dict.append
dict.clear
dict.erase
dict.get
dict.haskey
dict.items
dict.keys
dict.len
dict.put
dict.values
)}


## directory Class

The `directory` class handles information necessary to seek directory structure in a path.
Its instance usually works with functions in `path` module: `path.dir()` and `path.walk()`.

Though the instance can be created by `directory()` function,
you don't have to use it in many cases because a casting from `string` to `directory` instance
works implicitly in a function call.

### Constructor

${markdown.makedoc@function(`en
directory
)}


## environment Class

The `environment` class provides measures to operate variables in an environment,
which is a fundamental mechanism to store variables.

### Method

${markdown.makedoc@function(`en
environment.getprop!
environment.lookup
environment.setprop!
)}


## error Class

The `error` class provides measures to access error information.

There is no measures to create an `error` instance.
They're instantiated and passed to a block of `catch()` function
when an error occurs within a `try` block in a `try-catch` sequence.

In the following code, `e` is an instance that contains information
about an error that has occured in the `try` block.

    try {
        // any jobs
    } catch {|e:error|
        // ...
    }

### Predefined Variable

<table>
<tr><th>Variable</th><th>Explanation</th></tr>

<tr><td><code>error.ArgumentError</code></td>
<td>Argument error.</td></tr>

<tr><td><code>error.ArithmeticError</code></td>
<td>Arithmetic error.</td></tr>

<tr><td><code>error.AttributeError</code></td>
<td>Invalid attribute is specified.</td></tr>

<tr><td><code>error.CodecError</code></td>
<td>An error that is related to codec process.</td></tr>

<tr><td><code>error.CommandError</code></td>
<td>An error that could happen in command line.</td></tr>

<tr><td><code>error.DeclarationError</code></td>
<td>An error in a function\'s declarations.</td></tr>

<tr><td><code>error.FormatError</code></td>
<td></td></tr>

<tr><td><code>error.IOError</code></td>
<td></td></tr>

<tr><td><code>error.ImportError</code></td>
<td></td></tr>

<tr><td><code>error.IndexError</code></td>
<td></td></tr>

<tr><td><code>error.IteratorError</code></td>
<td></td></tr>

<tr><td><code>error.KeyError</code></td>
<td></td></tr>

<tr><td><code>error.MemberAccessError</code></td>
<td></td></tr>

<tr><td><code>error.MemoryError</code></td>
<td></td></tr>

<tr><td><code>error.NameError</code></td>
<td></td></tr>

<tr><td><code>error.NotImplementedError</code></td>
<td>An error that could occur when a called function has no implemented body but an entry.</td></tr>

<tr><td><code>error.OutOfRange</code></td>
<td>Index number is out of range.</td></tr>

<tr><td><code>error.ResourceError</code></td>
<td>Resource error.</td></tr>

<tr><td><code>error.RuntimeError</code></td>
<td>Runtime error.</td></tr>

<tr><td><code>error.SyntaxError</code></td>
<td>Syntax error.</td></tr>

<tr><td><code>error.SystemError</code></td>
<td>System error.</td></tr>

<tr><td><code>error.TypeError</code></td>
<td>Type error.</td></tr>

<tr><td><code>error.ValueError</code></td>
<td>Invalid value is specified.</td></tr>

<tr><td><code>error.ZeroDivisionError</code></td>
<td>Zero-division occured in division or modulo operations.</td></tr>

</table>

### Property

An `error` instance has the following properties:

${markdown.makedoc@property(`en, error)}


## expr Class

The `expr` class provides inromation about the language\'s syntax expression.

### Property

An `expr` instance has the following properties:

${markdown.makedoc@property(`en, expr)}


### Constructor

${markdown.makedoc@function(`en
expr
)}

### Method

${markdown.makedoc@function(`en
expr.eval
expr.parse
expr.textize
expr.tofunction
expr.unquote
expr.write
// type chekers - Unary and descendants
expr.isunary
expr.isunaryop
expr.isquote
// type chekers - Binary and descendants
expr.isbinary
expr.isbinaryop
expr.isassign
expr.ismember
// type chekers - Collector and descendants
expr.iscollector
expr.isroot
expr.isblock
expr.islister
expr.isiterer
// type chekers - Compound and descendants
expr.iscompound
expr.isindexer
expr.iscaller
// type chekers - others
expr.isvalue
expr.isidentifier
expr.issuffixed
)}


## formatter Class

The `formatter` class provides information about a format specifier.

The function `printf()` has the following declaration:

    printf('name: %s, age: %d\n', name, age)

The first argument is a string containing format specifiers like `%s` and `%d`
that determine the manner on how the correspoding values `name` and `age` should be formatted.
In the formatting mechanism, when the specifiers `%s` and `%d` appear,
it would call methods `name.__format_s__()` and `age.__format_s__()` respectively
which are format handlers responsible of formatting these values.
In general, a format handler has a format like `__format_X__(fmt:formatter)`
where `X` is the symbol of the specifier and `fmt` is a `formatter` instance that carries
information about the associated specifier such as minimum width and a padding character.
The handler must return a `string` as its result.

The table below summarizes associations between specifiers
and the method name of their format handlers:

<table>
<tr><th>Specifier</th><th>Method Name</th></tr>
<tr><td><code>%d</code></td><td><code>__format_d__</code></td></tr>
<tr><td><code>%u</code></td><td><code>__format_u__</code></td></tr>
<tr><td><code>%b</code></td><td><code>__format_b__</code></td></tr>
<tr><td><code>%o</code></td><td><code>__format_o__</code></td></tr>
<tr><td><code>%x</code></td><td><code>__format_x__</code></td></tr>
<tr><td><code>%e</code></td><td><code>__format_e__</code></td></tr>
<tr><td><code>%f</code></td><td><code>__format_f__</code></td></tr>
<tr><td><code>%g</code></td><td><code>__format_g__</code></td></tr>
<tr><td><code>%s</code></td><td><code>__format_s__</code></td></tr>
<tr><td><code>%c</code></td><td><code>__format_c__</code></td></tr>
</table>

This feature is supposed to be used when you want your original class\'s instance
properly formatted in `printf`. Below is an example to implement a format handler
for the specifier `%d`:

    A = class {

        // any implementations

        __format_d__(fmt:format) = {
            // returns a string for %d specifier.
        }
    }

    a = A()
    printf('%d', a) // a.__format_d__() is called


### Method

${markdown.makedoc@function(`en
formatter.getminwidth
formatter.getpadding
formatter.getplusmode
formatter.getprecision
formatter.isleftalign
formatter.issharp
formatter.isuppercase
)}


## function Class

The `function` class provides measure to inspect information about the instance.

All the functions are instances of `function` class,
so an implementation of a function means a realization of a `function` instance.
You can also create the instance using `function()` constructor.
The following two codes have the same result:

    f(a:number, b:number, c:number) = {
        (a + b + c) / 3
    }

    f = function(a:number, b:number, c:number) {
        (a + b + c) / 3
    }

Using `function()`, you can use variables prefixed by a dollar character
so that they are automatically added to the argument list.
In such a case, the variables are added to the argument list in the same order as
they appear in the function body.
The code below creates a function with a declaration `f($a, $b, $c)`.

    f = function {
        ($a + $b + $c) / 3
    }

You can use `&` as an alias of `function()` as shown below:

    f = &{
        ($a + $b + $c) / 3
    }


### Property

A `function` instance has the following properties:

${markdown.makedoc@property(`en, function)}


### Operator

You can print a function\'s help from the interactive prompt using the unary operator "`~`".
Below is an example to print the help of `printf()` function:

    >>> ~printf

### Constructor

${markdown.makedoc@function(`en
function
)}

### Method

${markdown.makedoc@function(`en
function.getdecls
function.getexpr
function.getformat
function.getfullname
function.getname
function.getsymbol
function.mathdiff
)}


## help Class

The `help` class provides measures to access help information
associated with a `function` instance.

You can get a `help` instance from a `function` instance or a `class`
by calling `help@function()` or `help@class()` respectively.

### Property

A `help` instance has the following properties:

${markdown.makedoc@property(`en, help)}


### Method

${markdown.makedoc@function(`en
help.text@iterator
help.text@block
help.presenter
)}


## image Class

The `image` class provides following measures to handle graphic image data:

- Reads image data from a file.
- Writes image data to a file.
- Apply some modifications on image data including rotation, resize and color conversion.

Acceptable image data formats can be extended by importing modules.
Below is a table to show image formats and name of modules that handle them.
The string listed in "imagetype" column shows a name that is used by functions
`image()`, `image#read()` and `image#write()` to explicitly specify the image data format
in a process of reading and writing files.

<table>
<tr><th>Image Format</th><th>Module Name</th><th>imagetype</th></tr>
<tr><td>BMP</td><td><code>bmp</code></td><td><code>'bmp'</code></td></tr>
<tr><td>GIF</td><td><code>gif</code></td><td><code>'gif'</code></td></tr>
<tr><td>JPEG</td><td><code>jpeg</code></td><td><code>'jpeg'</code></td></tr>
<tr><td>Microsoft Icon</td><td><code>msico</code></td><td><code>'msico'</code></td></tr>
<tr><td>PNG</td><td><code>png</code></td><td><code>'png'</code></td></tr>
<tr><td>PPM</td><td><code>ppm</code></td><td><code>'ppm'</code></td></tr>
<tr><td>TIFF</td><td><code>tiff</code></td><td><code>'tiff'</code></td></tr>
</table>


### Property

An `image` instance has the following properties:

${markdown.makedoc@property(`en, image)}


### Constructor

${markdown.makedoc@function(`en
image
)}

### Method

${markdown.makedoc@function(`en
image.allocbuff
image.blur
image.clear
image.crop
image.delpalette
image.extract
image.fill
image.fillrect
image.flip
image.getpixel
image.grayscale
image.mapcolorlevel
image.paste
image.putpixel
image.size
image.store
image.read
image.reducecolor
image.replacecolor
image.resize
image.rotate
image.scan
image.setalpha
image.thumbnail
image.write
)}


## list/iterator Class

The `list` class provides measures to handle a list structure,
which stores values on memory that can be accessed by indexer.

The `iterator` class provides measures to operate an iterator,
which iterates values that come from containers and streams.


### List-specific Features

#### Creating List

There are several ways to create a list.

    [3, 1, 4, 1, 5, 9]
    @{3, 1, 4, 1, 5, 9}


#### Index Access

You can read and write element values in a list with an indexer
by giving it an index number starting from zero.
Below is an example:

    x = [`A, `B, `C, `D, `E, `F]

    println(x[2]) // prints `C
    x[4] = `e     // replaces `E with `e


#### Function to Create list Instance

${markdown.makedoc@function(`en
list
xlist
set
xset
)}


#### Method Specific to list Class

${markdown.makedoc@function(`en
list.add
list.append
list.clear
list.combination
list.erase
list.first
list.get
list.insert
list.isempty
list.last
list.permutation
list.put
list.shift
list.shuffle
list.zip
)}


### Iterator-specific Features

#### Function to Create iterator Instance

${markdown.makedoc@function(`en
iterator
)}


#### Method Specific to iterator Class

${markdown.makedoc@function(`en
iterator.delay
iterator.finite
iterator.infinite
iterator.isinfinite
iterator.next
iterator.repeater
)}


### Method Common to Both list and iterator Classes

${markdown.makedoc@function$(`en, 'iterator#', 'iterable#'
iterator.after
iterator.align
iterator.and
iterator.argmax
iterator.argmin
iterator.before
iterator.contains
iterator.count
iterator.cycle
iterator.each
iterator.filter
iterator.find
iterator.flatten
iterator.fold
iterator.format
iterator.head
iterator.join
iterator.joinb
iterator.len
iterator.map
iterator.max
iterator.mean
iterator.min
iterator.nilto
iterator.offset
iterator.or
iterator.pack
iterator.pingpong
iterator.print
iterator.printf
iterator.println
iterator.rank
iterator.reduce
iterator.replace
iterator.reverse
iterator.roundoff
iterator.runlength
iterator.since
iterator.skip
iterator.skipnil
iterator.sort
iterator.std
iterator.sum
iterator.tail
iterator.until
iterator.var
iterator.while
)}


## memory Class

An instance of the `memory` class represents a memory that is stored in `array` instances.

### Property

A `memory` instance has the following properties:

${markdown.makedoc@property(`en, memory)}


### Constructor

${markdown.makedoc@function(`en
memory
)}

### Method

${markdown.makedoc@function(`en
memory.array@int8
memory.array@uint8
memory.array@int16
memory.array@uint16
memory.array@int32
memory.array@uint32
memory.array@int64
memory.array@uint64
memory.array@float
memory.array@double
memory.dump
memory.pointer
)}


## nil Class

The `nil` class is the class of `nil` value that is usually used as an invalid value.
In a logical operation, the `nil` value is recognized as `false`.


## number Class

The `number` class is a type of number values.
A number literal would create a `number` instance.

### Method

${markdown.makedoc@function(`en
number.roundoff
)}


## operator Class

The `operator` class provides measures to assign operators with a user-defined procedure.


### Property

An `operator` instance has the following properties:

${markdown.makedoc@property(`en, operator)}


### Constructor

${markdown.makedoc@function(`en
operator
)}


### Method

${markdown.makedoc@function(`en
operator.assign
operator.entries
)}


## palette Class

The `palette` instance has a set of `color` instance.


### Constructor

${markdown.makedoc@function(`en
palette
)}

### Method

${markdown.makedoc@function(`en
palette.each
palette.nearest
palette.shrink
palette.updateby
)}


## pointer Class

The `pointer` class provides measures to read and write content in a `binary` and `memory` instance.


### Property

A `pointer` instance has the following properties:

${markdown.makedoc@property(`en, pointer)}


### Constructor

${markdown.makedoc@function(`en
pointer
)}


### Method

${markdown.makedoc@function(`en
pointer.copyfrom
pointer.copyto
pointer.decode
pointer.dump
pointer.encodeuri
pointer.each@int8
pointer.each@uint8
pointer.each@int16
pointer.each@uint16
pointer.each@int32
pointer.each@uint32
pointer.each@int64
pointer.each@uint64
pointer.each@float
pointer.each@double
pointer.forward
pointer.get@int8
pointer.get@uint8
pointer.get@int16
pointer.get@uint16
pointer.get@int32
pointer.get@uint32
pointer.get@int64
pointer.get@uint64
pointer.get@float
pointer.get@double
pointer.head
pointer.hex
pointer.pack
pointer.put@int8
pointer.put@uint8
pointer.put@int16
pointer.put@uint16
pointer.put@int32
pointer.put@uint32
pointer.put@int64
pointer.put@uint64
pointer.put@float
pointer.put@double
pointer.reader
pointer.seek
pointer.tail
pointer.unpack
pointer.unpacks
pointer.writer
)}


### Cast Operation

A function that expects a `pointer` instance in its argument can also take a value of
`binary` and `memory`.

With the above casting feature, you can call a function `f(p:pointer)`
that takes a `pointer` instance in its argument as below:

- `b = b'\x01\x23\x45\x67\x89\xab', f(b)`
- `m = memory(32), f(m)`


## rational Class

The `rational` class provides measures to handle rational numbers.

You can create a `rational` instance with following ways:

- Use `rational()` function.
- Append `r` suffix after a number literal.

Below are examples to realize a common fraction two-thirds:

    rational(2, 3)
    2r / 3
    2 / 3r

### Constructor

${markdown.makedoc@function(`en
rational
)}

### Method

${markdown.makedoc@function(`en
rational.reduce
)}


## semaphore Class

### Constructor

${markdown.makedoc@function(`en
semaphore
)}

### Method

${markdown.makedoc@function(`en
semaphore.release
semaphore.session
semaphore.wait
)}


## stream Class

The `stream` class provides methods to read and write data through a stream,
an abstract structure to handle a byte sequence.
It also provides information of the stream such as the pathname and the creation date and time.

You can specify a proper `codec` when creating the `stream` instance,
which is used to decode/encode character codes that appear in the stream.
Features of `codec` would affect on functions and methods that handle text data like follows:

- Decode
  - readlines()
  - stream#readchar()
  - stream#readline()
  - stream#readlines()
  - stream#readtext()

- Encode
  - operator `<<`
  - stream#print()
  - stream#printf()
  - stream#println()


### Property

A `stream` instance has the following properties:

${markdown.makedoc@property(`en, stream)}


### Operator

You can use the operator "`<<`" to output a content of a value to a `stream`.
It comes like "`stream << obj`" where `obj` is converted to a string before output to the stream.

    sys.stdout << 'Hello World.'

Since the operator returns the `stream` instance specified on the left as its result,
you can chain multiple operations as below:

    sys.stdout << 'First' << 'Second'


### Cast Operation

A function that expects a `stream` instance in its argument can also take a value of
`string` and `binary` as below:

- `string` .. Recognized the `string` as a path name from which `stream` instance is created.
- `binary` .. Creates a `stream` instance that reads or modifies the content of the specified `binary` data.
  If the `binary` data is a constant one, which might be created from a binary literal
  such as `b'\x00\x12\x34\x56'`, the stream is created with read-only attribute.

Using the above casting feature, you can call a function `f(stream:stream)`
that takes a `stream` instance in its argument as below:

- `f(stream('foo.txt'))` .. The most explicit way.
- `f('foo.txt')` .. Implicit casting from `string` to `stream`.
- `f(b'\x00\x12\x34\x56')` .. Implicit casting from `binary` to `stream` that reads the content.


### Constructor

${markdown.makedoc@function(`en
stream
)}

You can also call `open()` function that is just an alias of `stream()`
to create a `stream` instance.

### Utility Function

${markdown.makedoc@function(`en
readlines
)}

### Method

${markdown.makedoc@function(`en
stream.addcr
stream.close
stream.compare
stream.copy
stream.copyfrom
stream.copyto
stream.delcr
stream.deserialize
stream.flush
stream.peek
//stream.prefetch
stream.print
stream.printf
stream.println
stream.read
stream.readchar
stream.readline
stream.readlines
stream.readtext
stream.seek
stream.serialize
stream.setcodec
stream.tell
stream.write
)}


## string Class

The `string` class provides measures to operate on strings.

You can create a `string` instance by embracing a sequence of characters
with a pair of single- or double-quotes.

    'Hello World'

    "Hello World"

If you need to declare a string that contains multiple lines,
embrace it with a pair of sequences of three single- or double-quotes.
''' R"""

    '''first line
    second line
    third line
    '''
""" R'''
### Suffix Management

When an string literal is suffixed by a character `$`,
a handler registered by `string.translate()` function that is supposed to translate
the string into other natural languages would be evaluated.

### Method

${markdown.makedoc@function(`en
string.align
string.binary
string.capitalize
string.chop
string.decodeuri
string.each
string.eachline
string.embed
string.encode
string.encodeuri
string.endswith
string.escapehtml
string.find
string.fold
string.foldw
string.format
string.isempty
string.left
string.len
string.lower
string.mid
string.print
string.println
string.reader
string.replace
string.replaces
string.right
string.split
string.startswith
string.strip
string.template
string.tosymbol
string.translator
string.unescapehtml
string.upper
string.width
string.zentohan
)}


## suffixmgr Class

The `suffixmgr` class provides measures to access suffix managers
that are responsible to handle suffix symbols appended to number or string literals.

Below is an example to register a suffix `X` that converts a string into upper case
after being appended to a string literal:

    suffixmgr(`string).assign(`X) {|body| body.upper()}

You can use that suffix like below:

    'hello world'X

### Constructor

${markdown.makedoc@function(`en
suffixmgr
)}

### Method

${markdown.makedoc@function(`en
suffixmgr.assign
)}


## symbol Class

### Method

${markdown.makedoc@function(`en
symbol.eval
)}


## template Class

### Cast Operation

A function that expects a `template` instance in its argument can also take a value of
`stream` as below:

- `stream` .. Creates a `template` instance by parsing the content of the stream.

As a `stream` is capable of being casted from `string` and `binary`,
such values can also be passed to the argument that expects `template`.

Using the above casting feature, you can call a function `f(tmpl:template)`
that takes a `template` instance in its argument as below:

- `f(template(stream('foo.txt')))` .. The most explicit way.
- `f(stream('foo.txt'))` .. Implicit casting: from `stream` to `template`.
- `f(template('foo.txt'))` .. Implicit casting: from `string` to `stream`.
- `f('foo.txt')` .. Implicit casting: from `string` to `stream`, then from `stream` to `template`.

### Constructor

${markdown.makedoc@function(`en
template
)}

### Method

${markdown.makedoc@function(`en
template.parse
template.read
template.render
)}

### Method Called by Template Directive

${markdown.makedoc@function(`en
template.block
template.call
template.define
template.embed
template.extends
template.super
)}


## timedelta Class

The `timedelta` instance provides a time delta information that works with `datetime` instance.
You can shift time information of `datetime` by applying addition or subtraction
of `timedelta` to it.

### Property

A `timedelta` instance has the following properties:

${markdown.makedoc@property(`en, timedelta)}


### Constructor

${markdown.makedoc@function(`en
timedelta
)}


## uri Class

The `uri` instance analyzes a URI string and returns each part in it
such as the scheme and path.
A generic URI has the following format:

    scheme:[//[user:password@]host:port]][/]path[?query][#fragment]


### Property

A `uri` instance has the following properties:

${markdown.makedoc@property(`en, uri)}


### Constructor

${markdown.makedoc@function(`en
uri
)}

### Method

${markdown.makedoc@function(`en
uri.getfragment
uri.getpath
uri.getquery
uri.parsequery
)}

### Cast Operation

A function that expects a `uri` instance in its argument can also take a value of
`string` that is recognized as a URI string.

With the above casting feature, you can call a function `f(uri:uri)`
that takes a `uri` instance in its argument as below:

- ``f(uri('http://example.com'))`` .. The most explicit way.
- `f('http://example.com')` .. Implicit casting: from `string` to `uri`.


## vertex Class

The `vertex` class provides vertex information that consists of x, y, z and w values.

### Property

An `vertex` instance has the following properties:

${markdown.makedoc@property(`en, vertex)}


### Constructor

${markdown.makedoc@function(`en
vertex
)}

### Method

${markdown.makedoc@function(`en
vertex.cross
vertex.dot
vertex.list
vertex.normal
vertex.rotate@x
vertex.rotate@y
vertex.rotate@z
vertex.translate
)}
'''.embed()

markdown.makedoc@module(locals(), %{`en => text@en})
