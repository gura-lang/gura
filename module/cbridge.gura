#!/usr/bin/env gura
//==============================================================================
// cbridge.gura
// Helper to create a binary Gura module.
//==============================================================================

//------------------------------------------------------------------------------
// template texts
//------------------------------------------------------------------------------
tmplImplementation = R'''
// ${fi.moduleName}.${fi.funcNameGura}
Gura_DeclareFunctionAlias(__${fi.funcNameGura}, "${fi.funcNameGura}")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_${fi.resultMode}, ${('FLAG_' + fi.flags).join(' | ')});
	${if (fi.blockDeclared)}
	DeclareBlock(OCCUR_${fi.blockDeclared});
	${end}
	${for (arg in fi.args)}
	DeclareArg(env, "${arg.name}", VTYPE_${arg.valType}, OCCUR_${
							arg.occurPattern}, ${('FLAG_' + arg.flags).join(' | ')});
	${end}
	${fi.helps.each {|help|}}
	${help.Render()}
	${end}
}

Gura_ImplementFunction(__${fi.funcNameGura})
{
	${if (!fi.validFlag)}
#if 0
	${end}
	${for (arg in fi.args) {|idx|}}
	${arg.tmplGetter.render()}
	${end}
${fi.tmplBody.render()}
	${if (!fi.validFlag)}
#endif
	env.SetError(ERR_NotImplementedError, "not implemented function ${fi.funcNameGura}");
	return Value::Nil;
	${end}
}
'''.template()

tmplAssignment = R'''
Gura_AssignFunction(__${fi.funcNameGura});
'''.template()

//------------------------------------------------------------------------------
// ArgInfo
//------------------------------------------------------------------------------
ArgInfo = struct(name:string, valType:string:nil, occurPattern:string:nil,
				 tmplGetter:template, flags[]:string)

//------------------------------------------------------------------------------
// TypeConv
//------------------------------------------------------------------------------
TypeConv = struct(
		valType:string:nil, occurPattern:string:nil, flags[]:string,
		tmplGetter:string:nil, tmplGetterOpt:string:nil,
		tmplBody:string:nil, voidFlag?:boolean)

//------------------------------------------------------------------------------
// Help
//------------------------------------------------------------------------------
Help = struct(lang:symbol, format:string, help:string) {
	Render() = {
		str = 'AddHelp(\n'
		str += format('\tGura_Symbol(%s), Help::FMT_%s,\n', this.lang, this.format)
		text = this.help.replace('"', '\\"')
		if (text.isempty()) {
			str += '\t""'
		} else {
			str += ('\t"' + text.eachline():chop + '\\n"').join('\n')
		}
		str += ');\n'
	} % {`en, 'markdown',
		R'''
		Render C code that adds help information.
		'''
	}
}

//------------------------------------------------------------------------------
// FuncInfo
//------------------------------------------------------------------------------
FuncInfo = class {
	public {
		moduleName, funcNameC, funcNameGura, args, tmplBody, resultMode, flags, helps
	}
	__init__(moduleName:string, decl:expr, funcNameTranslator:function:nil):map = {
		if (!decl.isassign()) {
			this.PrintError(decl, 'must be an assignment expression')
			sys.exit(1)
		}
		if (!decl.left.iscaller()) {
			this.PrintError(decl, "assinged target must be a caller")
			sys.exit(1)
		}
		caller = decl.left
		this.tmplBody = nil
		this.validFlag = true
		this.helps = []
		exprAssigned = decl.right
		while (exprAssigned.isbinaryop() && exprAssigned.operator.symbol == `% && \
												exprAssigned.right.isblock()) {
			args = exprAssigned.right.children::eval()
			if (!(args.len() == 3 && args[0].istype(`symbol) && \
						  args[1].istype(`string) && args[2].istype(`string))) {
				this.PrintError(decl, 'invalid format for help')
				sys.exit(1)
			}
			this.helps.add(Help(args*))
			exprAssigned = exprAssigned.left
		}
		valueAssigned = exprAssigned.eval()
		if (isstring(valueAssigned)) {
			this.tmplBody = valueAssigned.template()
		} elsif (valueAssigned == `auto) {
			// nothing to do
		} elsif (valueAssigned == `unsupport) {
			this.validFlag = false
		} else {
			this.PrintError(decl, 'invalid value for assignment')
			sys.exit(1)
		}
		this.blockDeclared = nil
		if (caller.block) {
			children = [caller.block.children]
			if (children.len() != 1) {
				this.PrintError(decl, 'block must contain a single expression')
				sys.exit(1)
			}
			child = children[0]
			if (child.isidentifier()) {
				this.blockDeclared = 'Once'
			} elsif (child.isunaryop()) {
				if (child.operator.symbol == `?) {
					this.blockDeclared = 'ZeroOrOnce'
				} else {
					this.PrintError(decl, 'suffixed operator must be ?')
					sys.exit(1)
				}
			} else {
				this.PrintError(decl, 'syntax error')
				sys.exit(1)
			}
		}
		this.moduleName = moduleName
		this.funcNameC:string = caller.car.symbol
		if (funcNameTranslator) {
			this.funcNameGura = funcNameTranslator(this.funcNameC)
		} else {
			this.funcNameGura = this.funcNameC
		}
		if (caller.attrs.find(`void)) {
			rtnTypeRaw = 'void'
		} else {
			rtnTypeRaw = caller.attrfront.join('.')
		}
		//if (rtnTypeRaw.isempty() && !this.validFlag) {
		//	rtnTypeRaw = 'void'
		//}
		if (caller.attrs.find(`const)) {
			rtnTypeRaw += ':const'
		}
		typeConv = typeConvDict.get(rtnTypeRaw)
		if (typeConv && typeConv.tmplBody) {
			// nothing to do
		} elsif (!this.validFlag) {
			typeConv = typeConvDict.get('void')
		} else {
			this.PrintError(decl,
							'failed to convert return information "%s"', rtnTypeRaw)
			sys.exit(1)
		}
		if (!this.tmplBody) {
			this.tmplBody = ('\t' + typeConv.tmplBody.eachline()).join().template()
		}
		this.resultMode = 'Normal'
		this.flags = []
		if (typeConv.voidFlag) {
			this.resultMode = 'Void'
		}
		caller.attrs.find(`map) && this.flags.append('Map')
		this.flags.isempty() && this.flags.append('None')
		this.args = caller.cdr.each():list {|arg|
			occurPattern = nil
			optionalFlag = false
			if (arg.isunaryop()) {
				if (arg.operator.symbol == `?) {
					occurPattern = 'ZeroOrOnce'
					optionalFlag = true
				} else {
					this.PrintError(decl, 'invalid occurance specifier')
					sys.exit(1)
				}
				arg = arg.child
			}
			if (arg.isindexer()) {
				identifier = arg.car
				argTypeRaw = identifier.attrfront.join('.') + '[]'
			} else {
				identifier = arg
				argTypeRaw = identifier.attrfront.join('.')
			}
			if (identifier.attrs.find(`const)) {
				argTypeRaw += ':const'
			}
			typeConv = typeConvDict.get(argTypeRaw)
			if (!typeConv) {
				this.PrintError(decl, 'failed to convert argument information %s', argTypeRaw)
				sys.exit(1)
			}
			flags = []
			flags.append(typeConv.flags)
			if (identifier.attrs.find(`nil)) {
				flags.append('Nil')
				optionalFlag = true
			}
			flags.isempty() && flags.append('None')
			tmplGetter = cond(optionalFlag, typeConv.tmplGetterOpt, typeConv.tmplGetter)
			if (!tmplGetter) {
				this.PrintError(decl, 'failed to convert argument information %s', argTypeRaw)
				sys.exit(1)
			}
			name = identifier.symbol
			ArgInfo(name, typeConv.valType, occurPattern || typeConv.occurPattern,
					tmplGetter.template(), flags)
		}
	}
	MakeCaller() = ('%s(%s)' % [this.funcNameC, this.args:*name.join(', ')])
	GetFullFuncNameGura() = this.moduleName + '.' + this.funcNameGura
	PrintError(decl:expr, fmt:string, args*) = {
		sys.stderr.printf('%s:%d: %s\n',
				  path.filename(decl.source), decl.lineno, format(fmt, args*))
	}
	RenderImplementation() = {
		fi = this
		tmplImplementation.render()
	} % {`en, 'markdown',
		R'''
		Renders C code that implements a Gura function.
		'''
	}
	RenderAssignment() = {
		fi = this
		tmplAssignment.render()
	} % {`en, 'markdown',
		R'''
		Renders C code that assigns a Gura function.
		'''
	}
}

//------------------------------------------------------------------------------
// Renderer
//------------------------------------------------------------------------------
Renderer = class {
	__init__(moduleName:string, funcNameTranslator:function:nil) = {
		this.moduleName:public = moduleName
		this.funcInfos:public = FuncInfo(moduleName, decls, funcNameTranslator):list
	}
	Render(tmplSource:template, fileNameOut:string) = {
		renderer = this
		if (sys.argv.len() > 1 && sys.argv[1] == 'test') {
			tmplSource.render(sys.stdout)
		} else {
			tmplSource.render(fileNameOut)
			sys.stderr.println(fileNameOut, ' was created')
		}
	} % {`en, 'markdown',
		R'''
		Renders C code using a template `tmplSource` and that output the result to
		a file specified by `fileNameOut`.
		'''
	}
	RenderImplementation() = {
		this.funcInfos:*RenderImplementation() + '\n'
	} % {`en, 'markdown',
		R'''
		Renders C code that implements Gura functions.
		'''
	}
	RenderAssignment() = {
		this.funcInfos:*RenderAssignment()
	} % {`en, 'markdown',
		R'''
		Renders C code that assigns Gura functions.
		'''
	}
}

//------------------------------------------------------------------------------
// internal variables
//------------------------------------------------------------------------------
typeConvDict = %{
	'' => TypeConv(
			nil, nil, [],
			nil,
			nil,
			'')
	'any' => TypeConv(
			'any', 'Once', [],
			R'''
			Value ${arg.name} = arg.GetValue(${idx});
			''',
			nil,
			nil)
	'void' => TypeConv(
			nil, nil, [],
			nil,
			nil,
			R'''
			${fi.MakeCaller()};
			return Value::Nil;
			''', true)
	'bool' => TypeConv(
			'boolean', 'Once', [],
			'bool ${arg.name} = arg.GetBoolean(${idx});',
			nil,
			R'''
			bool _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'char' => TypeConv(
			'number', 'Once', [],
			'char ${arg.name} = arg.GetChar(${idx});',
			nil,
			R'''
			bool _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'short' => TypeConv(
			'number', 'Once', [],
			'short ${arg.name} = arg.GetShort(${idx});',
			nil,
			R'''
			short _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'int' => TypeConv(
			'number', 'Once', [],
			'int ${arg.name} = arg.GetInt(${idx});',
			nil,
			R'''
			int _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'long' => TypeConv(
			'number', 'Once', [],
			'long ${arg.name} = arg.GetLong(${idx});',
			nil,
			R'''
			long _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'unsigned_char' => TypeConv(
			'number', 'Once', [],
			'unsigned char ${arg.name} = arg.GetUChar(${idx});',
			nil,
			R'''
			unsigned char _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'unsigned_short' => TypeConv(
			'number', 'Once', [],
			'unsigned short ${arg.name} = arg.GetUShort(${idx});',
			nil,
			R'''
			unsigned short _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'unsigned_int' => TypeConv(
			'number', 'Once', [],
			'unsigned int ${arg.name} = arg.GetUInt(${idx});',
			nil,
			R'''
			unsigned int _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'unsigned_long' => TypeConv(
			'number', 'Once', [],
			'unsigned long ${arg.name} = arg.GetULong(${idx});',
			nil,
			R'''
			unsigned long _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'UChar' => TypeConv(
			'number', 'Once', [],
			'UChar ${arg.name} = arg.GetUChar(${idx});',
			nil,
			R'''
			UChar _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'UShort' => TypeConv(
			'number', 'Once', [],
			'UShort ${arg.name} = arg.GetUShort(${idx});',
			nil,
			R'''
			UShort _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'UInt' => TypeConv(
			'number', 'Once', [],
			'UInt ${arg.name} = arg.GetUInt(${idx});',
			nil,
			R'''
			UInt _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'ULong' => TypeConv(
			'number', 'Once', [],
			'ULong ${arg.name} = arg.GetULong(${idx});',
			nil,
			R'''
			ULong _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'Int64' => TypeConv(
			'number', 'Once', [],
			'Int64 ${arg.name} = static_cast<Int64>(arg.GetDouble(${idx}));',
			nil,
			R'''
			Int64 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'UInt64' => TypeConv(
			'number', 'Once', [],
			'UInt64 ${arg.name} = static_cast<UInt64>(arg.GetDouble(${idx}));',
			nil,
			R'''
			UInt64 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'float' => TypeConv(
			'number', 'Once', [],
			'float ${arg.name} = arg.GetFloat(${idx});',
			nil,
			R'''
			float _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'double' => TypeConv(
			'number', 'Once', [],
			'double ${arg.name} = arg.GetDouble(${idx});',
			nil,
			R'''
			double _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'char[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'CArray<char> ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'short[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'CArray<short> ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'int[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'CArray<int> ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'long[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'CArray<long> ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'unsigned_char[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'CArray<unsigned char> ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'unsigned_short[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'CArray<unsigned short> ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'unsigned_int[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'CArray<unsigned int> ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'unsigned_long[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'CArray<unsigned long> ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'number[]' => TypeConv(
			'number', 'Once', ['ListVar'],
			'const ValueList & ${arg.name} = arg.GetList(${idx});',
			nil,
			nil)
	'char@' => TypeConv(
			'string', 'Once', [],
			'char *${arg.name} = arg.GetString(${idx});',
			nil,
			R'''
			char *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'char@:const' => TypeConv(
			'string', 'Once', [],
			'const char *${arg.name} = arg.GetString(${idx});',
			nil,
			R'''
			const char *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'boolean' => TypeConv(
			'boolean', 'Once', [],
			'bool ${arg.name} = arg.GetBoolean(${idx});',
			'bool ${arg.name} = arg.IsValid(${idx})? arg.GetBoolean(${idx}) : false;',
			nil)
	'complex' => TypeConv(
			'complex', 'Once', [],
			'Complex ${arg.name} = arg.GetComplex(${idx});',
			'Complex ${arg.name} = arg.IsValid(${idx})? arg.GetComplex(${idx}) : Complex::Zero;',
			nil)
	'rational' => TypeConv(
			'rational', 'Once', [],
			'Rational ${arg.name} = arg.GetRational(${idx});',
			'Rational ${arg.name} = arg.IsValid(${idx})? arg.GetRational(${idx}) : Rational::Zero;',
			nil)
	'string' => TypeConv(
			'string', 'Once', [],
			'const char *${arg.name} = arg.GetString(${idx});',
			'const char *${arg.name} = arg.IsValid(${idx})? arg.GetString(${idx}) : nullptr;',
			nil)
	'symbol' => TypeConv(
			'symbol', 'Once', [],
			'const Symbol *${arg.name} = arg.GetSymbol(${idx});',
			'const Symbol *${arg.name} = arg.IsValid(${idx})? arg.GetSymbol(${idx}) : nullptr;',
			R'''
			const Symbol *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, arg, Value(_rtn));
			''')
	'binary' => TypeConv(
			'binary', 'Once', [],
			'const Binary *${arg.name} = &Object_binary::GetObject(arg, ${idx})->GetBinary();',
			'const Binary *${arg.name} = arg.IsValid(${idx})? &Object_binary::GetObject(arg, ${idx})->GetBinary() : nullptr;',
			nil)
	'color' => TypeConv(
			'color', 'Once', [],
			'const Color *${arg.name} = &Object_color::GetObject(arg, ${idx})->GetColor();',
			'const Color *${arg.name} = arg.IsValid(${idx})? &Object_color::GetObject(arg, ${idx})->GetColor() : nullptr;',
			nil)
	'datetime' => TypeConv(
			'datetime', 'Once', [],
			'const DateTime *${arg.name} = &Object_datetime::GetObject(arg, ${idx})->GetDateTime();',
			'const DateTime *${arg.name} = arg.IsValid(${idx})? &Object_datetime::GetObject(arg, ${idx})->GetDateTime() : nullptr;',
			nil)
	'stream' => TypeConv(
			'stream', 'Once', [],
			'Stream *${arg.name} = &Object_stream::GetObject(arg, ${idx})->GetStream();',
			'Stream *${arg.name} = arg.IsValid(${idx})? &Object_stream::GetObject(arg, ${idx})->GetStream() : nullptr;',
			nil)
	'image' => TypeConv(
			'image', 'Once', [],
			'Image *${arg.name} = Object_image::GetObject(arg, ${idx})->GetImage();',
			'Image *${arg.name} = arg.IsValid(${idx})? Object_image::GetObject(arg, ${idx})->GetImage() : nullptr;',
			nil)
	'function' => TypeConv(
			'function', 'Once', [],
			'const Function *${arg.name} = Object_function::GetObject(arg, ${idx})->GetFunction();',
			'const Function *${arg.name} = arg.IsValid(${idx})? Object_function::GetObject(arg, ${idx})->GetFunction() : nullptr;',
			nil)
	'array@char' => TypeConv(
			'array_char', 'Once', ['NoMap'],
			'Array<char> *${arg.name} = Object_array<char>::GetObject(arg, ${idx})->GetArray();',
			'Array<char> *${arg.name} = arg.IsValid(${idx})? Object_array<char>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@uchar' => TypeConv(
			'array_uchar', 'Once', ['NoMap'],
			'Array<UChar> *${arg.name} = Object_array<UChar>::GetObject(arg, ${idx})->GetArray();',
			'Array<UChar> *${arg.name} = arg.IsValid(${idx})? Object_array<UChar>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@short' => TypeConv(
			'array_short', 'Once', ['NoMap'],
			'Array<short> *${arg.name} = Object_array<short>::GetObject(arg, ${idx})->GetArray();',
			'Array<short> *${arg.name} = arg.IsValid(${idx})? Object_array<short>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@ushort' => TypeConv(
			'array_ushort', 'Once', ['NoMap'],
			'Array<UShort> *${arg.name} = Object_array<UShort>::GetObject(arg, ${idx})->GetArray();',
			'Array<UShort> *${arg.name} = arg.IsValid(${idx})? Object_array<UShort>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@long' => TypeConv(
			'array_long', 'Once', ['NoMap'],
			'Array<long> *${arg.name} = Object_array<long>::GetObject(arg, ${idx})->GetArray();',
			'Array<long> *${arg.name} = arg.IsValid(${idx})? Object_array<long>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@ulong' => TypeConv(
			'array_ulong', 'Once', ['NoMap'],
			'Array<ULong> *${arg.name} = Object_array<ULong>::GetObject(arg, ${idx})->GetArray();',
			'Array<ULong> *${arg.name} = arg.IsValid(${idx})? Object_array<ULong>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@int' => TypeConv(
			'array_int', 'Once', ['NoMap'],
			'Array<int> *${arg.name} = Object_array<int>::GetObject(arg, ${idx})->GetArray();',
			'Array<int> *${arg.name} = arg.IsValid(${idx})? Object_array<int>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@uint' => TypeConv(
			'array_uint', 'Once', ['NoMap'],
			'Array<UInt> *${arg.name} = Object_array<UInt>::GetObject(arg, ${idx})->GetArray();',
			'Array<UInt> *${arg.name} = arg.IsValid(${idx})? Object_array<UInt>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@float' => TypeConv(
			'array_float', 'Once', ['NoMap'],
			'Array<float> *${arg.name} = Object_array<float>::GetObject(arg, ${idx})->GetArray();',
			'Array<float> *${arg.name} = arg.IsValid(${idx})? Object_array<float>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
	'array@double' => TypeConv(
			'array_double', 'Once', ['NoMap'],
			'Array<double> *${arg.name} = Object_array<double>::GetObject(arg, ${idx})->GetArray();',
			'Array<double> *${arg.name} = arg.IsValid(${idx})? Object_array<double>::GetObject(arg, ${idx})->GetArray() : nullptr;',
			nil)
}

decls = []

//------------------------------------------------------------------------------
// functions
//------------------------------------------------------------------------------
Implement() {`block} = {
	decls:extern = block.children
} % {`en, 'markdown',
	R'''
	Describes function implementations in the `block`.
	'''
}

AddTypeConv(typeName:string, typeConv:TypeConv) = {
	typeConvDict.put(typeName, typeConv)
} % {`en, 'markdown',
	R'''
	Adds a type converter information.
	'''
}

AddTypeConvs() {`block} = {
	typeConvDict.append {|block|}
} % {`en, 'markdown',
	R'''
	Adds multiple entries of type converter information by specifying them in `block`.
	'''
}
