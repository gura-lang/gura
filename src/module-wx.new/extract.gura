#!/usr/bin/env gura
import(re)

dirNameWx = 'interface.wx'
dirNameDst = 'tmp'
//dirNameDst = 'generated'

tmpl@ClassesSource_gura = R'''
#!/usr/bin/env gura

srcs:public = [
	${classInfosAtRoot:*Gen_SourceEntry()}
]
'''.template()

tmpl@Classes_h = R'''
#ifndef __CLASSES_H__
#define __CLASSES_H__

${classInfosAtRoot:*Gen_Include()}

#endif
'''.template()

tmpl@Classes_cpp = R'''
#include "stdafx.h"

Gura_BeginModuleScope(wx)

void RegisterClasses(Environment &env)
{
	${classInfosAtRoot:*Gen_RealizeClass()}
	${classInfosAtRoot:*Gen_PrepareClass()}
}

Gura_EndModuleScope(wx)
'''.template()

tmpl@Header = R'''
//----------------------------------------------------------------------------
// wx${classNameShort}
//----------------------------------------------------------------------------
#ifndef __CLASS_WX_${classNameShort.upper()}_H__
#define __CLASS_WX_${classNameShort.upper()}_H__

Gura_BeginModuleScope(wx)

//----------------------------------------------------------------------------
// Class declaration for wx${classNameShort}
//----------------------------------------------------------------------------
Gura_DeclareUserClass(wx_${classNameShort});

//----------------------------------------------------------------------------
// Object declaration for wx${classNameShort}
//----------------------------------------------------------------------------
class Object_wx_${classNameShort} : public Object_wx_Object {
public:
	Gura_DeclareObjectAccessor(wx_${classNameShort})
public:
	inline Object_wx_${classNameShort}(wxEvent *pEntity, GuraObjectObserver *pObserver, bool ownerFlag) :
				Object_wx_Object(Gura_UserClass(wx_${classNameShort}), pEntity, pObserver, ownerFlag) {}
	inline Object_wx_${classNameShort}(Class *pClass, wx${classNameShort} *pEntity, GuraObjectObserver *pObserver, bool ownerFlag) :
				Object_wx_Object(pClass, pEntity, pObserver, ownerFlag) {}
	virtual ~Object_wx_${classNameShort}();
	virtual Object *Clone() const;
	virtual String ToString(bool exprFlag);
	inline wx${classNameShort} *GetEntity() {
		return dynamic_cast<wx${classNameShort} *>(_pEntity);
	}
	inline wx${classNameShort} *ReleaseEntity() {
		wx${classNameShort} *pEntity = GetEntity();
		InvalidateEntity();
		return pEntity;
	}
	inline bool IsInvalid(Signal &sig) const {
		if (_pEntity != nullptr) return false;
		SetError_InvalidWxObject(sig, "wx${classNameShort}");
		return true;
	}
};

Gura_EndModuleScope(wx)

#endif
'''.template()

tmpl@Source = R'''
//----------------------------------------------------------------------------
// wx${classNameShort}
//----------------------------------------------------------------------------
#include "stdafx.h"

Gura_BeginModuleScope(wx)

//----------------------------------------------------------------------------
// Gura interfaces for wx${classNameShort}
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Object implementation for wx${classNameShort}
//----------------------------------------------------------------------------
Object_wx_${classNameShort}::~Object_wx_${classNameShort}()
{
}

Object *Object_wx_${classNameShort}::Clone() const
{
	return nullptr;
}

String Object_wx_${classNameShort}::ToString(bool exprFlag)
{
	String rtn("<wx.${classNameShort}:");
	if (GetEntity() == nullptr) {
		rtn += "invalid>";
	} else {
		char buff[64];
		::sprintf(buff, "%p>", GetEntity());
		rtn += buff;
	}
	return rtn;
}

//----------------------------------------------------------------------------
// Class implementation for wx${classNameShort}
//----------------------------------------------------------------------------
Gura_ImplementUserInheritableClass(wx_${classNameShort})
{
}

Gura_ImplementDescendantCreator(wx_${classNameShort})
{
	return new Object_wx_${classNameShort}((pClass == nullptr)? this : pClass, nullptr, nullptr, OwnerFalse);
}

Gura_EndModuleScope(wx)
'''.template()

ClassInfo = struct(pathName:string, lineNo:number, strSrc:string,
				   className:string, classNamesParent[]:string,
				   classInfosOfParent[] => [], classInfosOfChild[] => []) {
	MakeClassNameShort() = this.className.sub('^wx', '')
	Gen_SourceEntry() = {
		str = format("'Class_wx_%s.cpp'\n", this.MakeClassNameShort())
		str + this.classInfosOfChild:*Gen_SourceEntry().join()
	}
	Gen_Include() = {
		str = format('#include "Class_wx_%s.h"\n', this.MakeClassNameShort())
		str + this.classInfosOfChild:*Gen_Include().join()
	}
	Gen_RealizeClass() = {
		str = if (this.classInfosOfParent.isempty()) {
			format('RealizeBaseClass(%s);\n', this.MakeClassNameShort())
		} else {
			format('RealizeDervClass(%s, %s);\n',
				   this.MakeClassNameShort(), this.classInfosOfParent[0].MakeClassNameShort())
		}
		str + this.classInfosOfChild:*Gen_RealizeClass().join()
	}
	Gen_PrepareClass() = {
		str = format('PrepareClass(%s);\n', this.MakeClassNameShort())
		str + this.classInfosOfChild:*Gen_PrepareClass().join()
	}
	RenderHeader(dirName:string):void = {
		classNameShort = this.MakeClassNameShort()
		tmpl@Header.render(path.join(dirName, format('Class_wx_%s.h', classNameShort)))
	}
	RenderSource(dirName:string) = {
		classNameShort = this.MakeClassNameShort()
		tmpl@Source.render(path.join(dirName, format('Class_wx_%s.cpp', classNameShort)))
	}
}

classInfoDict = %{}
classInfosAtRoot = []

WarningMessage(pathName:string, lineNo:number, strSrc:string, strMsg:string) = {
	printf('%s:%d: %s\n', pathName.replace(dirNameWx + path.sep_file, ''), lineNo, strMsg)
	printf('    %s\n', strSrc.sub(r'\s+', ' '))
	println()
}

ErrorMessage(pathName:string, lineNo:number, strSrc:string, strMsg:string) = {
	printf('%s:%d: %s\n', pathName.replace(dirNameWx + path.sep_file, ''), lineNo, strMsg)
	printf('    %s\n', strSrc.sub(r'\s+', ' '))
	println()
	sys.exit(1)
}

CreateClassInfo(pathName:string, lineNo:string, strSrc:string):void = {
	fields = [strSrc.split(':'):*strip()]
	if (m = fields[0].match(r'^class\s+(\w+\s+)?(wx\w+\s*<\s*\w+\s*>)$')) {
		// nothing to do
	} elsif (m = fields[0].match(r'^class\s+(\w+\s+)?(wx\w+)$')) {
		// nothing to do
	} else {
		ErrorMessage(pathName, lineNo, strSrc, 'unacceptable class syntax')
	}
	className = m[2]
	if (fields.len() == 2) {
		classNamesParent = fields[1].split(','):*strip().each():xlist {|field|
			if (m = field.match(r'^public\s+(\w+)')) {
				m[1]
			} else {
				WarningMessage(pathName, lineNo, strSrc, 'uses private inheritance')
				nil
			}
		}
	} else {
		classNamesParent = []
	}
	classInfoDict[className] = ClassInfo(pathName, lineNo, strSrc, className, classNamesParent)
}

Parse(pathName:string):map:void = {
	stat = `initial
	lineNo = 0
	readlines(pathName).each {|line|
		lineNo += 1
		line = line.chop()
		if (stat == `initial) {
			if (m = line.match(r'^class')) {
				str = line
				if (m = str.match('(.*);$')) {
					// just ignore prototype declaration
				} elsif (m = str.match('(.*){$')) {
					CreateClassInfo(pathName, lineNo, m[1])
				} else {
					stat = `classDecl
				}
			}
		} elsif (stat == `classDecl) {
			if (m = line.match(r'{')) {
				CreateClassInfo(pathName, lineNo, str)
				stat = `initial
			} else {
				str += line
			}
		}
	}
}

println('-- parsing')
Parse(path.walk(dirNameWx))
//Parse(path.walk(dirNameWx).head(10))
println('-- associating class information')
classInfoDict.values {|classInfo|
	if (classInfo.classNamesParent.isempty()) {
		classInfosAtRoot.add(classInfo)
	} else {
		classInfo.classNamesParent.each {|className|
			classInfoOfParent = classInfoDict.get(className)
			if (classInfoOfParent) {
				classInfo.classInfosOfParent.add(classInfoOfParent)
				classInfoOfParent.classInfosOfChild.add(classInfo)
			} else {
				WarningMessage(classInfo.pathName, classInfo.lineNo, classInfo.strSrc,
							   format('class %s refers to undefined class %s',
									  classInfo.className, className))
			}
		}
	}
}
println('-- generating files')
tmpl@ClassesSource_gura.render(path.join(dirNameDst, 'ClassesSource.gura'))
tmpl@Classes_h.render(path.join(dirNameDst, 'Classes.h'))
tmpl@Classes_cpp.render(path.join(dirNameDst, 'Classes.cpp'))
classInfoDict.values():*RenderHeader(dirNameDst)
classInfoDict.values():*RenderSource(dirNameDst)
