#!/usr/bin/env gura
import(re)

dirNameBase = '../../guest/wxWidgets-3.1.0/interface/wx'

ClassInfo = struct(pathName:string, lineNo:number, strSrc:string,
				   className:string, classNamesParent[]:string, classInfosParent[] => [])

classInfoDict = %{}

WarningMessage(pathName:string, lineNo:number, strSrc:string, strMsg:string) = {
	printf('%s:%d: %s\n', pathName.replace(dirNameBase + path.sep_file, ''), lineNo, strMsg)
	printf('    %s\n', strSrc.sub(r'\s+', ' '))
	println()
}

ErrorMessage(pathName:string, lineNo:number, strSrc:string, strMsg:string) = {
	printf('%s:%d: %s\n', pathName.replace(dirNameBase + path.sep_file, ''), lineNo, strMsg)
	printf('    %s\n', strSrc.sub(r'\s+', ' '))
	println()
	sys.exit(1)
}

CreateClassInfo(pathName:string, lineNo:string, strSrc:string):void = {
	fields = [strSrc.split(':'):*strip()]
	if (m = fields[0].match(r'^class\s+(\w+\s+)?(wx\w+\s*<\s*\w+\s*>)$')) {
		// nothing to do
	} elsif (m = fields[0].match(r'^class\s+(\w+\s+)?(wx\w+)$')) {
		// nothing to do
	} else {
		ErrorMessage(pathName, lineNo, strSrc, 'unacceptable class syntax')
	}
	className = m[2]
	if (fields.len() == 2) {
		classNamesParent = fields[1].split(','):*strip().each():xlist {|field|
			if (m = field.match(r'^public\s+(\w+)')) {
				m[1]
			} else {
				WarningMessage(pathName, lineNo, strSrc, 'uses private inheritance')
				nil
			}
		}
	} else {
		classNamesParent = []
	}
	classInfoDict[className] = ClassInfo(pathName, lineNo, strSrc, className, classNamesParent)
}

Parse(pathName:string):map:void = {
	stat = `initial
	lineNo = 0
	readlines(pathName).each {|line|
		lineNo += 1
		line = line.chop()
		if (stat == `initial) {
			if (m = line.match(r'^class')) {
				str = line
				if (m = str.match('(.*);$')) {
					// just ignore prototype declaration
				} elsif (m = str.match('(.*){$')) {
					CreateClassInfo(pathName, lineNo, m[1])
				} else {
					stat = `classDecl
				}
			}
		} elsif (stat == `classDecl) {
			if (m = line.match(r'{')) {
				CreateClassInfo(pathName, lineNo, str)
				stat = `initial
			} else {
				str += line
			}
		}
	}
}

Parse(path.walk(dirNameBase))
classInfoDict.values {|classInfo|
	classInfo.classNamesParent.each {|className|
		try {
			classInfoParent = classInfoDict[className]
			classInfo.classInfosParent.add(classInfoParent)
		} catch {
			WarningMessage(classInfo.pathName, classInfo.lineNo, classInfo.strSrc,
						   format('class %s refers to undefined class %s',
								  classInfo.className, className))
		}
	}
}
//Parse(path.walk(dirNameBase).head(10))
//Parse(path.join(dirNameBase, 'richtext/richtextbuffer.h'))
