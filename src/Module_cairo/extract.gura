#!/usr/bin/env gura
import(re)
fileName = 'resource.txt'

typeMap = %{
'cairo_antialias_t'			=> 'number'
'cairo_fill_rule_t'			=> 'number'
'cairo_line_cap_t'			=> 'number'
'cairo_line_join_t'			=> 'number'
'cairo_operator_t'			=> 'number'
'cairo_extend_t'			=> 'number'
'cairo_filter_t'			=> 'number'
'cairo_pattern_type_t'		=> 'number'
'cairo_region_overlap_t'	=> 'number'
'cairo_font_type_t'			=> 'number'
'cairo_subpixel_order_t'	=> 'number'
'cairo_hint_style_t'		=> 'number'
'cairo_hint_metrics_t'		=> 'number'
'cairo_ft_synthesize_t'		=> 'number'
'cairo_device_type_t'		=> 'number'
'cairo_surface_type_t'		=> 'number'
'cairo_pdf_version_t'		=> 'number'
'cairo_ps_level_t'			=> 'number'
'cairo_svg_version_t'		=> 'number'
'cairo_script_mode_t'		=> 'number'
}

tmplMethod = R'''
Gura_DeclareMethod(${className}, ${funcName})
{
	SetMode(RSLTMODE_Reduce, FLAG_None);
}

Gura_ImplementMethod(${className}, ${funcName})
{
	${cairoTypeName} *pEntity = Object_${className}::GetThisObj(args)->GetEntity();
	if (IsInvalid(sig, pEntity)) return Value::Null;
${if (!args.isempty()) { format('\t%s = "";', args:*Format()).join('\n') }}
	::${funcName}(${args:*argName.join(', ')});
	if (IsError(sig, cr)) return Value::Null;
	return args.GetThis();
}
'''
Arg = class {
	__init__(argType:string, argName:string, constFlag:boolean, ptrFlag:boolean) = {
		this.argType = argType
		this.argName = argName
		this.constFlag = constFlag
		this.ptrFlag = ptrFlag
	}
	Format() = {
		format('%s%s %s%s', cond(this.constFlag, 'const ', ''),
				this.argType, cond(this.ptrFlag, '*', ''), this.argName)
	}
}

types = []
generate(rtnType:string, rtnPtr:string, funcName:string, argsRaw:string) = {
	rtnPtrFlag = !rtnPtr.isempty()
	//println(rtnType, ' ', rtnPtr, ' ', funcName)
	types.append(rtnType)
	args = []
	argsRaw.split(','):*strip().each() {|argRaw|
		if (m = argRaw.match(r'^(\w+)$')) {
			argType = m[1]
		} elsif (m = argRaw.match(r'^(const\s+)?(unsigned\s+)?(\w+)\s*\*?\s*(\w+)')) {
			[argType, argName] = m[3, 4]
			if (!m[2].isempty()) { argType = m[2] + ' ' + argType }
			args.add(Arg(argType, argName, !m[1].isempty(), true))
		} elsif (m = argRaw.match(r'^(const\s+)?(unsigned\s+)?(\w+)\s+(\w+)')) {
			[argType, argName] = m[3, 4]
			if (!m[2].isempty()) { argType = m[2] + ' ' + argType }
			args.add(Arg(argType, argName, !m[1].isempty(), false))
		} else {
			println('invalid argument form: ', arg)
			sys.exit(1)
		}
	}
	className = ''
	cairoTypeName = 'cairo_hoge'
	print(tmplMethod.template())
}
stat = `normal
readlines(fileName) {|line|
	if (stat == `normal) {
		if (m = line.match(r'^(\w+)\s*(\*?)\s*(\w+)\s*\(([^\)]*)\)')) {
			[rtnType, rtnPtr, funcName] = m[1, 2, 3]
			argsRaw = m[4].strip()
			generate(rtnType, rtnPtr, funcName, argsRaw)
		} elsif (m = line.match(r'^(\w+)\s*(\*?)\s*(\w+)\s*\(([^\)]*)')) {
			[rtnType, rtnPtr, funcName] = m[1, 2, 3]
			argsRaw = m[4].strip()
			stat = `args
		} elsif (m = line.match(r'^(\w+)\s*(\*?)\s*(\w+)')) {
			[rtnType, rtnPtr, funcName] = m[1, 2, 3]
			stat = `argssep
		}
	} elsif (stat == `argssep) {
		if (m = line.match(r'^\s*\(([^\)]*)\)')) {
			argsRaw = m[1].strip()
			generate(rtnType, rtnPtr, funcName, argsRaw)
			stat = `normal
		} elsif (m = line.match(r'^\s*\(([^\)]*)')) {
			argsRaw = m[1].strip()
			stat = `args
		}
	} elsif (stat == `args) {
		if (m = line.match(r'\s*([^\)]*)\)')) {
			argsRaw += m[1].strip()
			generate(rtnType, rtnPtr, funcName, argsRaw)
			stat = `normal
		} elsif (m = line.match(r'\s*([^\)]*)')) {
			argsRaw += m[1].strip()
		}
	}
}
println(set(types).sort())
