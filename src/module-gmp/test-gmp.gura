#!/usr/bin/env gura
import(gmp)
import(testutil) {*}

TestUnaryOperators(ops[]:symbol, value) = {
	operator(ops) {|op|
		try {
			result = op(value).tostring()
		} catch {|e|
			result = e.text
		}
		printf('%s%s .. %s\n', op.symbol, value, result)
	}
}
TestBinaryOperators(ops[]:symbol, valueL, valueR) = {
	operator(ops) {|op|
		try {
			result = op(valueL, valueR).tostring()
		} catch {|e|
			result = e.text
		}
		printf('%s %s %s .. %s\n', valueL, op.symbol, valueR, result)
	}
}
testcase('declaration') {
	tests = [
		`gmp.mpz(0)
		`gmp.mpq(0)
		`gmp.mpf(0)
		`0L
		`0Lr
		`0.L
		`gmp.mpz(1)
		`gmp.mpq(1)
		`gmp.mpf(1)
		`1L
		`1Lr
		`1.L
		`gmp.mpz(-1)
		`gmp.mpq(-1)
		`gmp.mpf(-1)
		`(-1L)
		`(-1Lr)
		`(-1.L)
		`gmp.mpz(314)
		`gmp.mpq(314)
		`gmp.mpf(314)
		`314L
		`314Lr
		`314.L
		`gmp.mpz('314')
		`gmp.mpq('314')
		`gmp.mpf('314')
		`'314'.mpz()
		`'314'.mpq()
		`'314'.mpf()
		`3.14L
		//`3.14Lr
		`123456789012345678901234567890123456789012345678901234567890L
		`123456789012345678901234567890123456789012345678901234567890Lr
		`0777777
		`0b10101010
		`0xffffffff
	]
	tester(tests)
}
testcase('generic test for unary operators') {
	ops = [
		`+, `-, `~, `!, `.., `?
	]
	for (x in [3L, 3.L, 3Lr]) {
		printf('%s\n', typename(x))
		TestUnaryOperators(ops, x)
	}
}
testcase('generic test for binary operators') {
	ops = [
		`+, `-, `*, `/, `%, `**,
		`==, `<, `>, `<=, `>=, `<=>, `in,
		`&, `|, `^, `<<, `>>, `||, `&&, `=>
	]
	cross (x in [3, 3L, 3.L, 3Lr], y in [4, 4L, 4.L, 4Lr]) {
		printf('%s, %s\n', typename(x), typename(y))
		TestBinaryOperators(ops, x, y)
	}
}
testcase('zero-division') {
	ops = [`/, `%]
	cross (x in [3, 3L, 3.L, 3Lr], y in [0, 0L, 0.L, 0Lr]) {
		printf('%s, %s\n', typename(x), typename(y))
		TestBinaryOperators(ops, x, y)
	}
}
