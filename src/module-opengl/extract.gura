#!/usr/bin/env gura

decls = `{
glAccum(op:GLenum, value:GLfloat):void
glAlphaFunc(func:GLenum, ref:GLclampf):void
$glAreTexturesResident(textures:GLuint@:const):GLboolean = R'''
	GLsizei n = textures.GetSize();
	CArray<GLboolean> residences(n);
	GLboolean _rtn = glAreTexturesResident(n, textures, residences);
	if (_rtn == 0) return Value::Null;
	Value rtn;
	ValueList &valList = rtn.InitAsList(env, n);
	for (GLsizei i = 0; i < n; i++) {
		valList.push_back(residences[i] != 0);
	}
	return ReturnValue(env, sig, args, rtn);
'''
glArrayElement(i:GLint):void
glBegin(mode:GLenum):void
glBindTexture(target:GLenum, texture:GLuint):void
$glBitmap(width:GLsizei, height:GLsizei, xorig:GLfloat, yorig:GLfloat, xmove:GLfloat, ymove:GLfloat, bitmap:GLubyte@:const):void
glBlendColor(red:GLclampf, green:GLclampf, blue:GLclampf, alpha:GLclampf):void
glBlendEquation(mode:GLenum):void
glBlendEquationSeparate(modeRGB:GLenum, modeAlpha:GLenum):void
glBlendFunc(sfactor:GLenum, dfactor:GLenum):void
glCallList(list:GLuint):void
//$glCallLists(n:GLsizei, type:GLenum, lists:GLvoid@:const):void
glClear(mask:GLbitfield):void
glClearAccum(red:GLfloat, green:GLfloat, blue:GLfloat, alpha:GLfloat):void
glClearColor(red:GLclampf, green:GLclampf, blue:GLclampf, alpha:GLclampf):void
glClearDepth(depth:GLclampd):void
glClearIndex(c:GLfloat):void
glClearStencil(s:GLint):void
$glClipPlane(plane:GLenum, equation:GLdouble@:const):void
glColor3b(red:GLbyte, green:GLbyte, blue:GLbyte):void
$glColor3bv(v:GLbyte@:const):void
glColor3d(red:GLdouble, green:GLdouble, blue:GLdouble):void
$glColor3dv(v:GLdouble@:const):void
glColor3f(red:GLfloat, green:GLfloat, blue:GLfloat):void
$glColor3fv(v:GLfloat@:const):void
glColor3i(red:GLint, green:GLint, blue:GLint):void
$glColor3iv(v:GLint@:const):void
glColor3s(red:GLshort, green:GLshort, blue:GLshort):void
$glColor3sv(v:GLshort@:const):void
glColor3ub(red:GLubyte, green:GLubyte, blue:GLubyte):void
$glColor3ubv(v:GLubyte@:const):void
glColor3ui(red:GLuint, green:GLuint, blue:GLuint):void
$glColor3uiv(v:GLuint@:const):void
glColor3us(red:GLushort, green:GLushort, blue:GLushort):void
$glColor3usv(v:GLushort@:const):void
glColor4b(red:GLbyte, green:GLbyte, blue:GLbyte, alpha:GLbyte):void
$glColor4bv(v:GLbyte@:const):void
glColor4d(red:GLdouble, green:GLdouble, blue:GLdouble, alpha:GLdouble):void
$glColor4dv(v:GLdouble@:const):void
glColor4f(red:GLfloat, green:GLfloat, blue:GLfloat, alpha:GLfloat):void
$glColor4fv(v:GLfloat@:const):void
glColor4i(red:GLint, green:GLint, blue:GLint, alpha:GLint):void
$glColor4iv(v:GLint@:const):void
glColor4s(red:GLshort, green:GLshort, blue:GLshort, alpha:GLshort):void
$glColor4sv(v:GLshort@:const):void
glColor4ub(red:GLubyte, green:GLubyte, blue:GLubyte, alpha:GLubyte):void
$glColor4ubv(v:GLubyte@:const):void
glColor4ui(red:GLuint, green:GLuint, blue:GLuint, alpha:GLuint):void
$glColor4uiv(v:GLuint@:const):void
glColor4us(red:GLushort, green:GLushort, blue:GLushort, alpha:GLushort):void
$glColor4usv(v:GLushort@:const):void
glColorMask(red:GLboolean, green:GLboolean, blue:GLboolean, alpha:GLboolean):void
glColorMaterial(face:GLenum, mode:GLenum):void
//$glColorPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void
//$glColorSubTable(target:GLenum, start:GLsizei, count:GLsizei, format:GLenum, type:GLenum, data:GLvoid@:const):void
//$glColorTable(target:GLenum, internalformat:GLenum, width:GLsizei, format:GLenum, type:GLenum, table:GLvoid@:const):void
$glColorTableParameterfv(target:GLenum, pname:GLenum, params:GLfloat@:const):void
$glColorTableParameteriv(target:GLenum, pname:GLenum, params:GLint@:const):void
//$glConvolutionFilter1D(target:GLenum, internalformat:GLenum, width:GLsizei, format:GLenum, type:GLenum, image:GLvoid@:const):void
//$glConvolutionFilter2D(target:GLenum, internalformat:GLenum, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, image:GLvoid@:const):void
glConvolutionParameterf(target:GLenum, pname:GLenum, params:GLfloat):void
$glConvolutionParameterfv(target:GLenum, pname:GLenum, params:GLfloat@:const):void
glConvolutionParameteri(target:GLenum, pname:GLenum, params:GLint):void
$glConvolutionParameteriv(target:GLenum, pname:GLenum, params:GLint@:const):void
glCopyColorSubTable(target:GLenum, start:GLsizei, x:GLint, y:GLint, width:GLsizei):void
glCopyColorTable(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei):void
glCopyConvolutionFilter1D(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei):void
glCopyConvolutionFilter2D(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void
glCopyPixels(x:GLint, y:GLint, width:GLsizei, height:GLsizei, type:GLenum):void
glCopyTexImage1D(target:GLenum, level:GLint, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, border:GLint):void
glCopyTexImage2D(target:GLenum, level:GLint, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, height:GLsizei, border:GLint):void
glCopyTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, x:GLint, y:GLint, width:GLsizei):void
glCopyTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void
glCopyTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void
glCullFace(mode:GLenum):void
glDeleteLists(list:GLuint, range:GLsizei):void
$glDeleteTextures(n:GLsizei, textures:GLuint@:const):void
glDepthFunc(func:GLenum):void
glDepthMask(flag:GLboolean):void
glDepthRange(zNear:GLclampd, zFar:GLclampd):void
glDisable(cap:GLenum):void
glDisableClientState(array:GLenum):void
glDrawArrays(mode:GLenum, first:GLint, count:GLsizei):void
glDrawBuffer(mode:GLenum):void
//$glDrawElements(mode:GLenum, count:GLsizei, type:GLenum, indices:GLvoid@:const):void
//$glDrawPixels(width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, pixels:GLvoid@:const):void
//$glDrawRangeElements(mode:GLenum, start:GLuint, end:GLuint, count:GLsizei, type:GLenum, indices:GLvoid@:const):void
glEdgeFlag(flag:GLboolean):void
//$glEdgeFlagPointer(stride:GLsizei, pointer:GLvoid@:const):void
$glEdgeFlagv(flag:GLboolean@:const):void
glEnable(cap:GLenum):void
glEnableClientState(array:GLenum):void
glEnd():void
glEndList():void
glEvalCoord1d(u:GLdouble):void
$glEvalCoord1dv(u:GLdouble@:const):void
glEvalCoord1f(u:GLfloat):void
$glEvalCoord1fv(u:GLfloat@:const):void
glEvalCoord2d(u:GLdouble, v:GLdouble):void
$glEvalCoord2dv(u:GLdouble@:const):void
glEvalCoord2f(u:GLfloat, v:GLfloat):void
$glEvalCoord2fv(u:GLfloat@:const):void
glEvalMesh1(mode:GLenum, i1:GLint, i2:GLint):void
glEvalMesh2(mode:GLenum, i1:GLint, i2:GLint, j1:GLint, j2:GLint):void
glEvalPoint1(i:GLint):void
glEvalPoint2(i:GLint, j:GLint):void
$glFeedbackBuffer(size:GLsizei, type:GLenum, buffer:GLfloat@):void
glFinish():void
glFlush():void
glFogf(pname:GLenum, param:GLfloat):void
$glFogfv(pname:GLenum, params:GLfloat@:const):void
glFogi(pname:GLenum, param:GLint):void
$glFogiv(pname:GLenum, params:GLint@:const):void
glFrontFace(mode:GLenum):void
glFrustum(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble, zNear:GLdouble, zFar:GLdouble):void
glGenLists(range:GLsizei):GLuint
$glGenTextures(n:GLsizei, textures:GLuint@):void
$glGetBooleanv(pname:GLenum, params:GLboolean@):void
$glGetClipPlane(plane:GLenum, equation:GLdouble@):void
//$glGetColorTable(target:GLenum, format:GLenum, type:GLenum, table:GLvoid@):void
$glGetColorTableParameterfv(target:GLenum, pname:GLenum, params:GLfloat@):void
$glGetColorTableParameteriv(target:GLenum, pname:GLenum, params:GLint@):void
//$glGetConvolutionFilter(target:GLenum, format:GLenum, type:GLenum, image:GLvoid@):void
$glGetConvolutionParameterfv(target:GLenum, pname:GLenum, params:GLfloat@):void
$glGetConvolutionParameteriv(target:GLenum, pname:GLenum, params:GLint@):void
$glGetDoublev(pname:GLenum, params:GLdouble@):void
glGetError():GLenum
$glGetFloatv(pname:GLenum, params:GLfloat@):void
//$glGetHistogram(target:GLenum, reset:GLboolean, format:GLenum, type:GLenum, values:GLvoid@):void
$glGetHistogramParameterfv(target:GLenum, pname:GLenum, params:GLfloat@):void
$glGetHistogramParameteriv(target:GLenum, pname:GLenum, params:GLint@):void
$glGetIntegerv(pname:GLenum, params:GLint@):void
$glGetLightfv(light:GLenum, pname:GLenum, params:GLfloat@):void
$glGetLightiv(light:GLenum, pname:GLenum, params:GLint@):void
$glGetMapdv(target:GLenum, query:GLenum, v:GLdouble@):void
$glGetMapfv(target:GLenum, query:GLenum, v:GLfloat@):void
$glGetMapiv(target:GLenum, query:GLenum, v:GLint@):void
$glGetMaterialfv(face:GLenum, pname:GLenum, params:GLfloat@):void
$glGetMaterialiv(face:GLenum, pname:GLenum, params:GLint@):void
//$glGetMinmax(target:GLenum, reset:GLboolean, format:GLenum, type:GLenum, values:GLvoid@):void
$glGetMinmaxParameterfv(target:GLenum, pname:GLenum, params:GLfloat@):void
$glGetMinmaxParameteriv(target:GLenum, pname:GLenum, params:GLint@):void
$glGetPixelMapfv(map:GLenum, values:GLfloat@):void
$glGetPixelMapuiv(map:GLenum, values:GLuint@):void
$glGetPixelMapusv(map:GLenum, values:GLushort@):void
//$glGetPointerv(pname:GLenum, params:GLvoid@@):void
$glGetPolygonStipple(mask:GLubyte@):void
//$glGetSeparableFilter(target:GLenum, format:GLenum, type:GLenum, row:GLvoid@, column:GLvoid@, span:GLvoid@):void
$glGetString(name:GLenum):GLubyte@:const
$glGetTexEnvfv(target:GLenum, pname:GLenum, params:GLfloat@):void
$glGetTexEnviv(target:GLenum, pname:GLenum, params:GLint@):void
$glGetTexGendv(coord:GLenum, pname:GLenum, params:GLdouble@):void
$glGetTexGenfv(coord:GLenum, pname:GLenum, params:GLfloat@):void
$glGetTexGeniv(coord:GLenum, pname:GLenum, params:GLint@):void
//$glGetTexImage(target:GLenum, level:GLint, format:GLenum, type:GLenum, pixels:GLvoid@):void
$glGetTexLevelParameterfv(target:GLenum, level:GLint, pname:GLenum, params:GLfloat@):void
$glGetTexLevelParameteriv(target:GLenum, level:GLint, pname:GLenum, params:GLint@):void
$glGetTexParameterfv(target:GLenum, pname:GLenum, params:GLfloat@):void
$glGetTexParameteriv(target:GLenum, pname:GLenum, params:GLint@):void
glHint(target:GLenum, mode:GLenum):void
glHistogram(target:GLenum, width:GLsizei, internalformat:GLenum, sink:GLboolean):void
glIndexMask(mask:GLuint):void
//$glIndexPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void
glIndexd(c:GLdouble):void
$glIndexdv(c:GLdouble@:const):void
glIndexf(c:GLfloat):void
$glIndexfv(c:GLfloat@:const):void
glIndexi(c:GLint):void
$glIndexiv(c:GLint@:const):void
glIndexs(c:GLshort):void
$glIndexsv(c:GLshort@:const):void
glIndexub(c:GLubyte):void
$glIndexubv(c:GLubyte@:const):void
glInitNames():void
//$glInterleavedArrays(format:GLenum, stride:GLsizei, pointer:GLvoid@:const):void
glIsEnabled(cap:GLenum):GLboolean
glIsList(list:GLuint):GLboolean
glIsTexture(texture:GLuint):GLboolean
glLightModelf(pname:GLenum, param:GLfloat):void
$glLightModelfv(pname:GLenum, params:GLfloat@:const):void
glLightModeli(pname:GLenum, param:GLint):void
$glLightModeliv(pname:GLenum, params:GLint@:const):void
glLightf(light:GLenum, pname:GLenum, param:GLfloat):void
$glLightfv(light:GLenum, pname:GLenum, params:GLfloat@:const):void
glLighti(light:GLenum, pname:GLenum, param:GLint):void
$glLightiv(light:GLenum, pname:GLenum, params:GLint@:const):void
glLineStipple(factor:GLint, pattern:GLushort):void
glLineWidth(width:GLfloat):void
glListBase(base:GLuint):void
glLoadIdentity():void
$glLoadMatrixd(m:GLdouble@:const):void
$glLoadMatrixf(m:GLfloat@:const):void
glLoadName(name:GLuint):void
glLogicOp(opcode:GLenum):void
$glMap1d(target:GLenum, u1:GLdouble, u2:GLdouble, stride:GLint, order:GLint, points:GLdouble@:const):void
$glMap1f(target:GLenum, u1:GLfloat, u2:GLfloat, stride:GLint, order:GLint, points:GLfloat@:const):void
$glMap2d(target:GLenum, u1:GLdouble, u2:GLdouble, ustride:GLint, uorder:GLint, v1:GLdouble, v2:GLdouble, vstride:GLint, vorder:GLint, points:GLdouble@:const):void
$glMap2f(target:GLenum, u1:GLfloat, u2:GLfloat, ustride:GLint, uorder:GLint, v1:GLfloat, v2:GLfloat, vstride:GLint, vorder:GLint, points:GLfloat@:const):void
glMapGrid1d(un:GLint, u1:GLdouble, u2:GLdouble):void
glMapGrid1f(un:GLint, u1:GLfloat, u2:GLfloat):void
glMapGrid2d(un:GLint, u1:GLdouble, u2:GLdouble, vn:GLint, v1:GLdouble, v2:GLdouble):void
glMapGrid2f(un:GLint, u1:GLfloat, u2:GLfloat, vn:GLint, v1:GLfloat, v2:GLfloat):void
glMaterialf(face:GLenum, pname:GLenum, param:GLfloat):void
$glMaterialfv(face:GLenum, pname:GLenum, params:GLfloat@:const):void
glMateriali(face:GLenum, pname:GLenum, param:GLint):void
$glMaterialiv(face:GLenum, pname:GLenum, params:GLint@:const):void
glMatrixMode(mode:GLenum):void
glMinmax(target:GLenum, internalformat:GLenum, sink:GLboolean):void
$glMultMatrixd(m:GLdouble@:const):void
$glMultMatrixf(m:GLfloat@:const):void
glNewList(list:GLuint, mode:GLenum):void
glNormal3b(nx:GLbyte, ny:GLbyte, nz:GLbyte):void
$glNormal3bv(v:GLbyte@:const):void
glNormal3d(nx:GLdouble, ny:GLdouble, nz:GLdouble):void
$glNormal3dv(v:GLdouble@:const):void
glNormal3f(nx:GLfloat, ny:GLfloat, nz:GLfloat):void
$glNormal3fv(v:GLfloat@:const):void
glNormal3i(nx:GLint, ny:GLint, nz:GLint):void
$glNormal3iv(v:GLint@:const):void
glNormal3s(nx:GLshort, ny:GLshort, nz:GLshort):void
$glNormal3sv(v:GLshort@:const):void
//$glNormalPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void
glOrtho(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble, zNear:GLdouble, zFar:GLdouble):void
glPassThrough(token:GLfloat):void
$glPixelMapfv(map:GLenum, mapsize:GLint, values:GLfloat@:const):void
$glPixelMapuiv(map:GLenum, mapsize:GLint, values:GLuint@:const):void
$glPixelMapusv(map:GLenum, mapsize:GLint, values:GLushort@:const):void
glPixelStoref(pname:GLenum, param:GLfloat):void
glPixelStorei(pname:GLenum, param:GLint):void
glPixelTransferf(pname:GLenum, param:GLfloat):void
glPixelTransferi(pname:GLenum, param:GLint):void
glPixelZoom(xfactor:GLfloat, yfactor:GLfloat):void
glPointSize(size:GLfloat):void
glPolygonMode(face:GLenum, mode:GLenum):void
glPolygonOffset(factor:GLfloat, units:GLfloat):void
$glPolygonStipple(mask:GLubyte@:const):void
glPopAttrib():void
glPopClientAttrib():void
glPopMatrix():void
glPopName():void
$glPrioritizeTextures(n:GLsizei, textures:GLuint@:const, priorities:GLclampf@:const):void
glPushAttrib(mask:GLbitfield):void
glPushClientAttrib(mask:GLbitfield):void
glPushMatrix():void
glPushName(name:GLuint):void
glRasterPos2d(x:GLdouble, y:GLdouble):void
$glRasterPos2dv(v:GLdouble@:const):void
glRasterPos2f(x:GLfloat, y:GLfloat):void
$glRasterPos2fv(v:GLfloat@:const):void
glRasterPos2i(x:GLint, y:GLint):void
$glRasterPos2iv(v:GLint@:const):void
glRasterPos2s(x:GLshort, y:GLshort):void
$glRasterPos2sv(v:GLshort@:const):void
glRasterPos3d(x:GLdouble, y:GLdouble, z:GLdouble):void
$glRasterPos3dv(v:GLdouble@:const):void
glRasterPos3f(x:GLfloat, y:GLfloat, z:GLfloat):void
$glRasterPos3fv(v:GLfloat@:const):void
glRasterPos3i(x:GLint, y:GLint, z:GLint):void
$glRasterPos3iv(v:GLint@:const):void
glRasterPos3s(x:GLshort, y:GLshort, z:GLshort):void
$glRasterPos3sv(v:GLshort@:const):void
glRasterPos4d(x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void
$glRasterPos4dv(v:GLdouble@:const):void
glRasterPos4f(x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void
$glRasterPos4fv(v:GLfloat@:const):void
glRasterPos4i(x:GLint, y:GLint, z:GLint, w:GLint):void
$glRasterPos4iv(v:GLint@:const):void
glRasterPos4s(x:GLshort, y:GLshort, z:GLshort, w:GLshort):void
$glRasterPos4sv(v:GLshort@:const):void
glReadBuffer(mode:GLenum):void
//$glReadPixels(x:GLint, y:GLint, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, pixels:GLvoid@):void
glRectd(x1:GLdouble, y1:GLdouble, x2:GLdouble, y2:GLdouble):void
$glRectdv(v1:GLdouble@:const, v2:GLdouble@:const):void
glRectf(x1:GLfloat, y1:GLfloat, x2:GLfloat, y2:GLfloat):void
$glRectfv(v1:GLfloat@:const, v2:GLfloat@:const):void
glRecti(x1:GLint, y1:GLint, x2:GLint, y2:GLint):void
$glRectiv(v1:GLint@:const, v2:GLint@:const):void
glRects(x1:GLshort, y1:GLshort, x2:GLshort, y2:GLshort):void
$glRectsv(v1:GLshort@:const, v2:GLshort@:const):void
glRenderMode(mode:GLenum):GLint
glResetHistogram(target:GLenum):void
glResetMinmax(target:GLenum):void
glRotated(angle:GLdouble, x:GLdouble, y:GLdouble, z:GLdouble):void
glRotatef(angle:GLfloat, x:GLfloat, y:GLfloat, z:GLfloat):void
glScaled(x:GLdouble, y:GLdouble, z:GLdouble):void
glScalef(x:GLfloat, y:GLfloat, z:GLfloat):void
glScissor(x:GLint, y:GLint, width:GLsizei, height:GLsizei):void
$glSelectBuffer(size:GLsizei, buffer:GLuint@):void
//$glSeparableFilter2D(target:GLenum, internalformat:GLenum, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, row:GLvoid@:const, column:GLvoid@:const):void
glShadeModel(mode:GLenum):void
glStencilFunc(func:GLenum, ref:GLint, mask:GLuint):void
glStencilMask(mask:GLuint):void
glStencilOp(fail:GLenum, zfail:GLenum, zpass:GLenum):void
glTexCoord1d(s:GLdouble):void
$glTexCoord1dv(v:GLdouble@:const):void
glTexCoord1f(s:GLfloat):void
$glTexCoord1fv(v:GLfloat@:const):void
glTexCoord1i(s:GLint):void
$glTexCoord1iv(v:GLint@:const):void
glTexCoord1s(s:GLshort):void
$glTexCoord1sv(v:GLshort@:const):void
glTexCoord2d(s:GLdouble, t:GLdouble):void
$glTexCoord2dv(v:GLdouble@:const):void
glTexCoord2f(s:GLfloat, t:GLfloat):void
$glTexCoord2fv(v:GLfloat@:const):void
glTexCoord2i(s:GLint, t:GLint):void
$glTexCoord2iv(v:GLint@:const):void
glTexCoord2s(s:GLshort, t:GLshort):void
$glTexCoord2sv(v:GLshort@:const):void
glTexCoord3d(s:GLdouble, t:GLdouble, r:GLdouble):void
$glTexCoord3dv(v:GLdouble@:const):void
glTexCoord3f(s:GLfloat, t:GLfloat, r:GLfloat):void
$glTexCoord3fv(v:GLfloat@:const):void
glTexCoord3i(s:GLint, t:GLint, r:GLint):void
$glTexCoord3iv(v:GLint@:const):void
glTexCoord3s(s:GLshort, t:GLshort, r:GLshort):void
$glTexCoord3sv(v:GLshort@:const):void
glTexCoord4d(s:GLdouble, t:GLdouble, r:GLdouble, q:GLdouble):void
$glTexCoord4dv(v:GLdouble@:const):void
glTexCoord4f(s:GLfloat, t:GLfloat, r:GLfloat, q:GLfloat):void
$glTexCoord4fv(v:GLfloat@:const):void
glTexCoord4i(s:GLint, t:GLint, r:GLint, q:GLint):void
$glTexCoord4iv(v:GLint@:const):void
glTexCoord4s(s:GLshort, t:GLshort, r:GLshort, q:GLshort):void
$glTexCoord4sv(v:GLshort@:const):void
//$glTexCoordPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void
glTexEnvf(target:GLenum, pname:GLenum, param:GLfloat):void
$glTexEnvfv(target:GLenum, pname:GLenum, params:GLfloat@:const):void
glTexEnvi(target:GLenum, pname:GLenum, param:GLint):void
$glTexEnviv(target:GLenum, pname:GLenum, params:GLint@:const):void
glTexGend(coord:GLenum, pname:GLenum, param:GLdouble):void
$glTexGendv(coord:GLenum, pname:GLenum, params:GLdouble@:const):void
glTexGenf(coord:GLenum, pname:GLenum, param:GLfloat):void
$glTexGenfv(coord:GLenum, pname:GLenum, params:GLfloat@:const):void
glTexGeni(coord:GLenum, pname:GLenum, param:GLint):void
$glTexGeniv(coord:GLenum, pname:GLenum, params:GLint@:const):void
//$glTexImage1D(target:GLenum, level:GLint, internalformat:GLint, width:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:GLvoid@:const):void
//$glTexImage2D(target:GLenum, level:GLint, internalformat:GLint, width:GLsizei, height:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:GLvoid@:const):void
//$glTexImage3D(target:GLenum, level:GLint, internalformat:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:GLvoid@:const):void
glTexParameterf(target:GLenum, pname:GLenum, param:GLfloat):void
$glTexParameterfv(target:GLenum, pname:GLenum, params:GLfloat@:const):void
glTexParameteri(target:GLenum, pname:GLenum, param:GLint):void
$glTexParameteriv(target:GLenum, pname:GLenum, params:GLint@:const):void
//$glTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, width:GLsizei, format:GLenum, type:GLenum, pixels:GLvoid@:const):void
//$glTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, pixels:GLvoid@:const):void
//$glTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, type:GLenum, pixels:GLvoid@:const):void
glTranslated(x:GLdouble, y:GLdouble, z:GLdouble):void
glTranslatef(x:GLfloat, y:GLfloat, z:GLfloat):void
glVertex2d(x:GLdouble, y:GLdouble):void
$glVertex2dv(v:GLdouble@:const):void
glVertex2f(x:GLfloat, y:GLfloat):void
$glVertex2fv(v:GLfloat@:const):void
glVertex2i(x:GLint, y:GLint):void
$glVertex2iv(v:GLint@:const):void
glVertex2s(x:GLshort, y:GLshort):void
$glVertex2sv(v:GLshort@:const):void
glVertex3d(x:GLdouble, y:GLdouble, z:GLdouble):void
$glVertex3dv(v:GLdouble@:const):void
glVertex3f(x:GLfloat, y:GLfloat, z:GLfloat):void
$glVertex3fv(v:GLfloat@:const):void
glVertex3i(x:GLint, y:GLint, z:GLint):void
$glVertex3iv(v:GLint@:const):void
glVertex3s(x:GLshort, y:GLshort, z:GLshort):void
$glVertex3sv(v:GLshort@:const):void
glVertex4d(x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void
$glVertex4dv(v:GLdouble@:const):void
glVertex4f(x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void
$glVertex4fv(v:GLfloat@:const):void
glVertex4i(x:GLint, y:GLint, z:GLint, w:GLint):void
$glVertex4iv(v:GLint@:const):void
glVertex4s(x:GLshort, y:GLshort, z:GLshort, w:GLshort):void
$glVertex4sv(v:GLshort@:const):void
//$glVertexPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void
glViewport(x:GLint, y:GLint, width:GLsizei, height:GLsizei):void
glSampleCoverage(value:GLclampf, invert:GLboolean):void
$glLoadTransposeMatrixf(m:GLfloat@:const):void
$glLoadTransposeMatrixd(m:GLdouble@:const):void
$glMultTransposeMatrixf(m:GLfloat@:const):void
$glMultTransposeMatrixd(m:GLdouble@:const):void
//$glCompressedTexImage3D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, height:GLsizei, depth:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void
//$glCompressedTexImage2D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, height:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void
//$glCompressedTexImage1D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void
//$glCompressedTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void
//$glCompressedTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, width:GLsizei, height:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void
//$glCompressedTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, width:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void
//$glGetCompressedTexImage(target:GLenum, lod:GLint, img:GLvoid@):void
glActiveTexture(texture:GLenum):void
glClientActiveTexture(texture:GLenum):void
glMultiTexCoord1d(target:GLenum, s:GLdouble):void
$glMultiTexCoord1dv(target:GLenum, v:GLdouble@:const):void
glMultiTexCoord1f(target:GLenum, s:GLfloat):void
$glMultiTexCoord1fv(target:GLenum, v:GLfloat@:const):void
glMultiTexCoord1i(target:GLenum, s:GLint):void
$glMultiTexCoord1iv(target:GLenum, v:GLint@:const):void
glMultiTexCoord1s(target:GLenum, s:GLshort):void
$glMultiTexCoord1sv(target:GLenum, v:GLshort@:const):void
glMultiTexCoord2d(target:GLenum, s:GLdouble, t:GLdouble):void
$glMultiTexCoord2dv(target:GLenum, v:GLdouble@:const):void
glMultiTexCoord2f(target:GLenum, s:GLfloat, t:GLfloat):void
$glMultiTexCoord2fv(target:GLenum, v:GLfloat@:const):void
glMultiTexCoord2i(target:GLenum, s:GLint, t:GLint):void
$glMultiTexCoord2iv(target:GLenum, v:GLint@:const):void
glMultiTexCoord2s(target:GLenum, s:GLshort, t:GLshort):void
$glMultiTexCoord2sv(target:GLenum, v:GLshort@:const):void
glMultiTexCoord3d(target:GLenum, s:GLdouble, t:GLdouble, r:GLdouble):void
$glMultiTexCoord3dv(target:GLenum, v:GLdouble@:const):void
glMultiTexCoord3f(target:GLenum, s:GLfloat, t:GLfloat, r:GLfloat):void
$glMultiTexCoord3fv(target:GLenum, v:GLfloat@:const):void
glMultiTexCoord3i(target:GLenum, s:GLint, t:GLint, r:GLint):void
$glMultiTexCoord3iv(target:GLenum, v:GLint@:const):void
glMultiTexCoord3s(target:GLenum, s:GLshort, t:GLshort, r:GLshort):void
$glMultiTexCoord3sv(target:GLenum, v:GLshort@:const):void
glMultiTexCoord4d(target:GLenum, s:GLdouble, t:GLdouble, r:GLdouble, q:GLdouble):void
$glMultiTexCoord4dv(target:GLenum, v:GLdouble@:const):void
glMultiTexCoord4f(target:GLenum, s:GLfloat, t:GLfloat, r:GLfloat, q:GLfloat):void
$glMultiTexCoord4fv(target:GLenum, v:GLfloat@:const):void
glMultiTexCoord4i(target:GLenum, s:GLint, t:GLint, r:GLint, q:GLint):void
$glMultiTexCoord4iv(target:GLenum, v:GLint@:const):void
glMultiTexCoord4s(target:GLenum, s:GLshort, t:GLshort, r:GLshort, q:GLshort):void
$glMultiTexCoord4sv(target:GLenum, v:GLshort@:const):void
glFogCoordf(coord:GLfloat):void
$glFogCoordfv(coord:GLfloat@:const):void
glFogCoordd(coord:GLdouble):void
$glFogCoorddv(coord:GLdouble@:const):void
//$glFogCoordPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void
glSecondaryColor3b(red:GLbyte, green:GLbyte, blue:GLbyte):void
$glSecondaryColor3bv(v:GLbyte@:const):void
glSecondaryColor3d(red:GLdouble, green:GLdouble, blue:GLdouble):void
$glSecondaryColor3dv(v:GLdouble@:const):void
glSecondaryColor3f(red:GLfloat, green:GLfloat, blue:GLfloat):void
$glSecondaryColor3fv(v:GLfloat@:const):void
glSecondaryColor3i(red:GLint, green:GLint, blue:GLint):void
$glSecondaryColor3iv(v:GLint@:const):void
glSecondaryColor3s(red:GLshort, green:GLshort, blue:GLshort):void
$glSecondaryColor3sv(v:GLshort@:const):void
glSecondaryColor3ub(red:GLubyte, green:GLubyte, blue:GLubyte):void
$glSecondaryColor3ubv(v:GLubyte@:const):void
glSecondaryColor3ui(red:GLuint, green:GLuint, blue:GLuint):void
$glSecondaryColor3uiv(v:GLuint@:const):void
glSecondaryColor3us(red:GLushort, green:GLushort, blue:GLushort):void
$glSecondaryColor3usv(v:GLushort@:const):void
//$glSecondaryColorPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void
glPointParameterf(pname:GLenum, param:GLfloat):void
$glPointParameterfv(pname:GLenum, params:GLfloat@:const):void
glPointParameteri(pname:GLenum, param:GLint):void
$glPointParameteriv(pname:GLenum, params:GLint@:const):void
glBlendFuncSeparate(srcRGB:GLenum, dstRGB:GLenum, srcAlpha:GLenum, dstAlpha:GLenum):void
$glMultiDrawArrays(mode:GLenum, first:GLint@:const, count:GLsizei@:const, primcount:GLsizei):void
//$glMultiDrawElements(mode:GLenum, count:GLsizei@:const, type:GLenum, indices:GLvoid@:const@:const, primcount:GLsizei):void
glWindowPos2d(x:GLdouble, y:GLdouble):void
$glWindowPos2dv(v:GLdouble@:const):void
glWindowPos2f(x:GLfloat, y:GLfloat):void
$glWindowPos2fv(v:GLfloat@:const):void
glWindowPos2i(x:GLint, y:GLint):void
$glWindowPos2iv(v:GLint@:const):void
glWindowPos2s(x:GLshort, y:GLshort):void
$glWindowPos2sv(v:GLshort@:const):void
glWindowPos3d(x:GLdouble, y:GLdouble, z:GLdouble):void
$glWindowPos3dv(v:GLdouble@:const):void
glWindowPos3f(x:GLfloat, y:GLfloat, z:GLfloat):void
$glWindowPos3fv(v:GLfloat@:const):void
glWindowPos3i(x:GLint, y:GLint, z:GLint):void
$glWindowPos3iv(v:GLint@:const):void
glWindowPos3s(x:GLshort, y:GLshort, z:GLshort):void
$glWindowPos3sv(v:GLshort@:const):void
$glGenQueries(n:GLsizei, ids:GLuint@):void
$glDeleteQueries(n:GLsizei, ids:GLuint@:const):void
glIsQuery(id:GLuint):GLboolean
glBeginQuery(target:GLenum, id:GLuint):void
glEndQuery(target:GLenum):void
$glGetQueryiv(target:GLenum, pname:GLenum, params:GLint@):void
$glGetQueryObjectiv(id:GLuint, pname:GLenum, params:GLint@):void
$glGetQueryObjectuiv(id:GLuint, pname:GLenum, params:GLuint@):void
glBindBuffer(target:GLenum, buffer:GLuint):void
$glDeleteBuffers(n:GLsizei, buffers:GLuint@:const):void
$glGenBuffers(n:GLsizei, buffers:GLuint@):void
glIsBuffer(buffer:GLuint):GLboolean
//$glBufferData(target:GLenum, size:GLsizeiptr, data:GLvoid@:const, usage:GLenum):void
//$glBufferSubData(target:GLenum, offset:GLintptr, size:GLsizeiptr, data:GLvoid@:const):void
//$glGetBufferSubData(target:GLenum, offset:GLintptr, size:GLsizeiptr, data:GLvoid@):void
//glMapBuffer(target:GLenum, access:GLenum):GLvoid@
glUnmapBuffer(target:GLenum):GLboolean
$glGetBufferParameteriv(target:GLenum, pname:GLenum, params:GLint@):void
//$glGetBufferPointerv(target:GLenum, pname:GLenum, params:GLvoid@@):void
$glDrawBuffers(n:GLsizei, bufs:GLenum@:const):void
glVertexAttrib1d(index:GLuint, x:GLdouble):void
$glVertexAttrib1dv(index:GLuint, v:GLdouble@:const):void
glVertexAttrib1f(index:GLuint, x:GLfloat):void
$glVertexAttrib1fv(index:GLuint, v:GLfloat@:const):void
glVertexAttrib1s(index:GLuint, x:GLshort):void
$glVertexAttrib1sv(index:GLuint, v:GLshort@:const):void
glVertexAttrib2d(index:GLuint, x:GLdouble, y:GLdouble):void
$glVertexAttrib2dv(index:GLuint, v:GLdouble@:const):void
glVertexAttrib2f(index:GLuint, x:GLfloat, y:GLfloat):void
$glVertexAttrib2fv(index:GLuint, v:GLfloat@:const):void
glVertexAttrib2s(index:GLuint, x:GLshort, y:GLshort):void
$glVertexAttrib2sv(index:GLuint, v:GLshort@:const):void
glVertexAttrib3d(index:GLuint, x:GLdouble, y:GLdouble, z:GLdouble):void
$glVertexAttrib3dv(index:GLuint, v:GLdouble@:const):void
glVertexAttrib3f(index:GLuint, x:GLfloat, y:GLfloat, z:GLfloat):void
$glVertexAttrib3fv(index:GLuint, v:GLfloat@:const):void
glVertexAttrib3s(index:GLuint, x:GLshort, y:GLshort, z:GLshort):void
$glVertexAttrib3sv(index:GLuint, v:GLshort@:const):void
$glVertexAttrib4Nbv(index:GLuint, v:GLbyte@:const):void
$glVertexAttrib4Niv(index:GLuint, v:GLint@:const):void
$glVertexAttrib4Nsv(index:GLuint, v:GLshort@:const):void
glVertexAttrib4Nub(index:GLuint, x:GLubyte, y:GLubyte, z:GLubyte, w:GLubyte):void
$glVertexAttrib4Nubv(index:GLuint, v:GLubyte@:const):void
$glVertexAttrib4Nuiv(index:GLuint, v:GLuint@:const):void
$glVertexAttrib4Nusv(index:GLuint, v:GLushort@:const):void
$glVertexAttrib4bv(index:GLuint, v:GLbyte@:const):void
glVertexAttrib4d(index:GLuint, x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void
$glVertexAttrib4dv(index:GLuint, v:GLdouble@:const):void
glVertexAttrib4f(index:GLuint, x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void
$glVertexAttrib4fv(index:GLuint, v:GLfloat@:const):void
$glVertexAttrib4iv(index:GLuint, v:GLint@:const):void
glVertexAttrib4s(index:GLuint, x:GLshort, y:GLshort, z:GLshort, w:GLshort):void
$glVertexAttrib4sv(index:GLuint, v:GLshort@:const):void
$glVertexAttrib4ubv(index:GLuint, v:GLubyte@:const):void
$glVertexAttrib4uiv(index:GLuint, v:GLuint@:const):void
$glVertexAttrib4usv(index:GLuint, v:GLushort@:const):void
//$glVertexAttribPointer(index:GLuint, size:GLint, type:GLenum, normalized:GLboolean, stride:GLsizei, pointer:GLvoid@:const):void
glEnableVertexAttribArray(index:GLuint):void
glDisableVertexAttribArray(index:GLuint):void
$glGetVertexAttribdv(index:GLuint, pname:GLenum, params:GLdouble@):void
$glGetVertexAttribfv(index:GLuint, pname:GLenum, params:GLfloat@):void
$glGetVertexAttribiv(index:GLuint, pname:GLenum, params:GLint@):void
//$glGetVertexAttribPointerv(index:GLuint, pname:GLenum, pointer:GLvoid@@):void
glDeleteShader(shader:GLuint):void
glDetachShader(program:GLuint, shader:GLuint):void
glCreateShader(type:GLenum):GLuint
$glShaderSource(shader:GLuint, count:GLsizei, string:GLchar@:const@:const, length:GLint@:const):void
glCompileShader(shader:GLuint):void
glCreateProgram():GLuint
glAttachShader(program:GLuint, shader:GLuint):void
glLinkProgram(program:GLuint):void
glUseProgram(program:GLuint):void
glDeleteProgram(program:GLuint):void
glValidateProgram(program:GLuint):void
glUniform1f(location:GLint, v0:GLfloat):void
glUniform2f(location:GLint, v0:GLfloat, v1:GLfloat):void
glUniform3f(location:GLint, v0:GLfloat, v1:GLfloat, v2:GLfloat):void
glUniform4f(location:GLint, v0:GLfloat, v1:GLfloat, v2:GLfloat, v3:GLfloat):void
glUniform1i(location:GLint, v0:GLint):void
glUniform2i(location:GLint, v0:GLint, v1:GLint):void
glUniform3i(location:GLint, v0:GLint, v1:GLint, v2:GLint):void
glUniform4i(location:GLint, v0:GLint, v1:GLint, v2:GLint, v3:GLint):void
$glUniform1fv(location:GLint, count:GLsizei, value:GLfloat@:const):void
$glUniform2fv(location:GLint, count:GLsizei, value:GLfloat@:const):void
$glUniform3fv(location:GLint, count:GLsizei, value:GLfloat@:const):void
$glUniform4fv(location:GLint, count:GLsizei, value:GLfloat@:const):void
$glUniform1iv(location:GLint, count:GLsizei, value:GLint@:const):void
$glUniform2iv(location:GLint, count:GLsizei, value:GLint@:const):void
$glUniform3iv(location:GLint, count:GLsizei, value:GLint@:const):void
$glUniform4iv(location:GLint, count:GLsizei, value:GLint@:const):void
$glUniformMatrix2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
$glUniformMatrix3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
$glUniformMatrix4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
glIsShader(shader:GLuint):GLboolean
glIsProgram(program:GLuint):GLboolean
$glGetShaderiv(shader:GLuint, pname:GLenum, params:GLint@):void
$glGetProgramiv(program:GLuint, pname:GLenum, params:GLint@):void
$glGetAttachedShaders(program:GLuint, maxCount:GLsizei, count:GLsizei@, shaders:GLuint@):void
$glGetShaderInfoLog(shader:GLuint, bufSize:GLsizei, length:GLsizei@, infoLog:GLchar@):void
$glGetProgramInfoLog(program:GLuint, bufSize:GLsizei, length:GLsizei@, infoLog:GLchar@):void
$glGetUniformLocation(program:GLuint, name:GLchar@:const):GLint
$glGetActiveUniform(program:GLuint, index:GLuint, bufSize:GLsizei, length:GLsizei@, size:GLint@, type:GLenum@, name:GLchar@):void
$glGetUniformfv(program:GLuint, location:GLint, params:GLfloat@):void
$glGetUniformiv(program:GLuint, location:GLint, params:GLint@):void
$glGetShaderSource(shader:GLuint, bufSize:GLsizei, length:GLsizei@, source:GLchar@):void
$glBindAttribLocation(program:GLuint, index:GLuint, name:GLchar@:const):void
$glGetActiveAttrib(program:GLuint, index:GLuint, bufSize:GLsizei, length:GLsizei@, size:GLint@, type:GLenum@, name:GLchar@):void
$glGetAttribLocation(program:GLuint, name:GLchar@:const):GLint
glStencilFuncSeparate(face:GLenum, func:GLenum, ref:GLint, mask:GLuint):void
glStencilOpSeparate(face:GLenum, fail:GLenum, zfail:GLenum, zpass:GLenum):void
glStencilMaskSeparate(face:GLenum, mask:GLuint):void
$glUniformMatrix2x3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
$glUniformMatrix3x2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
$glUniformMatrix2x4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
$glUniformMatrix4x2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
$glUniformMatrix3x4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
$glUniformMatrix4x3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void
}

import(modimp) {TypeConv, Renderer}

TypeConv_Enum(typeName:string) = {
	typeName => TypeConv(
			'number', 'Once', [],
			typeName,
			'static_cast<' + typeName + '>(args.GetInt(%d))',
			'Value(_rtn)')
}


typeConvDict = %{
	TypeConv_Enum('GLenum')
	'GLboolean' => TypeConv(
			'boolean', 'Once', [],
			'GLboolean', '(args.GetBoolean(%d)? 1 : 0)',
			'Value(_rtn != 0)')
	'GLbitfield' => TypeConv(
			'number', 'Once', [],
			'GLbitfield', 'args.GetUInt(%d)',
			'Value(_rtn)')
	'GLbyte' => TypeConv(
			'number', 'Once', [],
			'GLbyte', 'args.GetChar(%d)',
			'Value(_rtn)')
	'GLshort' => TypeConv(
			'number', 'Once', [],
			'GLshort', 'args.GetShort(%d)',
			'Value(_rtn)')
	'GLint' => TypeConv(
			'number', 'Once', [],
			'GLint', 'args.GetInt(%d)',
			'Value(_rtn)')
	'GLsizei' => TypeConv(
			'number', 'Once', [],
			'GLsizei', 'args.GetInt(%d)',
			'Value(_rtn)')
	'GLubyte' => TypeConv(
			'number', 'Once', [],
			'GLubyte', 'args.GetUChar(%d)',
			'Value(_rtn)')
	'GLushort' => TypeConv(
			'number', 'Once', [],
			'GLushort', 'args.GetUShort(%d)',
			'Value(_rtn)')
	'GLuint' => TypeConv(
			'number', 'Once', [],
			'GLuint', 'args.GetUInt(%d)',
			'Value(_rtn)')
	'GLfloat' => TypeConv(
			'number', 'Once', [],
			'GLfloat', 'args.GetFloat(%d)',
			'Value(_rtn)')
	'GLclampf' => TypeConv(
			'number', 'Once', [],
			'GLclampf', 'args.GetFloat(%d)',
			'Value(_rtn)')
	'GLdouble' => TypeConv(
			'number', 'Once', [],
			'GLdouble', 'args.GetDouble(%d)',
			'Value(_rtn)')
	'GLclampd' => TypeConv(
			'number', 'Once', [],
			'GLclampd', 'args.GetDouble(%d)',
			'Value(_rtn)')
	'GLenum@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLenum>', 'args.GetList(%d)',
			nil)
	'GLenum@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLenum>', 'args.GetList(%d)',
			nil)
	'GLboolean@' => TypeConv(
			'boolean', 'Once', ['List'],
			'CArray<GLboolean>', 'args.GetList(%d)',
			nil)
	'GLboolean@:const' => TypeConv(
			'boolean', 'Once', ['List'],
			'CArray<GLboolean>', 'args.GetList(%d)',
			nil)
	'GLbyte@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLbyte>', 'args.GetList(%d)',
			nil)
	'GLchar@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLchar>', 'args.GetList(%d)',
			nil)
	'GLchar@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLchar>', 'args.GetList(%d)',
			nil)
	'GLubyte@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLubyte>', 'args.GetList(%d)',
			nil)
	'GLubyte@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLubyte>', 'args.GetList(%d)',
			nil)
	'GLshort@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLshort>', 'args.GetList(%d)',
			nil)
	'GLushort@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLushort>', 'args.GetList(%d)',
			nil)
	'GLushort@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLushort>', 'args.GetList(%d)',
			nil)
	'GLint@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLint>', 'args.GetList(%d)',
			nil)
	'GLint@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLint>', 'args.GetList(%d)',
			nil)
	'GLsizei@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLsizei>', 'args.GetList(%d)',
			nil)
	'GLsizei@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLsizei>', 'args.GetList(%d)',
			nil)
	'GLuint@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLuint>', 'args.GetList(%d)',
			nil)
	'GLuint@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLuint>', 'args.GetList(%d)',
			nil)
	'GLfloat@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLfloat>', 'args.GetList(%d)',
			nil)
	'GLfloat@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLfloat>', 'args.GetList(%d)',
			nil)
	'GLclampf@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLclampf>', 'args.GetList(%d)',
			nil)
	'GLdouble@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLdouble>', 'args.GetList(%d)',
			nil)
	'GLdouble@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLdouble>', 'args.GetList(%d)',
			nil)
}

Renderer('opengl', decls.children, typeConvDict, &{$funcName}) {|renderer|
	if (sys.argv.len() > 1 && sys.argv[1] == 'test') {
		print(renderer.RenderImplementation())
		print(renderer.RenderAssignment())
	} else {
		fileNameTmpl = 'Functions.cpp.tmpl'
		fileNameOut = 'Functions.cpp'
		template(fileNameTmpl).render(fileNameOut)
		println(fileNameOut, ' was created')
	}
}
