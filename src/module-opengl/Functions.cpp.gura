#!/usr/bin/env gura
import(cbridge_gl)

cbridge_gl.Implement {

glewInit():void = R'''
^#if defined(__GLEW_H__)
	SetupGLEW(env);
#endif
	return Value::Nil;
''' %% {`en,
	R'''
	Initializes the extension entry points.
	'''
}
	
glAccum(op:GLenum, value:GLfloat):void:map = `auto %% {`en,
	R'''
	operate on the accumulation buffer
	'''
}

glAlphaFunc(func:GLenum, ref:GLclampf):void:map = `auto %% {`en,
	R'''
	specify the alpha test function
	'''
}

glAreTexturesResident(textures:GLuint@:const):GLboolean:map {block?} = R'''
	GLsizei n = _textures->GetElemNum();
	AutoPtr<ArrayT<GLboolean> > _residences(new ArrayT<GLboolean>(n));
	GLboolean *residences = _residences->GetPointer();
	GLboolean _rtn = glAreTexturesResident(n, textures, residences);
	if (_rtn == 0) return Value::Nil;
	Value _rtnVal;
	Object_list *pObjList = _rtnVal.InitAsList(env, n);
	for (GLsizei i = 0; i < n; i++) {
		pObjList->Add(residences[i] != 0);
	}
	return ReturnValue(env, arg, _rtnVal);
''' %% {`en,
	R'''
	determine if textures are loaded in texture memory
	'''
}

glArrayElement(i:GLint):void:map = `auto %% {`en,
	R'''
	render a vertex using the specified vertex array element
	'''
}

glBegin(mode:GLenum):void:map {block?} = R'''
	glBegin(mode);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glEnd();
	}
	return Value::Nil;
''' %% {`en,
	R'''
	delimit the vertices of a primitive or a group of like primitives
	'''
}

glBindTexture(target:GLenum, texture:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

glBitmap(width:GLsizei, height:GLsizei, xorig:GLfloat, yorig:GLfloat, xmove:GLfloat, ymove:GLfloat, bitmap:GLubyte@:const:nil):void:map = R'''
	if (_bitmap != nullptr) {
		size_t bytesReq = ((width + 7) / 8) * height;
		if (_bitmap->GetElemNum() < bytesReq) {
			env.SetError(ERR_ValueError, "array doesn\'t contain enough data");
			return Value::Nil;
		}
	}
	glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glBlendColor(red:GLclampf, green:GLclampf, blue:GLclampf, alpha:GLclampf):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glBlendColor(red, green, blue, alpha);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}
	
glBlendEquation(mode:GLenum):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glBlendEquation(mode);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glBlendEquationSeparate(modeRGB:GLenum, modeAlpha:GLenum):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glBlendEquationSeparate(modeRGB, modeAlpha);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glBlendFunc(sfactor:GLenum, dfactor:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glCallList(list:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

glCallLists(type:GLenum, lists[]:number):void:map = R'''
	const ValueList &lists_in = arg.GetList(1);
	GLsizei n = static_cast<GLsizei>(lists.size());
	AutoPtr<Memory> pListsBuff;
	if (type == GL_BYTE) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLbyte) * n));
		GLbyte *p = reinterpret_cast<GLbyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetChar(); }
	} else if (type == GL_UNSIGNED_BYTE) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUChar(); }
	} else if (type == GL_SHORT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLshort) * n));
		GLshort *p = reinterpret_cast<GLshort *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetShort(); }
	} else if (type == GL_UNSIGNED_SHORT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLushort) * n));
		GLushort *p = reinterpret_cast<GLushort *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUShort(); }
	} else if (type == GL_INT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLint) * n));
		GLint *p = reinterpret_cast<GLint *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetInt(); }
	} else if (type == GL_UNSIGNED_INT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLuint) * n));
		GLuint *p = reinterpret_cast<GLuint *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUInt(); }
	} else if (type == GL_FLOAT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLfloat) * n));
		GLfloat *p = reinterpret_cast<GLfloat *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetFloat(); }
	} else if (type == GL_2_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 2 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			UShort num = pValue->GetUShort();
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else if (type == GL_3_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 3 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			ULong num = pValue->GetULong();
			*p++ = static_cast<GLubyte>(num >> 16);
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else if (type == GL_4_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 4 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			ULong num = pValue->GetULong();
			*p++ = static_cast<GLubyte>(num >> 24);
			*p++ = static_cast<GLubyte>(num >> 16);
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else {
		env.SetError(ERR_ValueError, "invalid type specification");
		return Value::Nil;
	}
	// GLsizei n, GLenum type, const GLvoid *lists
	glCallLists(n, type, pListsBuff->GetPointer());
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glClear(mask:GLbitfield):void:map = `auto %% {`en,
	R'''
	'''
}

glClearAccum(red:GLfloat, green:GLfloat, blue:GLfloat, alpha:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glClearColor(red:GLclampf, green:GLclampf, blue:GLclampf, alpha:GLclampf):void:map = `auto %% {`en,
	R'''
	'''
}

glClearDepth(depth:GLclampd):void:map = `auto %% {`en,
	R'''
	'''
}

glClearIndex(c:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glClearStencil(s:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glClipPlane(plane:GLenum, equation:GLdouble@4):map:void {block?} = R'''
	glClipPlane(plane, equation);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glColor3b(red:GLbyte, green:GLbyte, blue:GLbyte):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3bv(v:GLbyte@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3d(red:GLdouble, green:GLdouble, blue:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3dv(v:GLdouble@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3f(red:GLfloat, green:GLfloat, blue:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3fv(v:GLfloat@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3i(red:GLint, green:GLint, blue:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3iv(v:GLint@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3s(red:GLshort, green:GLshort, blue:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3sv(v:GLshort@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3ub(red:GLubyte, green:GLubyte, blue:GLubyte):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3ubv(v:GLubyte@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3ui(red:GLuint, green:GLuint, blue:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3uiv(v:GLuint@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3us(red:GLushort, green:GLushort, blue:GLushort):void:map = `auto %% {`en,
	R'''
	'''
}

glColor3usv(v:GLushort@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4b(red:GLbyte, green:GLbyte, blue:GLbyte, alpha:GLbyte):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4bv(v:GLbyte@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4d(red:GLdouble, green:GLdouble, blue:GLdouble, alpha:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4dv(v:GLdouble@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4f(red:GLfloat, green:GLfloat, blue:GLfloat, alpha:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4fv(v:GLfloat@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4i(red:GLint, green:GLint, blue:GLint, alpha:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4iv(v:GLint@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4s(red:GLshort, green:GLshort, blue:GLshort, alpha:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4sv(v:GLshort@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4ub(red:GLubyte, green:GLubyte, blue:GLubyte, alpha:GLubyte):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4ubv(v:GLubyte@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4ui(red:GLuint, green:GLuint, blue:GLuint, alpha:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4uiv(v:GLuint@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4us(red:GLushort, green:GLushort, blue:GLushort, alpha:GLushort):void:map = `auto %% {`en,
	R'''
	'''
}

glColor4usv(v:GLushort@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glColorMask(red:GLboolean, green:GLboolean, blue:GLboolean, alpha:GLboolean):void:map = `auto %% {`en,
	R'''
	'''
}

glColorMaterial(face:GLenum, mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

//glColorPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

//glColorSubTable(target:GLenum, start:GLsizei, count:GLsizei, format:GLenum, type:GLenum, data:GLvoid@:const):void:map = `unsupport

//glColorTable(target:GLenum, internalformat:GLenum, width:GLsizei, format:GLenum, type:GLenum, table:GLvoid@:const):void:map = `unsupport

glColorTableParameterfv(target:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glColorTableParameterfv(target, pname, params);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glColorTableParameteriv(target:GLenum, pname:GLenum, params:GLint@pname:const):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glColorTableParameteriv(target, pname, params);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

//glConvolutionFilter1D(target:GLenum, internalformat:GLenum, width:GLsizei, format:GLenum, type:GLenum, image:GLvoid@:const):void:map = `unsupport

//glConvolutionFilter2D(target:GLenum, internalformat:GLenum, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, image:GLvoid@:const):void:map = `unsupport

glConvolutionParameterf(target:GLenum, pname:GLenum, params:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glConvolutionParameterf(target, pname, params);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glConvolutionParameterfv(target:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glConvolutionParameterfv(target, pname, params);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glConvolutionParameteri(target:GLenum, pname:GLenum, params:GLint):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glConvolutionParameteri(target, pname, params);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glConvolutionParameteriv(target:GLenum, pname:GLenum, params:GLint@pname:const):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glConvolutionParameteriv(target, pname, params);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCopyColorSubTable(target:GLenum, start:GLsizei, x:GLint, y:GLint, width:GLsizei):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glCopyColorSubTable(target, start, x, y, width);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCopyColorTable(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glCopyColorTable(target, internalformat, x, y, width);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCopyConvolutionFilter1D(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glCopyConvolutionFilter1D(target, internalformat, x, y, width);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCopyConvolutionFilter2D(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCopyPixels(x:GLint, y:GLint, width:GLsizei, height:GLsizei, type:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glCopyTexImage1D(target:GLenum, level:GLint, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, border:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glCopyTexImage2D(target:GLenum, level:GLint, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, height:GLsizei, border:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glCopyTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, x:GLint, y:GLint, width:GLsizei):void:map = `auto %% {`en,
	R'''
	'''
}

glCopyTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = `auto %% {`en,
	R'''
	'''
}

glCopyTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCullFace(mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glDeleteLists(list:GLuint, range:GLsizei):void:map = `auto %% {`en,
	R'''
	'''
}

glDeleteTextures(textures:GLuint@:const):void:map = R'''
	GLsizei n = _textures->GetElemNum();
	glDeleteTextures(n, textures);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glDepthFunc(func:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glDepthMask(flag:GLboolean):void:map = `auto %% {`en,
	R'''
	'''
}

glDepthRange(zNear:GLclampd, zFar:GLclampd):void:map = `auto %% {`en,
	R'''
	'''
}

glDisable(cap:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glDisableClientState(array:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glDrawArrays(mode:GLenum, first:GLint, count:GLsizei):void:map = `auto %% {`en,
	R'''
	'''
}

glDrawBuffer(mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

//glDrawElements(mode:GLenum, count:GLsizei, type:GLenum, indices:GLvoid@:const):void:map = `unsupport

glDrawPixels(width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, pixels:array):void:map = R'''
	const void *p = GetArrayTPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glDrawPixels(width, height, format, type, p);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glDrawPixelsFromImage(image:image):void:map = R'''	
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = image->GetBuffer();
	// GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels
	glDrawPixels(width, height, format, type, pixels);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

//glDrawRangeElements(mode:GLenum, start:GLuint, end:GLuint, count:GLsizei, type:GLenum, indices:GLvoid@:const):void:map = `unsupport

glEdgeFlag(flag:GLboolean):void:map = `auto %% {`en,
	R'''
	'''
}

//glEdgeFlagPointer(stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glEdgeFlagv(flag:GLboolean@1:const):void:map = `auto %% {`en,
	R'''
	'''
}

glEnable(cap:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glEnableClientState(array:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glEnd():void = `auto %% {`en,
	R'''
	'''
}

glEndList():void = `auto %% {`en,
	R'''
	'''
}

glEvalCoord1d(u:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalCoord1dv(u:GLdouble@1:const):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalCoord1f(u:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalCoord1fv(u:GLfloat@1:const):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalCoord2d(u:GLdouble, v:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalCoord2dv(u:GLdouble@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalCoord2f(u:GLfloat, v:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalCoord2fv(u:GLfloat@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalMesh1(mode:GLenum, i1:GLint, i2:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalMesh2(mode:GLenum, i1:GLint, i2:GLint, j1:GLint, j2:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalPoint1(i:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glEvalPoint2(i:GLint, j:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glFeedbackBuffer(type:GLenum, buffer:array@float:nil):void = R'''
	if (buffer == nullptr) {
		glFeedbackBuffer(0, type, nullptr);
	} else {
		glFeedbackBuffer(buffer->GetElemNum(), type, buffer->GetPointer());
	}
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glFinish():void = `auto %% {`en,
	R'''
	'''
}

glFlush():void = `auto %% {`en,
	R'''
	'''
}

glFogf(pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glFogfv(pname:GLenum, params:GLfloat@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glFogi(pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glFogiv(pname:GLenum, params:GLint@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glFrontFace(mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glFrustum(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble, zNear:GLdouble, zFar:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glGenLists(range:GLsizei):GLuint:map {block?} = `auto %% {`en,
	R'''
	'''
}

glGenTextures(n:GLsizei):map {block?} = R'''
	AutoPtr<ArrayT<GLuint> > _textures(new ArrayT<GLuint>(n));
	GLuint *textures = _textures->GetPointer();
	glGenTextures(n, textures);
	return Value::CreateList(env, textures, n);
''' %% {`en,
	R'''
	'''
}

glGetBooleanv(pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLboolean> > _params(new ArrayT<GLboolean>(n));
	GLboolean *params = _params->GetPointer();
	glGetBooleanv(pname, params);
	Value _rtnVal;
	if (n == 1) {
		_rtnVal = Value(params[0]);
	} else {
		Object_list *pObjList = _rtnVal.InitAsList(env, n);
		for (GLsizei i = 0; i < n; i++) {
			pObjList->Add(params[i] != 0);
		}
	}
	return ReturnValue(env, arg, _rtnVal);
''' %% {`en,
	R'''
	'''
}

glGetClipPlane(plane:GLenum):map = R'''
	GLdouble equation[4];
	glGetClipPlane(plane, equation);
	return ReturnValue(env, arg, Value::CreateList(env, equation, ArraySizeOf(equation)));
''' %% {`en,
	R'''
	'''
}

//glGetColorTable(target:GLenum, format:GLenum, type:GLenum, table:GLvoid@):void:map = `unsupport

glGetColorTableParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetColorTableParameterfv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetColorTableParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetColorTableParameteriv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

//glGetConvolutionFilter(target:GLenum, format:GLenum, type:GLenum, image:GLvoid@):void:map = `unsupport

glGetConvolutionParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetColorTableParameterfv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetConvolutionParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetColorTableParameteriv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetDoublev(pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLdouble> > _params(new ArrayT<GLdouble>(n));
	GLdouble *params = _params->GetPointer();
	glGetDoublev(pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetError():GLenum {block?} = `auto %% {`en,
	R'''
	'''
}

glGetFloatv(pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetFloatv(pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

//glGetHistogram(target:GLenum, reset:GLboolean, format:GLenum, type:GLenum, values:GLvoid@):void:map = `unsupport

glGetHistogramParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetHistogramParameterfv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetHistogramParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetHistogramParameteriv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetIntegerv(pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetIntegerv(pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetLightfv(light:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetLightfv(light, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetLightiv(light:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetLightiv(light, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetMapdv(target:GLenum, query:GLenum, v:GLdouble@):void:map = `unsupport %% {`en,
	R'''
	'''
}

glGetMapfv(target:GLenum, query:GLenum, v:GLfloat@):void:map = `unsupport %% {`en,
	R'''
	'''
}

glGetMapiv(target:GLenum, query:GLenum, v:GLint@):void:map = `unsupport %% {`en,
	R'''
	'''
}

glGetMaterialfv(face:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetMaterialfv(face, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetMaterialiv(face:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetMaterialiv(face, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

//glGetMinmax(target:GLenum, reset:GLboolean, format:GLenum, type:GLenum, values:GLvoid@):void:map = `unsupport

glGetMinmaxParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetMinmaxParameterfv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetMinmaxParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetMinmaxParameteriv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetPixelMapfv(map:GLenum, values:GLfloat@):void:map = `unsupport %% {`en,
	R'''
	'''
}

glGetPixelMapuiv(map:GLenum, values:GLuint@):void:map = `unsupport %% {`en,
	R'''
	'''
}

glGetPixelMapusv(map:GLenum, values:GLushort@):void:map = `unsupport %% {`en,
	R'''
	'''
}

//glGetPointerv(pname:GLenum, params:GLvoid@@):void:map = `unsupport

glGetPolygonStipple():map = R'''
	AutoPtr<ArrayT<UInt8> > pArrayT(new ArrayT<UInt8>(32 * 4));
	glGetPolygonStipple(pArrayT->GetPointer());
	return Value(new Object_arrayT<UInt8>(env, VTYPE_array_at_uint8, pArrayT.release()));
''' %% {`en,
	R'''
	'''
}

//glGetSeparableFilter(target:GLenum, format:GLenum, type:GLenum, row:GLvoid@, column:GLvoid@, span:GLvoid@):void:map = `unsupport

glGetString(name:GLenum):map {block?} = R'''
	const GLubyte *_rtn = glGetString(name);
	if (_rtn == nullptr) {
		env.SetError(ERR_ValueError, "invalid name");
		return Value::Nil;
	}
	return ReturnValue(env, arg, Value(reinterpret_cast<const char *>(_rtn)));
''' %% {`en,
	R'''
	'''
}

glGetTexEnvfv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetTexEnvfv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetTexEnviv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetTexEnviv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetTexGendv(coord:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLdouble> > _params(new ArrayT<GLdouble>(n));
	GLdouble *params = _params->GetPointer();
	glGetTexGendv(coord, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetTexGenfv(coord:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetTexGenfv(coord, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetTexGeniv(coord:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetTexGeniv(coord, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

//glGetTexImage(target:GLenum, level:GLint, format:GLenum, type:GLenum, pixels:GLvoid@):void:map = `unsupport

glGetTexLevelParameterfv(target:GLenum, level:GLint, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetTexLevelParameterfv(target, level, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetTexLevelParameteriv(target:GLenum, level:GLint, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetTexLevelParameteriv(target, level, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetTexParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetTexParameterfv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glGetTexParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetTexParameteriv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
''' %% {`en,
	R'''
	'''
}

glHint(target:GLenum, mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glHistogram(target:GLenum, width:GLsizei, internalformat:GLenum, sink:GLboolean):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glHistogram(target, width, internalformat, sink);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glIndexMask(mask:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

//glIndexPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glIndexd(c:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexdv(c:GLdouble@:const):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexf(c:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexfv(c:GLfloat@:const):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexi(c:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexiv(c:GLint@:const):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexs(c:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexsv(c:GLshort@:const):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexub(c:GLubyte):void:map = `auto %% {`en,
	R'''
	'''
}

glIndexubv(c:GLubyte@:const):void:map = `auto %% {`en,
	R'''
	'''
}

glInitNames():void = `auto %% {`en,
	R'''
	'''
}

//glInterleavedArrays(format:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glIsEnabled(cap:GLenum):GLboolean:map {block?} = `auto %% {`en,
	R'''
	'''
}

glIsList(list:GLuint):GLboolean:map {block?} = `auto %% {`en,
	R'''
	'''
}

glIsTexture(texture:GLuint):GLboolean:map {block?} = `auto %% {`en,
	R'''
	'''
}

glLightModelf(pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glLightModelfv(pname:GLenum, params:GLfloat@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glLightModeli(pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glLightModeliv(pname:GLenum, params:GLint@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}
	
glLightf(light:GLenum, pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glLightfv(light:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glLighti(light:GLenum, pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glLightiv(light:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glLineStipple(factor:GLint, pattern:GLushort):void:map = `auto %% {`en,
	R'''
	'''
}

glLineWidth(width:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glListBase(base:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

glLoadIdentity():void = `auto %% {`en,
	R'''
	'''
}

glLoadMatrixd(m:GLdouble@matrix:const):void = `auto %% {`en,
	R'''
	'''
}

glLoadMatrixf(m:GLfloat@matrix:const):void = `auto %% {`en,
	R'''
	'''
}

glLoadName(name:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

glLogicOp(opcode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glMap1d(target:GLenum, u1:GLdouble, u2:GLdouble, stride:GLint, order:GLint, points:array@double):void:map = R'''
	glMap1d(target, u1, u2, stride, order, points->GetPointer());
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glMap1f(target:GLenum, u1:GLfloat, u2:GLfloat, stride:GLint, order:GLint, points:array@float):void:map = R'''
	glMap1f(target, u1, u2, stride, order, points->GetPointer());
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glMap2d(target:GLenum, u1:GLdouble, u2:GLdouble, ustride:GLint, uorder:GLint, v1:GLdouble, v2:GLdouble, vstride:GLint, vorder:GLint, points:array@double):void:map = R'''
	glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points->GetPointer());
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glMap2f(target:GLenum, u1:GLfloat, u2:GLfloat, ustride:GLint, uorder:GLint, v1:GLfloat, v2:GLfloat, vstride:GLint, vorder:GLint, points:array@float):void:map = R'''
	glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points->GetPointer());
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glMapGrid1d(un:GLint, u1:GLdouble, u2:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glMapGrid1f(un:GLint, u1:GLfloat, u2:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glMapGrid2d(un:GLint, u1:GLdouble, u2:GLdouble, vn:GLint, v1:GLdouble, v2:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glMapGrid2f(un:GLint, u1:GLfloat, u2:GLfloat, vn:GLint, v1:GLfloat, v2:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glMaterialf(face:GLenum, pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glMaterialfv(face:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glMateriali(face:GLenum, pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glMaterialiv(face:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glMatrixMode(mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glMinmax(target:GLenum, internalformat:GLenum, sink:GLboolean):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glMinmax(target, internalformat, sink);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultMatrixd(m:GLdouble@matrix:const):void = `auto %% {`en,
	R'''
	'''
}

glMultMatrixf(m:GLfloat@matrix:const):void = `auto %% {`en,
	R'''
	'''
}

glNewList(list:GLuint, mode:GLenum):void:map {block?} = R'''
	glNewList(list, mode);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glEndList();
	}
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glNormal3(v:vertex):void:map = R'''
	glNormal3d(v->x, v->y, v->z);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glNormal3b(nx:GLbyte, ny:GLbyte, nz:GLbyte):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3bv(v:GLbyte@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3d(nx:GLdouble, ny:GLdouble, nz:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3dv(v:GLdouble@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3f(nx:GLfloat, ny:GLfloat, nz:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3fv(v:GLfloat@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3i(nx:GLint, ny:GLint, nz:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3iv(v:GLint@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3s(nx:GLshort, ny:GLshort, nz:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glNormal3sv(v:GLshort@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

//glNormalPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glOrtho(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble, zNear:GLdouble, zFar:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glPassThrough(token:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glPixelMapfv(map:GLenum, mapsize:GLint, values:GLfloat@:const):void:map = `auto %% {`en,
	R'''
	'''
}

glPixelMapuiv(map:GLenum, mapsize:GLint, values:GLuint@:const):void:map = `auto %% {`en,
	R'''
	'''
}

glPixelMapusv(map:GLenum, mapsize:GLint, values:GLushort@:const):void:map = `auto %% {`en,
	R'''
	'''
}

glPixelStoref(pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glPixelStorei(pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glPixelTransferf(pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glPixelTransferi(pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glPixelZoom(xfactor:GLfloat, yfactor:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glPointSize(size:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glPolygonMode(face:GLenum, mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glPolygonOffset(factor:GLfloat, units:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glPolygonStipple(mask:array@uint8):void:map = R'''
	if (mask->GetElemNum() != 32 * 4) {
		env.SetError(ERR_ValueError, "mask must contain 32 * 4 elements");
		return Value::Nil;
	}
	glPolygonStipple(mask->GetPointer());
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glPopAttrib():void = `auto %% {`en,
	R'''
	'''
}

glPopClientAttrib():void = `auto %% {`en,
	R'''
	'''
}

glPopMatrix():void = `auto %% {`en,
	R'''
	'''
}

glPopName():void = `auto %% {`en,
	R'''
	'''
}

glPrioritizeTextures(textures:GLuint@:const, priorities:GLclampf@:const):void:map = R'''
	GLsizei n = _textures->GetElemNum();
	if (n != _priorities->GetElemNum()) {
		env.SetError(ERR_ValueError, "textures and priorities must have the same number of elements");
		return Value::Nil;
	}
	glPrioritizeTextures(n, textures, priorities);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glPushAttrib(mask:GLbitfield):void:map {block?} = R'''
	glPushAttrib(mask);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glPopAttrib();
	}
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glPushClientAttrib(mask:GLbitfield):void:map {block?} = R'''
	glPushClientAttrib(mask);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glPopClientAttrib();
	}
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glPushMatrix():void {block?} = R'''
	glPushMatrix();
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glPopMatrix();
	}
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glPushName(name:GLuint):void:map {block?} = R'''
	glPushName(name);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glPopName();
	}
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glRasterPos2d(x:GLdouble, y:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos2dv(v:GLdouble@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos2f(x:GLfloat, y:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos2fv(v:GLfloat@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos2i(x:GLint, y:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos2iv(v:GLint@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos2s(x:GLshort, y:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos2sv(v:GLshort@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos3d(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos3dv(v:GLdouble@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos3f(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos3fv(v:GLfloat@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos3i(x:GLint, y:GLint, z:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos3iv(v:GLint@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos3s(x:GLshort, y:GLshort, z:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos3sv(v:GLshort@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos4d(x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos4dv(v:GLdouble@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos4f(x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos4fv(v:GLfloat@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos4i(x:GLint, y:GLint, z:GLint, w:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos4iv(v:GLint@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos4s(x:GLshort, y:GLshort, z:GLshort, w:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glRasterPos4sv(v:GLshort@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glReadBuffer(mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glReadPixels(x:GLint, y:GLint, width:GLsizei, height:GLsizei, format:symbol):map {block?} = R'''
	Signal &sig = env.GetSignal();
	Image::Format fmt = Image::SymbolToFormat(sig, format);
	if (env.IsSignalled()) return Value::Nil;
	AutoPtr<Image> pImage(new Image(fmt));
	GLenum _format = GetImageFormat(env, pImage.get());
	if (env.IsSignalled()) return Value::Nil;
	if (!pImage->AllocBuffer(sig, width, height, 0xff)) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	glReadPixels(x, y, width, height, _format, type, pImage->GetBuffer());
	return ReturnValue(env, arg, Value(new Object_image(env, pImage.release())));
''' %% {`en,
	R'''
	'''
}

glRectd(x1:GLdouble, y1:GLdouble, x2:GLdouble, y2:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glRectdv(v1:GLdouble@2:const, v2:GLdouble@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRectf(x1:GLfloat, y1:GLfloat, x2:GLfloat, y2:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glRectfv(v1:GLfloat@2:const, v2:GLfloat@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRecti(x1:GLint, y1:GLint, x2:GLint, y2:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glRectiv(v1:GLint@2:const, v2:GLint@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRects(x1:GLshort, y1:GLshort, x2:GLshort, y2:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glRectsv(v1:GLshort@2:const, v2:GLshort@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glRenderMode(mode:GLenum):GLint:map {block?} = `auto %% {`en,
	R'''
	'''
}

glResetHistogram(target:GLenum):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glResetHistogram(target);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glResetMinmax(target:GLenum):void:map = R'''
^#if defined(GL_VERSION_1_2)
^	ImplementGLExtension();
	glResetMinmax(target);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.2");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glRotated(angle:GLdouble, x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glRotatef(angle:GLfloat, x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glScaled(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glScalef(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glScissor(x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = `auto %% {`en,
	R'''
	'''
}

glSelectBuffer(buffer:array@uint32:nil):void = R'''
	if (buffer == nullptr) {
		glSelectBuffer(0, nullptr);
	} else {
		glSelectBuffer(buffer->GetElemNum(), buffer->GetPointer());
	}
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

//glSeparableFilter2D(target:GLenum, internalformat:GLenum, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, row:GLvoid@:const, column:GLvoid@:const):void:map = `unsupport

glShadeModel(mode:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glStencilFunc(func:GLenum, ref:GLint, mask:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

glStencilMask(mask:GLuint):void:map = `auto %% {`en,
	R'''
	'''
}

glStencilOp(fail:GLenum, zfail:GLenum, zpass:GLenum):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord1d(s:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord1dv(v:GLdouble@1:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord1f(s:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord1fv(v:GLfloat@1:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord1i(s:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord1iv(v:GLint@1:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord1s(s:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord1sv(v:GLshort@1:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord2d(s:GLdouble, t:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord2dv(v:GLdouble@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord2f(s:GLfloat, t:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord2fv(v:GLfloat@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord2i(s:GLint, t:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord2iv(v:GLint@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord2s(s:GLshort, t:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord2sv(v:GLshort@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord3d(s:GLdouble, t:GLdouble, r:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord3dv(v:GLdouble@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord3f(s:GLfloat, t:GLfloat, r:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord3fv(v:GLfloat@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord3i(s:GLint, t:GLint, r:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord3iv(v:GLint@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord3s(s:GLshort, t:GLshort, r:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord3sv(v:GLshort@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord4d(s:GLdouble, t:GLdouble, r:GLdouble, q:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord4dv(v:GLdouble@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord4f(s:GLfloat, t:GLfloat, r:GLfloat, q:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord4fv(v:GLfloat@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord4i(s:GLint, t:GLint, r:GLint, q:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord4iv(v:GLint@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord4s(s:GLshort, t:GLshort, r:GLshort, q:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glTexCoord4sv(v:GLshort@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

//glTexCoordPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glTexEnvf(target:GLenum, pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glTexEnvfv(target:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexEnvi(target:GLenum, pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glTexEnviv(target:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexGend(coord:GLenum, pname:GLenum, param:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glTexGendv(coord:GLenum, pname:GLenum, params:GLdouble@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexGenf(coord:GLenum, pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glTexGenfv(coord:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexGeni(coord:GLenum, pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glTexGeniv(coord:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexImage1D(target:GLenum, level:GLint, internalformat:GLint,
			width:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:array):void:map = R'''
	// check pixels->size()
	const void *p = GetArrayTPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glTexImage1D(target, level, internalformat, width, border, format, type, p);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glTexImage1DFromImage(target:GLenum, level:GLint,
			 internalformat:GLint, border:GLint, image:image):void:map = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth()) + border * 2;
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glTexImage2D(target:GLenum, level:GLint, internalformat:GLint,
		width:GLsizei, height:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:array):void:map = R'''
	// check pixels->size()
	const void *p = GetArrayTPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glTexImage2D(target, level, internalformat, width, height, border, format, type, p);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}
	
glTexImage2DFromImage(target:GLenum, level:GLint,
			 internalformat:GLint, border:GLint, image:image):void:map = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth()) + border * 2;
	GLsizei height = static_cast<GLsizei>(image->GetHeight()) + border * 2;
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}
	
//glTexImage3D(target:GLenum, level:GLint, internalformat:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:GLvoid@:const):void:map = `unsupport

glTexParameterf(target:GLenum, pname:GLenum, param:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glTexParameterfv(target:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexParameteri(target:GLenum, pname:GLenum, param:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glTexParameteriv(target:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto %% {`en,
	R'''
	'''
}

glTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint,
			 width:GLsizei, format:GLenum, type:GLenum, pixels:array):void:map = R'''
	// check pixels->size()
	const void *p = GetArrayTPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glTexSubImage1D(target, level, xoffset, width, format, type, p);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glTexSubImage1DFromImage(target:GLenum, level:GLint, xoffset:GLint, image:image):void:map = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint,
		width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, pixels:array):void:map = R'''
	// check pixels->size()
	const void *p = GetArrayTPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, p);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glTexSubImage2DFromImage(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, image:image):void:map = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

//glTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, type:GLenum, pixels:GLvoid@:const):void:map = `unsupport

glTranslated(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glTranslatef(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3(v:vertex):void:map = R'''
	glVertex3d(v->x, v->y, v->z);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glVertex4(v:vertex, w:GLdouble):void:map = R'''
	glVertex4d(v->x, v->y, v->z, w);
	return Value::Nil;
''' %% {`en,
	R'''
	'''
}

glVertex2d(x:GLdouble, y:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex2dv(v:GLdouble@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex2f(x:GLfloat, y:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex2fv(v:GLfloat@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex2i(x:GLint, y:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex2iv(v:GLint@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex2s(x:GLshort, y:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex2sv(v:GLshort@2:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3d(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3dv(v:GLdouble@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3f(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3fv(v:GLfloat@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3i(x:GLint, y:GLint, z:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3iv(v:GLint@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3s(x:GLshort, y:GLshort, z:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex3sv(v:GLshort@3:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex4d(x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex4dv(v:GLdouble@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex4f(x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex4fv(v:GLfloat@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex4i(x:GLint, y:GLint, z:GLint, w:GLint):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex4iv(v:GLint@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex4s(x:GLshort, y:GLshort, z:GLshort, w:GLshort):void:map = `auto %% {`en,
	R'''
	'''
}

glVertex4sv(v:GLshort@4:const):void:map = `auto %% {`en,
	R'''
	'''
}

//glVertexPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glViewport(x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = `auto %% {`en,
	R'''
	'''
}

/*
glSampleCoverage(value:GLclampf, invert:GLboolean):void:map = `auto %% {`en,
	R'''
	'''
}
*/

/*
glLoadTransposeMatrixf(m:GLfloat@matrix:const):void = `auto %% {`en,
	R'''
	'''
}
*/

/*
glLoadTransposeMatrixd(m:GLdouble@matrix:const):void = `auto %% {`en,
	R'''
	'''
}
*/

/*
glMultTransposeMatrixf(m:GLfloat@matrix:const):void = `auto %% {`en,
	R'''
	'''
}
*/

/*
glMultTransposeMatrixd(m:GLdouble@matrix:const):void = `auto %% {`en,
	R'''
	'''
}
*/

//glCompressedTexImage3D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, height:GLsizei, depth:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexImage2D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, height:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexImage1D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, width:GLsizei, height:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, width:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glGetCompressedTexImage(target:GLenum, lod:GLint, img:GLvoid@):void:map = `unsupport

glActiveTexture(texture:GLenum):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glActiveTexture(texture);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glClientActiveTexture(texture:GLenum):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glClientActiveTexture(texture);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord1d(target:GLenum, s:GLdouble):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord1d(target, s);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord1dv(target:GLenum, v:GLdouble@1:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord1dv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord1f(target:GLenum, s:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord1f(target, s);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord1fv(target:GLenum, v:GLfloat@1:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord1fv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord1i(target:GLenum, s:GLint):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord1i(target, s);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord1iv(target:GLenum, v:GLint@1:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord1iv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord1s(target:GLenum, s:GLshort):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord1s(target, s);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord1sv(target:GLenum, v:GLshort@1:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord1sv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord2d(target:GLenum, s:GLdouble, t:GLdouble):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord2d(target, s, t);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord2dv(target:GLenum, v:GLdouble@2:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord2dv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord2f(target:GLenum, s:GLfloat, t:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord2f(target, s, t);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord2fv(target:GLenum, v:GLfloat@2:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord2fv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord2i(target:GLenum, s:GLint, t:GLint):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord2i(target, s, t);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord2iv(target:GLenum, v:GLint@2:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord2iv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord2s(target:GLenum, s:GLshort, t:GLshort):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord2s(target, s, t);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord2sv(target:GLenum, v:GLshort@2:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord2sv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord3d(target:GLenum, s:GLdouble, t:GLdouble, r:GLdouble):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord3d(target, s, t, r);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord3dv(target:GLenum, v:GLdouble@3:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord3dv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord3f(target:GLenum, s:GLfloat, t:GLfloat, r:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord3f(target, s, t, r);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord3fv(target:GLenum, v:GLfloat@3:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord3fv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord3i(target:GLenum, s:GLint, t:GLint, r:GLint):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord3i(target, s, t, r);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord3iv(target:GLenum, v:GLint@3:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord3iv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord3s(target:GLenum, s:GLshort, t:GLshort, r:GLshort):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord3s(target, s, t, r);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord3sv(target:GLenum, v:GLshort@3:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord3sv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord4d(target:GLenum, s:GLdouble, t:GLdouble, r:GLdouble, q:GLdouble):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord4d(target, s, t, r, q);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord4dv(target:GLenum, v:GLdouble@4:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord4dv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord4f(target:GLenum, s:GLfloat, t:GLfloat, r:GLfloat, q:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord4f(target, s, t, r, q);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord4fv(target:GLenum, v:GLfloat@4:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord4fv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord4i(target:GLenum, s:GLint, t:GLint, r:GLint, q:GLint):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord4i(target, s, t, r, q);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord4iv(target:GLenum, v:GLint@4:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord4iv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord4s(target:GLenum, s:GLshort, t:GLshort, r:GLshort, q:GLshort):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord4s(target, s, t, r, q);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiTexCoord4sv(target:GLenum, v:GLshort@4:const):void:map = R'''
^#if defined(GL_VERSION_1_3)
^	ImplementGLExtension();
	glMultiTexCoord4sv(target, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.3");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}
	
glFogCoordf(coord:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glFogCoordf(coord);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glFogCoordfv(coord:GLfloat@1:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glFogCoordfv(coord);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glFogCoordd(coord:GLdouble):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glFogCoordd(coord);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glFogCoorddv(coord:GLdouble@1:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glFogCoorddv(coord);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

//glFogCoordPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glSecondaryColor3b(red:GLbyte, green:GLbyte, blue:GLbyte):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3b(red, green, blue);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3bv(v:GLbyte@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3bv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3d(red:GLdouble, green:GLdouble, blue:GLdouble):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3d(red, green, blue);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3dv(v:GLdouble@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3dv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3f(red:GLfloat, green:GLfloat, blue:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3f(red, green, blue);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3fv(v:GLfloat@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3fv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3i(red:GLint, green:GLint, blue:GLint):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3i(red, green, blue);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3iv(v:GLint@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3iv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3s(red:GLshort, green:GLshort, blue:GLshort):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3s(red, green, blue);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3sv(v:GLshort@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3sv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3ub(red:GLubyte, green:GLubyte, blue:GLubyte):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3ub(red, green, blue);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3ubv(v:GLubyte@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3ubv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3ui(red:GLuint, green:GLuint, blue:GLuint):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3ui(red, green, blue);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3uiv(v:GLuint@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3uiv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3us(red:GLushort, green:GLushort, blue:GLushort):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3us(red, green, blue);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glSecondaryColor3usv(v:GLushort@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glSecondaryColor3usv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

//glSecondaryColorPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glPointParameterf(pname:GLenum, param:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glPointParameterf(pname, param);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glPointParameterfv(pname:GLenum, params:GLfloat@pname:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glPointParameterfv(pname, params);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glPointParameteri(pname:GLenum, param:GLint):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glPointParameteri(pname, param);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glPointParameteriv(pname:GLenum, params:GLint@pname:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glPointParameteriv(pname, params);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glBlendFuncSeparate(srcRGB:GLenum, dstRGB:GLenum, srcAlpha:GLenum, dstAlpha:GLenum):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glMultiDrawArrays(mode:GLenum, first:GLint@:const, count:GLsizei@:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	GLsizei primcount = _first->GetElemNum();
	if (primcount != _count->GetElemNum()) {
		env.SetError(ERR_ValueError, "first and count must have the same number of elements");
		return Value::Nil;
	}
	glMultiDrawArrays(mode, first, count, primcount);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

//glMultiDrawElements(mode:GLenum, count:GLsizei@:const, type:GLenum, indices:GLvoid@:const@:const, primcount:GLsizei):void:map = `unsupport

glWindowPos2d(x:GLdouble, y:GLdouble):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos2d(x, y);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos2dv(v:GLdouble@2:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos2dv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos2f(x:GLfloat, y:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos2f(x, y);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos2fv(v:GLfloat@2:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos2fv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos2i(x:GLint, y:GLint):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos2i(x, y);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos2iv(v:GLint@2:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos2iv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos2s(x:GLshort, y:GLshort):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos2s(x, y);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos2sv(v:GLshort@2:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos2sv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos3d(x:GLdouble, y:GLdouble, z:GLdouble):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos3d(x, y, z);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos3dv(v:GLdouble@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos3dv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos3f(x:GLfloat, y:GLfloat, z:GLfloat):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos3f(x, y, z);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos3fv(v:GLfloat@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos3fv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos3i(x:GLint, y:GLint, z:GLint):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos3i(x, y, z);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos3iv(v:GLint@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos3iv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos3s(x:GLshort, y:GLshort, z:GLshort):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos3s(x, y, z);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glWindowPos3sv(v:GLshort@3:const):void:map = R'''
^#if defined(GL_VERSION_1_4)
^	ImplementGLExtension();
	glWindowPos3sv(v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.4");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGenQueries(n:GLsizei):map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	AutoPtr<ArrayT<GLuint> > _ids(new ArrayT<GLuint>(n));
	GLuint *ids = _ids->GetPointer();
	glGenQueries(n, ids);
	return ReturnValue(env, arg, Value::CreateList(env, ids, n));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glDeleteQueries(ids:GLuint@:const):void:map = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	GLsizei n = _ids->GetElemNum();
	glDeleteQueries(n, ids);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glIsQuery(id:GLuint):GLboolean:map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	GLboolean _rtn = glIsQuery(id);
	return ReturnValue(env, arg, Value(_rtn == GL_TRUE));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glBeginQuery(target:GLenum, id:GLuint):void:map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	glBeginQuery(target, id);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glEndQuery(target);
	}
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glEndQuery(target:GLenum):void:map = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	glEndQuery(target);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetQueryiv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetQueryiv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetQueryObjectiv(id:GLuint, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetQueryObjectiv(id, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetQueryObjectuiv(id:GLuint, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLuint> > _params(new ArrayT<GLuint>(n));
	GLuint *params = _params->GetPointer();
	glGetQueryObjectuiv(id, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}
	
glBindBuffer(target:GLenum, buffer:GLuint):void:map = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	glBindBuffer(target, buffer);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glDeleteBuffers(buffers:GLuint@:const):void:map = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	GLsizei n = _buffers->GetElemNum();
	glDeleteBuffers(n, buffers);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGenBuffers(n:GLsizei):map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	AutoPtr<ArrayT<GLuint> > _buffers(new ArrayT<GLuint>(n));
	GLuint *buffers = _buffers->GetPointer();
	glGenBuffers(n, buffers);
	return Value::CreateList(env, buffers, n);
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glIsBuffer(buffer:GLuint):GLboolean:map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	GLboolean _rtn = glIsBuffer(buffer);
	return ReturnValue(env, arg, Value(_rtn == GL_TRUE));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glBufferData(target:GLenum, size:GLsizeiptr, data:memory:nil, usage:GLenum):void:map = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	if (data != nullptr && data->GetSize() < size) {
		env.SetError(ERR_ValueError, "allocated memory for data is smaller than the specified size");
		return Value::Nil;
	}
	glBufferData(target, size, (data == nullptr)? nullptr : data->GetPointer(), usage);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

//glBufferSubData(target:GLenum, offset:GLintptr, size:GLsizeiptr, data:GLvoid@:const):void:map = `unsupport

//glGetBufferSubData(target:GLenum, offset:GLintptr, size:GLsizeiptr, data:GLvoid@):void:map = `unsupport

glMapBuffer(target:GLenum, access:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	GLsizei bufSize = 0;
	glGetBufferParameteriv(target, GL_BUFFER_SIZE, &bufSize);
	void *_rtn = glMapBuffer(target, access);
	return ReturnValue(env, arg, Value(new Object_memory(env, new Memory(bufSize, _rtn))));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUnmapBuffer(target:GLenum):GLboolean:map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	GLboolean _rtn = glUnmapBuffer(target);
	return ReturnValue(env, arg, Value(_rtn == GL_TRUE));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetBufferParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_1_5)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetBufferParameteriv(target, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

//glGetBufferPointerv(target:GLenum, pname:GLenum, params:GLvoid@@):void:map = `unsupport

glDrawBuffers(bufs:GLenum@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei n = _bufs->GetElemNum();
	glDrawBuffers(n, bufs);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "1.5");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib1d(index:GLuint, x:GLdouble):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib1d(index, x);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib1dv(index:GLuint, v:GLdouble@1:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib1dv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib1f(index:GLuint, x:GLfloat):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib1f(index, x);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib1fv(index:GLuint, v:GLfloat@1:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib1fv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib1s(index:GLuint, x:GLshort):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib1s(index, x);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib1sv(index:GLuint, v:GLshort@1:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib1sv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib2d(index:GLuint, x:GLdouble, y:GLdouble):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib2d(index, x, y);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib2dv(index:GLuint, v:GLdouble@2:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib2dv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib2f(index:GLuint, x:GLfloat, y:GLfloat):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib2f(index, x, y);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib2fv(index:GLuint, v:GLfloat@2:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib2fv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib2s(index:GLuint, x:GLshort, y:GLshort):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib2s(index, x, y);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib2sv(index:GLuint, v:GLshort@2:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib2sv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib3d(index:GLuint, x:GLdouble, y:GLdouble, z:GLdouble):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib3d(index, x, y, z);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib3dv(index:GLuint, v:GLdouble@3:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib3dv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib3f(index:GLuint, x:GLfloat, y:GLfloat, z:GLfloat):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib3f(index, x, y, z);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib3fv(index:GLuint, v:GLfloat@3:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib3fv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib3s(index:GLuint, x:GLshort, y:GLshort, z:GLshort):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib3s(index, x, y, z);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib3sv(index:GLuint, v:GLshort@3:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib3sv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4Nbv(index:GLuint, v:GLbyte@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4Nbv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4Niv(index:GLuint, v:GLint@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4Niv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4Nsv(index:GLuint, v:GLshort@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4Nsv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4Nub(index:GLuint, x:GLubyte, y:GLubyte, z:GLubyte, w:GLubyte):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4Nub(index, x, y, z, w);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4Nubv(index:GLuint, v:GLubyte@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4Nubv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4Nuiv(index:GLuint, v:GLuint@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4Nuiv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4Nusv(index:GLuint, v:GLushort@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4Nusv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4bv(index:GLuint, v:GLbyte@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4bv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4d(index:GLuint, x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4d(index, x, y, z, w);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4dv(index:GLuint, v:GLdouble@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4dv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4f(index:GLuint, x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4f(index, x, y, z, w);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4fv(index:GLuint, v:GLfloat@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4fv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4iv(index:GLuint, v:GLint@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4iv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4s(index:GLuint, x:GLshort, y:GLshort, z:GLshort, w:GLshort):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4s(index, x, y, z, w);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4sv(index:GLuint, v:GLshort@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4sv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4ubv(index:GLuint, v:GLubyte@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4ubv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4uiv(index:GLuint, v:GLuint@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4uiv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttrib4usv(index:GLuint, v:GLushort@4:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttrib4usv(index, v);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glVertexAttribPointer(index:GLuint, size:GLint, type:GLenum, normalized:GLboolean, stride:GLsizei, pointer:memory:nil):void = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glVertexAttribPointer(index, size, type, normalized, stride,
						(pointer == nullptr)? nullptr : pointer->GetPointer());
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glEnableVertexAttribArray(index:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glEnableVertexAttribArray(index);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glDisableVertexAttribArray(index:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glDisableVertexAttribArray(index);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetVertexAttribdv(index:GLuint, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLdouble> > _params(new ArrayT<GLdouble>(n));
	GLdouble *params = _params->GetPointer();
	glGetVertexAttribdv(index, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetVertexAttribfv(index:GLuint, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLfloat> > _params(new ArrayT<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetVertexAttribfv(index, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetVertexAttribiv(index:GLuint, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetVertexAttribiv(index, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

//glGetVertexAttribPointerv(index:GLuint, pname:GLenum, pointer:GLvoid@@):void:map = `unsupport

glDeleteShader(shader:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glDeleteShader(shader);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glDetachShader(program:GLuint, shader:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glDetachShader(program, shader);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCreateShader(type:GLenum):GLuint:map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLuint _rtn = glCreateShader(type);
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glShaderSource(shader:GLuint, string[]:string):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = static_cast<GLsizei>(string.size());
	const GLchar **_string = new const GLchar *[count];
	//GLint *length = new GLint[count];
	GLint *length = nullptr;
	for (GLint i = 0; i < count; i++) {
		_string[i] = reinterpret_cast<const GLchar *>(string[i].GetString());
		//length[i] = static_cast<GLint>(string[i].GetStringSTL().size());
	}
	glShaderSource(shader, count, _string, length);
	delete[] _string;
	delete[] length;
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCompileShader(shader:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glCompileShader(shader);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glCreateProgram():GLuint {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLuint _rtn = glCreateProgram();
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glAttachShader(program:GLuint, shader:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glAttachShader(program, shader);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glLinkProgram(program:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glLinkProgram(program);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUseProgram(program:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUseProgram(program);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glDeleteProgram(program:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glDeleteProgram(program);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glValidateProgram(program:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glValidateProgram(program);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform1f(location:GLint, v0:GLfloat):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUniform1f(location, v0);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform2f(location:GLint, v0:GLfloat, v1:GLfloat):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUniform2f(location, v0, v1);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform3f(location:GLint, v0:GLfloat, v1:GLfloat, v2:GLfloat):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUniform3f(location, v0, v1, v2);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform4f(location:GLint, v0:GLfloat, v1:GLfloat, v2:GLfloat, v3:GLfloat):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUniform4f(location, v0, v1, v2, v3);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform1i(location:GLint, v0:GLint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUniform1i(location, v0);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform2i(location:GLint, v0:GLint, v1:GLint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUniform2i(location, v0, v1);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform3i(location:GLint, v0:GLint, v1:GLint, v2:GLint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUniform3i(location, v0, v1, v2);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform4i(location:GLint, v0:GLint, v1:GLint, v2:GLint, v3:GLint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glUniform4i(location, v0, v1, v2, v3);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform1fv(location:GLint, value:GLfloat@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum();
	glUniform1fv(location, count, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform2fv(location:GLint, value:GLfloat@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / 2;
	glUniform2fv(location, count, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform3fv(location:GLint, value:GLfloat@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / 3;
	glUniform3fv(location, count, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform4fv(location:GLint, value:GLfloat@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / 4;
	glUniform4fv(location, count, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform1iv(location:GLint, value:GLint@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum();
	glUniform1iv(location, count, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform2iv(location:GLint, value:GLint@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / 2;
	glUniform2iv(location, count, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform3iv(location:GLint, value:GLint@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / 3;
	glUniform3iv(location, count, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniform4iv(location:GLint, value:GLint@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / 4;
	glUniform4iv(location, count, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniformMatrix2fv(location:GLint, transpose:GLboolean, value:GLfloat@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / (2 * 2);
	glUniformMatrix2fv(location, count, transpose, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniformMatrix3fv(location:GLint, transpose:GLboolean, value:GLfloat@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / (3 * 3);
	glUniformMatrix3fv(location, count, transpose, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniformMatrix4fv(location:GLint, transpose:GLboolean, value:GLfloat@:const):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei count = _value->GetElemNum() / (4 * 4);
	glUniformMatrix4fv(location, count, transpose, value);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glIsShader(shader:GLuint):GLboolean:map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	bool _rtn = glIsShader(shader);
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glIsProgram(program:GLuint):GLboolean:map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	bool _rtn = glIsProgram(program);
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetShaderiv(shader:GLuint, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetShaderiv(shader, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetProgramiv(program:GLuint, pname:GLenum):map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	size_t n = GetParamCount(pname);
	AutoPtr<ArrayT<GLint> > _params(new ArrayT<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetProgramiv(program, pname, params);
	return ReturnValue(env, arg, CreateValueFromParams(env, params, n));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetAttachedShaders(program:GLuint, maxCount:GLsizei, count:GLsizei@, shaders:GLuint@):void:map = `unsupport %% {`en,
	R'''
	'''
}

glGetShaderInfoLog(shader:GLuint):map {block?} = '''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	String _rtn;	
	GLsizei bufSize = 0;
	glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &bufSize);
	if (bufSize > 0) {
		GLsizei length = 0;
		GLchar *infoLog = new GLchar[bufSize];
		glGetShaderInfoLog(shader, bufSize, &length, infoLog);
		_rtn = infoLog;
		delete[] infoLog;
	}
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetProgramInfoLog(program:GLuint):map {block?} = '''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	String _rtn;	
	GLsizei bufSize = 0;
	glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufSize);
	if (bufSize > 0) {
		GLsizei length = 0;
		GLchar *infoLog = new GLchar[bufSize];
		glGetProgramInfoLog(program, bufSize, &length, infoLog);
		_rtn = infoLog;
		delete[] infoLog;
	}
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetUniformLocation(program:GLuint, name:string):GLint:map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLint _rtn = glGetUniformLocation(program, name);
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetActiveUniform(program:GLuint, index:GLuint):map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLsizei bufSize = GL_ACTIVE_UNIFORM_MAX_LENGTH;
	GLsizei length;
	GLint size;
	GLenum type;
	GLchar name[GL_ACTIVE_UNIFORM_MAX_LENGTH];
	glGetActiveUniform(program, index, bufSize, &length, &size, &type, name);
	return ReturnValue(env, arg, Value::CreateList(env, Value(size), Value(type), Value(name)));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetUniformfv(program:GLuint, location:GLint, params:GLfloat@):void:map = `unsupport %% {`en,
	R'''
	'''
}

glGetUniformiv(program:GLuint, location:GLint, params:GLint@):void:map = `unsupport %% {`en,
	R'''
	'''
}

glGetShaderSource(shader:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	String _rtn;
	GLsizei bufSize = 0;
	glGetShaderiv(shader, GL_SHADER_SOURCE_LENGTH, &bufSize);
	if (bufSize > 0) {
		GLchar *source = new GLchar[bufSize];
		glGetShaderSource(shader, bufSize, nullptr, source);
		_rtn = source;
		delete[] source;
	}
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glBindAttribLocation(program:GLuint, index:GLuint, name:string):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glBindAttribLocation(program, index, name);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetActiveAttrib(program:GLuint, index:GLuint):map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLint size = 0;
	GLenum type;
	String _name;
	GLsizei bufSize = 0;
	glGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &bufSize);
	if (bufSize > 0) {
		GLchar *name = new GLchar[bufSize];
		glGetActiveAttrib(program, index, bufSize, nullptr, &size, &type, name);
		_name = name;
		delete[] name;
	}
	return ReturnValue(env, arg, Value::CreateList(env, Value(size), Value(type), Value(_name)));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glGetAttribLocation(program:GLuint, name:string):GLint:map {block?} = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	GLint _rtn = glGetAttribLocation(program, name);
	return ReturnValue(env, arg, Value(_rtn));
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glStencilFuncSeparate(face:GLenum, func:GLenum, ref:GLint, mask:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glStencilFuncSeparate(face, func, ref, mask);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glStencilOpSeparate(face:GLenum, fail:GLenum, zfail:GLenum, zpass:GLenum):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glStencilOpSeparate(face, fail, zfail, zpass);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glStencilMaskSeparate(face:GLenum, mask:GLuint):void:map = R'''
^#if defined(GL_VERSION_2_0)
^	ImplementGLExtension();
	glStencilMaskSeparate(face, mask);
	return Value::Nil;
#else
	SetError_RequiredGLVersion(env, "2.0");
	return Value::Nil;
#endif
''' %% {`en,
	R'''
	'''
}

glUniformMatrix2x3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport %% {`en,
	R'''
	'''
}

glUniformMatrix3x2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport %% {`en,
	R'''
	'''
}

glUniformMatrix2x4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport %% {`en,
	R'''
	'''
}

glUniformMatrix4x2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport %% {`en,
	R'''
	'''
}

glUniformMatrix3x4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport %% {`en,
	R'''
	'''
}

glUniformMatrix4x3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport %% {`en,
	R'''
	'''
}

}

tmplSource = R"""
// Don't edit this file. This has been generated by Functions.cpp.gura.
#include "stdafx.h"

#if defined(GURA_ON_MSWIN)
typedef char GLchar;
#endif

Gura_BeginModuleScope(${renderer.moduleName})

${renderer.RenderImplementation()}

void AssignFunctions(Environment &env)
{
	${renderer.RenderAssignment()}
}

Gura_EndModuleScope(${renderer.moduleName})
""".template()

cbridge_gl.Renderer('opengl', nil).Render(tmplSource, 'Functions.cpp')
