#!/usr/bin/env gura
import(modimp) {TypeConv, Renderer}

decls = `{
glAccum(op:GLenum, value:GLfloat):void = `auto

glAlphaFunc(func:GLenum, ref:GLclampf):void = `auto

glAreTexturesResident(textures:GLuint@:const):GLboolean:map {block?} = R'''
	GLsizei n = textures.GetSize();
	CArray<GLboolean> residences(n);
	GLboolean _rtn = glAreTexturesResident(n, textures, residences);
	if (_rtn == 0) return Value::Null;
	Value _rtnVal;
	ValueList &valList = _rtnVal.InitAsList(env, n);
	for (GLsizei i = 0; i < n; i++) {
		valList.push_back(residences[i] != 0);
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

glArrayElement(i:GLint):void = `auto

glBegin(mode:GLenum):void {block?} = R'''
	glBegin(mode);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		glEnd();
	}
	return Value::Null;
'''

glBindTexture(target:GLenum, texture:GLuint):void = `auto

glBitmap(width:GLsizei, height:GLsizei, xorig:GLfloat, yorig:GLfloat, xmove:GLfloat, ymove:GLfloat, bitmap:binary):void = R'''
	size_t bytesReq = ((width + 7) / 8) * height;
	if (bytesReq < bitmap.size()) {
		sig.SetError(ERR_ValueError, "binary doesn\'t contain enough data");
		return Value::Null;
	}
	glBitmap(width, height, xorig, yorig, xmove, ymove,
			 reinterpret_cast<const GLubyte *>(bitmap.data()));
	return Value::Null;
'''

glBlendColor(red:GLclampf, green:GLclampf, blue:GLclampf, alpha:GLclampf):void = `auto

glBlendEquation(mode:GLenum):void = `auto

glBlendEquationSeparate(modeRGB:GLenum, modeAlpha:GLenum):void = `auto

glBlendFunc(sfactor:GLenum, dfactor:GLenum):void = `auto

glCallList(list:GLuint):void = `auto

glCallLists(type:GLenum, lists[]:number):void = R'''
	const ValueList &lists_in = args.GetList(1);
	GLsizei n = static_cast<GLsizei>(lists.size());
	AutoPtr<Memory> pListsBuff;
	if (type == GL_BYTE) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLbyte) * n));
		GLbyte *p = reinterpret_cast<GLbyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetChar(); }
	} else if (type == GL_UNSIGNED_BYTE) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUChar(); }
	} else if (type == GL_SHORT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLshort) * n));
		GLshort *p = reinterpret_cast<GLshort *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetShort(); }
	} else if (type == GL_UNSIGNED_SHORT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLushort) * n));
		GLushort *p = reinterpret_cast<GLushort *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUShort(); }
	} else if (type == GL_INT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLint) * n));
		GLint *p = reinterpret_cast<GLint *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetInt(); }
	} else if (type == GL_UNSIGNED_INT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLuint) * n));
		GLuint *p = reinterpret_cast<GLuint *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUInt(); }
	} else if (type == GL_FLOAT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLfloat) * n));
		GLfloat *p = reinterpret_cast<GLfloat *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetFloat(); }
	} else if (type == GL_2_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 2 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			UShort num = pValue->GetUShort();
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else if (type == GL_3_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 3 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			ULong num = pValue->GetULong();
			*p++ = static_cast<GLubyte>(num >> 16);
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else if (type == GL_4_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 4 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			ULong num = pValue->GetULong();
			*p++ = static_cast<GLubyte>(num >> 24);
			*p++ = static_cast<GLubyte>(num >> 16);
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else {
		sig.SetError(ERR_ValueError, "invalid type specification");
		return Value::Null;
	}
	// GLsizei n, GLenum type, const GLvoid *lists
	glCallLists(n, type, pListsBuff->GetPointer());
	return Value::Null;
'''

glClear(mask:GLbitfield):void = `auto

glClearAccum(red:GLfloat, green:GLfloat, blue:GLfloat, alpha:GLfloat):void = `auto

glClearColor(red:GLclampf, green:GLclampf, blue:GLclampf, alpha:GLclampf):void = `auto

glClearDepth(depth:GLclampd):void = `auto

glClearIndex(c:GLfloat):void = `auto

glClearStencil(s:GLint):void = `auto

glClipPlane(plane:GLenum) {block?} = R'''
	GLdouble equation[4];
	glGetClipPlane(plane, equation);
	return Value::CreateList(env, equation, ArraySizeOf(equation));
'''

glColor3b(red:GLbyte, green:GLbyte, blue:GLbyte):void = `auto

glColor3bv(v:GLbyte@3:const):void = `auto

glColor3d(red:GLdouble, green:GLdouble, blue:GLdouble):void = `auto

glColor3dv(v:GLdouble@3:const):void = `auto

glColor3f(red:GLfloat, green:GLfloat, blue:GLfloat):void = `auto

glColor3fv(v:GLfloat@3:const):void = `auto

glColor3i(red:GLint, green:GLint, blue:GLint):void = `auto

glColor3iv(v:GLint@3:const):void = `auto

glColor3s(red:GLshort, green:GLshort, blue:GLshort):void = `auto

glColor3sv(v:GLshort@3:const):void = `auto

glColor3ub(red:GLubyte, green:GLubyte, blue:GLubyte):void = `auto

glColor3ubv(v:GLubyte@3:const):void = `auto

glColor3ui(red:GLuint, green:GLuint, blue:GLuint):void = `auto

glColor3uiv(v:GLuint@3:const):void = `auto

glColor3us(red:GLushort, green:GLushort, blue:GLushort):void = `auto

glColor3usv(v:GLushort@3:const):void = `auto

glColor4b(red:GLbyte, green:GLbyte, blue:GLbyte, alpha:GLbyte):void = `auto

glColor4bv(v:GLbyte@4:const):void = `auto

glColor4d(red:GLdouble, green:GLdouble, blue:GLdouble, alpha:GLdouble):void = `auto

glColor4dv(v:GLdouble@4:const):void = `auto

glColor4f(red:GLfloat, green:GLfloat, blue:GLfloat, alpha:GLfloat):void = `auto

glColor4fv(v:GLfloat@4:const):void = `auto

glColor4i(red:GLint, green:GLint, blue:GLint, alpha:GLint):void = `auto

glColor4iv(v:GLint@4:const):void = `auto

glColor4s(red:GLshort, green:GLshort, blue:GLshort, alpha:GLshort):void = `auto

glColor4sv(v:GLshort@4:const):void = `auto

glColor4ub(red:GLubyte, green:GLubyte, blue:GLubyte, alpha:GLubyte):void = `auto

glColor4ubv(v:GLubyte@4:const):void = `auto

glColor4ui(red:GLuint, green:GLuint, blue:GLuint, alpha:GLuint):void = `auto

glColor4uiv(v:GLuint@4:const):void = `auto

glColor4us(red:GLushort, green:GLushort, blue:GLushort, alpha:GLushort):void = `auto

glColor4usv(v:GLushort@4:const):void = `auto

glColorMask(red:GLboolean, green:GLboolean, blue:GLboolean, alpha:GLboolean):void = `auto

glColorMaterial(face:GLenum, mode:GLenum):void = `auto

//glColorPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

//glColorSubTable(target:GLenum, start:GLsizei, count:GLsizei, format:GLenum, type:GLenum, data:GLvoid@:const):void = `unsupport

//glColorTable(target:GLenum, internalformat:GLenum, width:GLsizei, format:GLenum, type:GLenum, table:GLvoid@:const):void = `unsupport

glColorTableParameterfv(target:GLenum, pname:GLenum, params:GLfloat@:const):void = R'''
	glColorTableParameterfv(target, pname, params);
	return Value::Null;
'''
	
glColorTableParameteriv(target:GLenum, pname:GLenum, params:GLint@:const):void = R'''
	glColorTableParameteriv(target, pname, params);
	return Value::Null;
'''

//glConvolutionFilter1D(target:GLenum, internalformat:GLenum, width:GLsizei, format:GLenum, type:GLenum, image:GLvoid@:const):void = `unsupport

//glConvolutionFilter2D(target:GLenum, internalformat:GLenum, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, image:GLvoid@:const):void = `unsupport

glConvolutionParameterf(target:GLenum, pname:GLenum, params:GLfloat):void = `auto

glConvolutionParameterfv(target:GLenum, pname:GLenum, params:GLfloat@:const):void = R'''
	glColorTableParameterfv(target, pname, params);
	return Value::Null;
'''

glConvolutionParameteri(target:GLenum, pname:GLenum, params:GLint):void = `auto

glConvolutionParameteriv(target:GLenum, pname:GLenum, params:GLint@:const):void = R'''
	glColorTableParameteriv(target, pname, params);
	return Value::Null;
'''

glCopyColorSubTable(target:GLenum, start:GLsizei, x:GLint, y:GLint, width:GLsizei):void = `auto

glCopyColorTable(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei):void = `auto

glCopyConvolutionFilter1D(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei):void = `auto

glCopyConvolutionFilter2D(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void = `auto

glCopyPixels(x:GLint, y:GLint, width:GLsizei, height:GLsizei, type:GLenum):void = `auto

glCopyTexImage1D(target:GLenum, level:GLint, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, border:GLint):void = `auto

glCopyTexImage2D(target:GLenum, level:GLint, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, height:GLsizei, border:GLint):void = `auto

glCopyTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, x:GLint, y:GLint, width:GLsizei):void = `auto

glCopyTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void = `auto

glCopyTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void = `auto

glCullFace(mode:GLenum):void = `auto

glDeleteLists(list:GLuint, range:GLsizei):void = `auto

glDeleteTextures(textures:GLuint@:const):void = R'''
	GLsizei n = textures.GetSize();
	glDeleteTextures(n, textures);
	return Value::Null;
'''

glDepthFunc(func:GLenum):void = `auto

glDepthMask(flag:GLboolean):void = `auto

glDepthRange(zNear:GLclampd, zFar:GLclampd):void = `auto

glDisable(cap:GLenum):void = `auto

glDisableClientState(array:GLenum):void = `auto

glDrawArrays(mode:GLenum, first:GLint, count:GLsizei):void = `auto

glDrawBuffer(mode:GLenum):void = `auto

//glDrawElements(mode:GLenum, count:GLsizei, type:GLenum, indices:GLvoid@:const):void = `unsupport

glDrawPixels(image:image):void = R'''	
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = GetImageFormat(sig, image);
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = image->GetBuffer();
	// GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels
	glDrawPixels(width, height, format, type, pixels);
	return Value::Null;
'''

//glDrawRangeElements(mode:GLenum, start:GLuint, end:GLuint, count:GLsizei, type:GLenum, indices:GLvoid@:const):void = `unsupport

glEdgeFlag(flag:GLboolean):void = `auto

//glEdgeFlagPointer(stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glEdgeFlagv(flag:GLboolean@1:const):void = `auto

glEnable(cap:GLenum):void = `auto

glEnableClientState(array:GLenum):void = `auto

glEnd():void = `auto

glEndList():void = `auto

glEvalCoord1d(u:GLdouble):void = `auto

glEvalCoord1dv(u:GLdouble@1:const):void = `auto

glEvalCoord1f(u:GLfloat):void = `auto

glEvalCoord1fv(u:GLfloat@1:const):void = `auto

glEvalCoord2d(u:GLdouble, v:GLdouble):void = `auto

glEvalCoord2dv(u:GLdouble@2:const):void = `auto

glEvalCoord2f(u:GLfloat, v:GLfloat):void = `auto

glEvalCoord2fv(u:GLfloat@2:const):void = `auto

glEvalMesh1(mode:GLenum, i1:GLint, i2:GLint):void = `auto

glEvalMesh2(mode:GLenum, i1:GLint, i2:GLint, j1:GLint, j2:GLint):void = `auto

glEvalPoint1(i:GLint):void = `auto

glEvalPoint2(i:GLint, j:GLint):void = `auto

glFeedbackBuffer(size:GLsizei, type:GLenum, buffer:GLfloat@):void = `auto

glFinish():void = `auto

glFlush():void = `auto

glFogf(pname:GLenum, param:GLfloat):void = `auto

glFogfv(pname:GLenum, params:GLfloat@:const):void = R'''
	glFogfv(pname, params);
	return Value::Null;
'''

glFogi(pname:GLenum, param:GLint):void = `auto

glFogiv(pname:GLenum, params:GLint@:const):void = R'''
	glFogiv(pname, params);
	return Value::Null;
'''

glFrontFace(mode:GLenum):void = `auto

glFrustum(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble, zNear:GLdouble, zFar:GLdouble):void = `auto

glGenLists(range:GLsizei):GLuint {block?} = `auto

glGenTextures(n:GLsizei) {block?} = R'''
	CArray<GLuint> textures(n);
	glGenTextures(n, textures);
	return Value::CreateList(env, textures, n);
'''

glGetBooleanv(pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLboolean> params(n);
	glGetBooleanv(pname, params);
	Value _rtnVal;
	ValueList &valList = _rtnVal.InitAsList(env, n);
	for (GLsizei i = 0; i < n; i++) {
		valList.push_back(params[i] != 0);
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

glGetClipPlane(plane:GLenum) = R'''
	GLdouble equation[4];
	glGetClipPlane(plane, equation);
	return ReturnValue(env, sig, args, Value::CreateList(env, equation, ArraySizeOf(equation)));
'''

//glGetColorTable(target:GLenum, format:GLenum, type:GLenum, table:GLvoid@):void = `unsupport

glGetColorTableParameterfv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetColorTableParameterfv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetColorTableParameteriv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetColorTableParameteriv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

//glGetConvolutionFilter(target:GLenum, format:GLenum, type:GLenum, image:GLvoid@):void = `unsupport

glGetConvolutionParameterfv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetColorTableParameterfv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetConvolutionParameteriv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetColorTableParameteriv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetDoublev(pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLdouble> params(n);
	glGetDoublev(pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetError():GLenum {block?} = `auto

glGetFloatv(pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetFloatv(pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

//glGetHistogram(target:GLenum, reset:GLboolean, format:GLenum, type:GLenum, values:GLvoid@):void = `unsupport

glGetHistogramParameterfv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetHistogramParameterfv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetHistogramParameteriv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetHistogramParameteriv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetIntegerv(pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetIntegerv(pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetLightfv(light:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetLightfv(light, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetLightiv(light:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetLightiv(light, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetMapdv(target:GLenum, query:GLenum, v:GLdouble@):void = `unsupport

glGetMapfv(target:GLenum, query:GLenum, v:GLfloat@):void = `unsupport

glGetMapiv(target:GLenum, query:GLenum, v:GLint@):void = `unsupport

glGetMaterialfv(face:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetMaterialfv(face, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetMaterialiv(face:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetMaterialiv(face, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

//glGetMinmax(target:GLenum, reset:GLboolean, format:GLenum, type:GLenum, values:GLvoid@):void = `unsupport

glGetMinmaxParameterfv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetMinmaxParameterfv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetMinmaxParameteriv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetHistogramParameteriv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetPixelMapfv(map:GLenum, values:GLfloat@):void = `unsupport

glGetPixelMapuiv(map:GLenum, values:GLuint@):void = `unsupport

glGetPixelMapusv(map:GLenum, values:GLushort@):void = `unsupport

//glGetPointerv(pname:GLenum, params:GLvoid@@):void = `unsupport

glGetPolygonStipple(mask:GLubyte@):void = `unsupport

//glGetSeparableFilter(target:GLenum, format:GLenum, type:GLenum, row:GLvoid@, column:GLvoid@, span:GLvoid@):void = `unsupport

glGetString(name:GLenum) {block?} = R'''
	const GLubyte *_rtn = glGetString(name);
	if (_rtn == NULL) {
		sig.SetError(ERR_ValueError, "invalid name");
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(reinterpret_cast<const char *>(_rtn)));
'''

glGetTexEnvfv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetTexEnvfv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetTexEnviv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetTexEnviv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetTexGendv(coord:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLdouble> params(n);
	glGetTexGendv(coord, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetTexGenfv(coord:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetTexGenfv(coord, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetTexGeniv(coord:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetTexGeniv(coord, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

//glGetTexImage(target:GLenum, level:GLint, format:GLenum, type:GLenum, pixels:GLvoid@):void = `unsupport

glGetTexLevelParameterfv(target:GLenum, level:GLint, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetTexLevelParameterfv(target, level, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetTexLevelParameteriv(target:GLenum, level:GLint, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetTexLevelParameteriv(target, level, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetTexParameterfv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLfloat> params(n);
	glGetTexParameterfv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glGetTexParameteriv(target:GLenum, pname:GLenum) {block?} = R'''
	size_t n = GetParamCount(pname);
	CArray<GLint> params(n);
	glGetTexParameteriv(target, pname, params);
	return ReturnValue(env, sig, args, Value::CreateList(env, params, n));
'''

glHint(target:GLenum, mode:GLenum):void = `auto

glHistogram(target:GLenum, width:GLsizei, internalformat:GLenum, sink:GLboolean):void = `auto

glIndexMask(mask:GLuint):void = `auto

//glIndexPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glIndexd(c:GLdouble):void = `auto

glIndexdv(c:GLdouble@:const):void = `auto

glIndexf(c:GLfloat):void = `auto

glIndexfv(c:GLfloat@:const):void = `auto

glIndexi(c:GLint):void = `auto

glIndexiv(c:GLint@:const):void = `auto

glIndexs(c:GLshort):void = `auto

glIndexsv(c:GLshort@:const):void = `auto

glIndexub(c:GLubyte):void = `auto

glIndexubv(c:GLubyte@:const):void = `auto

glInitNames():void = `auto

//glInterleavedArrays(format:GLenum, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glIsEnabled(cap:GLenum):GLboolean {block?} = `auto

glIsList(list:GLuint):GLboolean {block?} = `auto

glIsTexture(texture:GLuint):GLboolean {block?} = `auto

glLightModelf(pname:GLenum, param:GLfloat):void = `auto

glLightModelfv(pname:GLenum, params:GLfloat@:const):void = R'''
	glLightModelfv(pname, params);
	return Value::Null;
'''

glLightModeli(pname:GLenum, param:GLint):void = `auto

glLightModeliv(pname:GLenum, params:GLint@:const):void = R'''
	glLightModeliv(pname, params);
	return Value::Null;
'''
	
glLightf(light:GLenum, pname:GLenum, param:GLfloat):void = `auto

glLightfv(light:GLenum, pname:GLenum, params:GLfloat@:const):void = R'''
	glLightfv(light, pname, params);
	return Value::Null;
'''

glLighti(light:GLenum, pname:GLenum, param:GLint):void = `auto

glLightiv(light:GLenum, pname:GLenum, params:GLint@:const):void = R'''
	glLightiv(light, pname, params);
	return Value::Null;
'''

glLineStipple(factor:GLint, pattern:GLushort):void = `auto

glLineWidth(width:GLfloat):void = `auto

glListBase(base:GLuint):void = `auto

glLoadIdentity():void = `auto

glLoadMatrixd(m:GLdouble@16:const):void = `auto

glLoadMatrixf(m:GLfloat@16:const):void = `auto

glLoadName(name:GLuint):void = `auto

glLogicOp(opcode:GLenum):void = `auto

glMap1d(target:GLenum, u1:GLdouble, u2:GLdouble, stride:GLint, order:GLint, points:GLdouble@:const):void = `auto

glMap1f(target:GLenum, u1:GLfloat, u2:GLfloat, stride:GLint, order:GLint, points:GLfloat@:const):void = `auto

glMap2d(target:GLenum, u1:GLdouble, u2:GLdouble, ustride:GLint, uorder:GLint, v1:GLdouble, v2:GLdouble, vstride:GLint, vorder:GLint, points:GLdouble@:const):void = `auto

glMap2f(target:GLenum, u1:GLfloat, u2:GLfloat, ustride:GLint, uorder:GLint, v1:GLfloat, v2:GLfloat, vstride:GLint, vorder:GLint, points:GLfloat@:const):void = `auto

glMapGrid1d(un:GLint, u1:GLdouble, u2:GLdouble):void = `auto

glMapGrid1f(un:GLint, u1:GLfloat, u2:GLfloat):void = `auto

glMapGrid2d(un:GLint, u1:GLdouble, u2:GLdouble, vn:GLint, v1:GLdouble, v2:GLdouble):void = `auto

glMapGrid2f(un:GLint, u1:GLfloat, u2:GLfloat, vn:GLint, v1:GLfloat, v2:GLfloat):void = `auto

glMaterialf(face:GLenum, pname:GLenum, param:GLfloat):void = `auto

glMaterialfv(face:GLenum, pname:GLenum, params:GLfloat@:const):void = R'''
	glMaterialfv(face, pname, params);
	return Value::Null;
'''

glMateriali(face:GLenum, pname:GLenum, param:GLint):void = `auto

glMaterialiv(face:GLenum, pname:GLenum, params:GLint@:const):void = R'''
	glMaterialiv(face, pname, params);
	return Value::Null;
'''

glMatrixMode(mode:GLenum):void = `auto

glMinmax(target:GLenum, internalformat:GLenum, sink:GLboolean):void = `auto

glMultMatrixd(m:GLdouble@16:const):void = `auto

glMultMatrixf(m:GLfloat@16:const):void = `auto

glNewList(list:GLuint, mode:GLenum):void {block?} = R'''
	glNewList(list, mode);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		glEndList();
	}
	return Value::Null;
'''

glNormal3b(nx:GLbyte, ny:GLbyte, nz:GLbyte):void = `auto

glNormal3bv(v:GLbyte@3:const):void = `auto

glNormal3d(nx:GLdouble, ny:GLdouble, nz:GLdouble):void = `auto

glNormal3dv(v:GLdouble@3:const):void = `auto

glNormal3f(nx:GLfloat, ny:GLfloat, nz:GLfloat):void = `auto

glNormal3fv(v:GLfloat@3:const):void = `auto

glNormal3i(nx:GLint, ny:GLint, nz:GLint):void = `auto

glNormal3iv(v:GLint@3:const):void = `auto

glNormal3s(nx:GLshort, ny:GLshort, nz:GLshort):void = `auto

glNormal3sv(v:GLshort@3:const):void = `auto

//glNormalPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glOrtho(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble, zNear:GLdouble, zFar:GLdouble):void = `auto

glPassThrough(token:GLfloat):void = `auto

glPixelMapfv(map:GLenum, mapsize:GLint, values:GLfloat@:const):void = `auto

glPixelMapuiv(map:GLenum, mapsize:GLint, values:GLuint@:const):void = `auto

glPixelMapusv(map:GLenum, mapsize:GLint, values:GLushort@:const):void = `auto

glPixelStoref(pname:GLenum, param:GLfloat):void = `auto

glPixelStorei(pname:GLenum, param:GLint):void = `auto

glPixelTransferf(pname:GLenum, param:GLfloat):void = `auto

glPixelTransferi(pname:GLenum, param:GLint):void = `auto

glPixelZoom(xfactor:GLfloat, yfactor:GLfloat):void = `auto

glPointSize(size:GLfloat):void = `auto

glPolygonMode(face:GLenum, mode:GLenum):void = `auto

glPolygonOffset(factor:GLfloat, units:GLfloat):void = `auto

glPolygonStipple(mask:binary):void = R'''
	if (mask.size() != 32 * 4) {
		sig.SetError(ERR_ValueError, "mask must be a binary containing 32 * 4 elements");
		return Value::Null;
	}
	glPolygonStipple(reinterpret_cast<const GLubyte *>(mask.data()));
	return Value::Null;
'''

glPopAttrib():void = `auto

glPopClientAttrib():void = `auto

glPopMatrix():void = `auto

glPopName():void = `auto

glPrioritizeTextures(textures:GLuint@:const, priorities:GLclampf@:const):void = R'''
	GLsizei n = textures.GetSize();
	if (n != priorities.GetSize()) {
		sig.SetError(ERR_ValueError, "textures and priorities must have the same number of elements");
		return Value::Null;
	}
	glPrioritizeTextures(n, textures, priorities);
	return Value::Null;
'''

glPushAttrib(mask:GLbitfield):void {block?} = R'''
	glPushAttrib(mask);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		glPopAttrib();
	}
	return Value::Null;
'''

glPushClientAttrib(mask:GLbitfield):void {block?} = R'''
	glPushClientAttrib(mask);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		glPopClientAttrib();
	}
	return Value::Null;
'''

glPushMatrix():void {block?} = R'''
	glPushMatrix();
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		glPopMatrix();
	}
	return Value::Null;
'''

glPushName(name:GLuint):void {block?} = R'''
	glPushName(name);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		glPopName();
	}
	return Value::Null;
'''

glRasterPos2d(x:GLdouble, y:GLdouble):void = `auto

glRasterPos2dv(v:GLdouble@2:const):void = `auto

glRasterPos2f(x:GLfloat, y:GLfloat):void = `auto

glRasterPos2fv(v:GLfloat@2:const):void = `auto

glRasterPos2i(x:GLint, y:GLint):void = `auto

glRasterPos2iv(v:GLint@2:const):void = `auto

glRasterPos2s(x:GLshort, y:GLshort):void = `auto

glRasterPos2sv(v:GLshort@2:const):void = `auto

glRasterPos3d(x:GLdouble, y:GLdouble, z:GLdouble):void = `auto

glRasterPos3dv(v:GLdouble@3:const):void = `auto

glRasterPos3f(x:GLfloat, y:GLfloat, z:GLfloat):void = `auto

glRasterPos3fv(v:GLfloat@3:const):void = `auto

glRasterPos3i(x:GLint, y:GLint, z:GLint):void = `auto

glRasterPos3iv(v:GLint@3:const):void = `auto

glRasterPos3s(x:GLshort, y:GLshort, z:GLshort):void = `auto

glRasterPos3sv(v:GLshort@3:const):void = `auto

glRasterPos4d(x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void = `auto

glRasterPos4dv(v:GLdouble@4:const):void = `auto

glRasterPos4f(x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void = `auto

glRasterPos4fv(v:GLfloat@4:const):void = `auto

glRasterPos4i(x:GLint, y:GLint, z:GLint, w:GLint):void = `auto

glRasterPos4iv(v:GLint@4:const):void = `auto

glRasterPos4s(x:GLshort, y:GLshort, z:GLshort, w:GLshort):void = `auto

glRasterPos4sv(v:GLshort@4:const):void = `auto

glReadBuffer(mode:GLenum):void = `auto

glReadPixels(x:GLint, y:GLint, width:GLsizei, height:GLsizei, format:symbol) {block?} = R'''
	Image::Format fmt = Image::SymbolToFormat(sig, format);
	if (sig.IsSignalled()) return Value::Null;
	AutoPtr<Image> pImage(new Image(fmt));
	GLenum _format = GetImageFormat(sig, pImage.get());
	if (sig.IsSignalled()) return Value::Null;
	if (!pImage->AllocBuffer(sig, width, height, 0xff)) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	glReadPixels(x, y, width, height, _format, type, pImage->GetBuffer());
	return ReturnValue(env, sig, args, Value(new Object_image(env, pImage.release())));
'''

glRectd(x1:GLdouble, y1:GLdouble, x2:GLdouble, y2:GLdouble):void = `auto

glRectdv(v1:GLdouble@2:const, v2:GLdouble@2:const):void = `auto

glRectf(x1:GLfloat, y1:GLfloat, x2:GLfloat, y2:GLfloat):void = `auto

glRectfv(v1:GLfloat@2:const, v2:GLfloat@2:const):void = `auto

glRecti(x1:GLint, y1:GLint, x2:GLint, y2:GLint):void = `auto

glRectiv(v1:GLint@2:const, v2:GLint@2:const):void = `auto

glRects(x1:GLshort, y1:GLshort, x2:GLshort, y2:GLshort):void = `auto

glRectsv(v1:GLshort@2:const, v2:GLshort@2:const):void = `auto

glRenderMode(mode:GLenum):GLint {block?} = `auto

glResetHistogram(target:GLenum):void = `auto

glResetMinmax(target:GLenum):void = `auto

glRotated(angle:GLdouble, x:GLdouble, y:GLdouble, z:GLdouble):void = `auto

glRotatef(angle:GLfloat, x:GLfloat, y:GLfloat, z:GLfloat):void = `auto

glScaled(x:GLdouble, y:GLdouble, z:GLdouble):void = `auto

glScalef(x:GLfloat, y:GLfloat, z:GLfloat):void = `auto

glScissor(x:GLint, y:GLint, width:GLsizei, height:GLsizei):void = `auto

glSelectBuffer(size:GLsizei) {block?} = R'''
	CArray<GLuint> buffer(size);
	glSelectBuffer(size, buffer);
	return ReturnValue(env, sig, args, Value::CreateList(env, buffer, size));
'''

//glSeparableFilter2D(target:GLenum, internalformat:GLenum, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, row:GLvoid@:const, column:GLvoid@:const):void = `unsupport

glShadeModel(mode:GLenum):void = `auto

glStencilFunc(func:GLenum, ref:GLint, mask:GLuint):void = `auto

glStencilMask(mask:GLuint):void = `auto

glStencilOp(fail:GLenum, zfail:GLenum, zpass:GLenum):void = `auto

glTexCoord1d(s:GLdouble):void = `auto

glTexCoord1dv(v:GLdouble@1:const):void = `auto

glTexCoord1f(s:GLfloat):void = `auto

glTexCoord1fv(v:GLfloat@1:const):void = `auto

glTexCoord1i(s:GLint):void = `auto

glTexCoord1iv(v:GLint@1:const):void = `auto

glTexCoord1s(s:GLshort):void = `auto

glTexCoord1sv(v:GLshort@1:const):void = `auto

glTexCoord2d(s:GLdouble, t:GLdouble):void = `auto

glTexCoord2dv(v:GLdouble@2:const):void = `auto

glTexCoord2f(s:GLfloat, t:GLfloat):void = `auto

glTexCoord2fv(v:GLfloat@2:const):void = `auto

glTexCoord2i(s:GLint, t:GLint):void = `auto

glTexCoord2iv(v:GLint@2:const):void = `auto

glTexCoord2s(s:GLshort, t:GLshort):void = `auto

glTexCoord2sv(v:GLshort@2:const):void = `auto

glTexCoord3d(s:GLdouble, t:GLdouble, r:GLdouble):void = `auto

glTexCoord3dv(v:GLdouble@3:const):void = `auto

glTexCoord3f(s:GLfloat, t:GLfloat, r:GLfloat):void = `auto

glTexCoord3fv(v:GLfloat@3:const):void = `auto

glTexCoord3i(s:GLint, t:GLint, r:GLint):void = `auto

glTexCoord3iv(v:GLint@3:const):void = `auto

glTexCoord3s(s:GLshort, t:GLshort, r:GLshort):void = `auto

glTexCoord3sv(v:GLshort@3:const):void = `auto

glTexCoord4d(s:GLdouble, t:GLdouble, r:GLdouble, q:GLdouble):void = `auto

glTexCoord4dv(v:GLdouble@4:const):void = `auto

glTexCoord4f(s:GLfloat, t:GLfloat, r:GLfloat, q:GLfloat):void = `auto

glTexCoord4fv(v:GLfloat@4:const):void = `auto

glTexCoord4i(s:GLint, t:GLint, r:GLint, q:GLint):void = `auto

glTexCoord4iv(v:GLint@4:const):void = `auto

glTexCoord4s(s:GLshort, t:GLshort, r:GLshort, q:GLshort):void = `auto

glTexCoord4sv(v:GLshort@4:const):void = `auto

//glTexCoordPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glTexEnvf(target:GLenum, pname:GLenum, param:GLfloat):void = `auto

glTexEnvfv(target:GLenum, pname:GLenum, params:GLfloat@:const):void = `auto

glTexEnvi(target:GLenum, pname:GLenum, param:GLint):void = `auto

glTexEnviv(target:GLenum, pname:GLenum, params:GLint@:const):void = `auto

glTexGend(coord:GLenum, pname:GLenum, param:GLdouble):void = `auto

glTexGendv(coord:GLenum, pname:GLenum, params:GLdouble@:const):void = `auto

glTexGenf(coord:GLenum, pname:GLenum, param:GLfloat):void = `auto

glTexGenfv(coord:GLenum, pname:GLenum, params:GLfloat@:const):void = `auto

glTexGeni(coord:GLenum, pname:GLenum, param:GLint):void = `auto

glTexGeniv(coord:GLenum, pname:GLenum, params:GLint@:const):void = `auto

glTexImage1D(target:GLenum, level:GLint,
			 internalformat:GLint, border:GLint, image:image):void = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth()) + border * 2;
	GLenum format = GetImageFormat(sig, image);
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
	return Value::Null;
'''

glTexImage2D(target:GLenum, level:GLint,
			 internalformat:GLint, border:GLint, image:image):void = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth()) + border * 2;
	GLsizei height = static_cast<GLsizei>(image->GetHeight()) + border * 2;
	GLenum format = GetImageFormat(sig, image);
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
	return Value::Null;
'''
	
//glTexImage3D(target:GLenum, level:GLint, internalformat:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:GLvoid@:const):void = `unsupport

glTexParameterf(target:GLenum, pname:GLenum, param:GLfloat):void = `auto

glTexParameterfv(target:GLenum, pname:GLenum, params:GLfloat@:const):void = `auto

glTexParameteri(target:GLenum, pname:GLenum, param:GLint):void = `auto

glTexParameteriv(target:GLenum, pname:GLenum, params:GLint@:const):void = `auto

glTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, image:image):void = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLenum format = GetImageFormat(sig, image);
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
	return Value::Null;
'''

glTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, image:image):void = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = GetImageFormat(sig, image);
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
	return Value::Null;
'''

//glTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, type:GLenum, pixels:GLvoid@:const):void = `unsupport

glTranslated(x:GLdouble, y:GLdouble, z:GLdouble):void = `auto

glTranslatef(x:GLfloat, y:GLfloat, z:GLfloat):void = `auto

glVertex2d(x:GLdouble, y:GLdouble):void = `auto

glVertex2dv(v:GLdouble@2:const):void = `auto

glVertex2f(x:GLfloat, y:GLfloat):void = `auto

glVertex2fv(v:GLfloat@2:const):void = `auto

glVertex2i(x:GLint, y:GLint):void = `auto

glVertex2iv(v:GLint@2:const):void = `auto

glVertex2s(x:GLshort, y:GLshort):void = `auto

glVertex2sv(v:GLshort@2:const):void = `auto

glVertex3d(x:GLdouble, y:GLdouble, z:GLdouble):void = `auto

glVertex3dv(v:GLdouble@3:const):void = `auto

glVertex3f(x:GLfloat, y:GLfloat, z:GLfloat):void = `auto

glVertex3fv(v:GLfloat@3:const):void = `auto

glVertex3i(x:GLint, y:GLint, z:GLint):void = `auto

glVertex3iv(v:GLint@3:const):void = `auto

glVertex3s(x:GLshort, y:GLshort, z:GLshort):void = `auto

glVertex3sv(v:GLshort@3:const):void = `auto

glVertex4d(x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void = `auto

glVertex4dv(v:GLdouble@4:const):void = `auto

glVertex4f(x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void = `auto

glVertex4fv(v:GLfloat@4:const):void = `auto

glVertex4i(x:GLint, y:GLint, z:GLint, w:GLint):void = `auto

glVertex4iv(v:GLint@4:const):void = `auto

glVertex4s(x:GLshort, y:GLshort, z:GLshort, w:GLshort):void = `auto

glVertex4sv(v:GLshort@4:const):void = `auto

//glVertexPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glViewport(x:GLint, y:GLint, width:GLsizei, height:GLsizei):void = `auto

glSampleCoverage(value:GLclampf, invert:GLboolean):void = `auto

glLoadTransposeMatrixf(m:GLfloat@16:const):void = `auto

glLoadTransposeMatrixd(m:GLdouble@16:const):void = `auto

glMultTransposeMatrixf(m:GLfloat@16:const):void = `auto

glMultTransposeMatrixd(m:GLdouble@16:const):void = `auto

//glCompressedTexImage3D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, height:GLsizei, depth:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void = `unsupport

//glCompressedTexImage2D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, height:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void = `unsupport

//glCompressedTexImage1D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void = `unsupport

//glCompressedTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void = `unsupport

//glCompressedTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, width:GLsizei, height:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void = `unsupport

//glCompressedTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, width:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void = `unsupport

//glGetCompressedTexImage(target:GLenum, lod:GLint, img:GLvoid@):void = `unsupport

glActiveTexture(texture:GLenum):void = `auto

glClientActiveTexture(texture:GLenum):void = `auto

glMultiTexCoord1d(target:GLenum, s:GLdouble):void = `auto

glMultiTexCoord1dv(target:GLenum, v:GLdouble@1:const):void = `auto

glMultiTexCoord1f(target:GLenum, s:GLfloat):void = `auto

glMultiTexCoord1fv(target:GLenum, v:GLfloat@1:const):void = `auto

glMultiTexCoord1i(target:GLenum, s:GLint):void = `auto

glMultiTexCoord1iv(target:GLenum, v:GLint@1:const):void = `auto

glMultiTexCoord1s(target:GLenum, s:GLshort):void = `auto

glMultiTexCoord1sv(target:GLenum, v:GLshort@1:const):void = `auto

glMultiTexCoord2d(target:GLenum, s:GLdouble, t:GLdouble):void = `auto

glMultiTexCoord2dv(target:GLenum, v:GLdouble@2:const):void = `auto

glMultiTexCoord2f(target:GLenum, s:GLfloat, t:GLfloat):void = `auto

glMultiTexCoord2fv(target:GLenum, v:GLfloat@2:const):void = `auto

glMultiTexCoord2i(target:GLenum, s:GLint, t:GLint):void = `auto

glMultiTexCoord2iv(target:GLenum, v:GLint@2:const):void = `auto

glMultiTexCoord2s(target:GLenum, s:GLshort, t:GLshort):void = `auto

glMultiTexCoord2sv(target:GLenum, v:GLshort@2:const):void = `auto

glMultiTexCoord3d(target:GLenum, s:GLdouble, t:GLdouble, r:GLdouble):void = `auto

glMultiTexCoord3dv(target:GLenum, v:GLdouble@3:const):void = `auto

glMultiTexCoord3f(target:GLenum, s:GLfloat, t:GLfloat, r:GLfloat):void = `auto

glMultiTexCoord3fv(target:GLenum, v:GLfloat@3:const):void = `auto

glMultiTexCoord3i(target:GLenum, s:GLint, t:GLint, r:GLint):void = `auto

glMultiTexCoord3iv(target:GLenum, v:GLint@3:const):void = `auto

glMultiTexCoord3s(target:GLenum, s:GLshort, t:GLshort, r:GLshort):void = `auto

glMultiTexCoord3sv(target:GLenum, v:GLshort@3:const):void = `auto

glMultiTexCoord4d(target:GLenum, s:GLdouble, t:GLdouble, r:GLdouble, q:GLdouble):void = `auto

glMultiTexCoord4dv(target:GLenum, v:GLdouble@4:const):void = `auto

glMultiTexCoord4f(target:GLenum, s:GLfloat, t:GLfloat, r:GLfloat, q:GLfloat):void = `auto

glMultiTexCoord4fv(target:GLenum, v:GLfloat@4:const):void = `auto

glMultiTexCoord4i(target:GLenum, s:GLint, t:GLint, r:GLint, q:GLint):void = `auto

glMultiTexCoord4iv(target:GLenum, v:GLint@4:const):void = `auto

glMultiTexCoord4s(target:GLenum, s:GLshort, t:GLshort, r:GLshort, q:GLshort):void = `auto

glMultiTexCoord4sv(target:GLenum, v:GLshort@4:const):void = `auto

glFogCoordf(coord:GLfloat):void = `auto

glFogCoordfv(coord:GLfloat@1:const):void = `auto

glFogCoordd(coord:GLdouble):void = `auto

glFogCoorddv(coord:GLdouble@1:const):void = `auto

//glFogCoordPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glSecondaryColor3b(red:GLbyte, green:GLbyte, blue:GLbyte):void = `auto

glSecondaryColor3bv(v:GLbyte@3:const):void = `auto

glSecondaryColor3d(red:GLdouble, green:GLdouble, blue:GLdouble):void = `auto

glSecondaryColor3dv(v:GLdouble@3:const):void = `auto

glSecondaryColor3f(red:GLfloat, green:GLfloat, blue:GLfloat):void = `auto

glSecondaryColor3fv(v:GLfloat@3:const):void = `auto

glSecondaryColor3i(red:GLint, green:GLint, blue:GLint):void = `auto

glSecondaryColor3iv(v:GLint@3:const):void = `auto

glSecondaryColor3s(red:GLshort, green:GLshort, blue:GLshort):void = `auto

glSecondaryColor3sv(v:GLshort@3:const):void = `auto

glSecondaryColor3ub(red:GLubyte, green:GLubyte, blue:GLubyte):void = `auto

glSecondaryColor3ubv(v:GLubyte@3:const):void = `auto

glSecondaryColor3ui(red:GLuint, green:GLuint, blue:GLuint):void = `auto

glSecondaryColor3uiv(v:GLuint@3:const):void = `auto

glSecondaryColor3us(red:GLushort, green:GLushort, blue:GLushort):void = `auto

glSecondaryColor3usv(v:GLushort@3:const):void = `auto

//glSecondaryColorPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glPointParameterf(pname:GLenum, param:GLfloat):void = `auto

glPointParameterfv(pname:GLenum, params:GLfloat@:const):void = `auto

glPointParameteri(pname:GLenum, param:GLint):void = `auto

glPointParameteriv(pname:GLenum, params:GLint@:const):void = `auto

glBlendFuncSeparate(srcRGB:GLenum, dstRGB:GLenum, srcAlpha:GLenum, dstAlpha:GLenum):void = `auto

glMultiDrawArrays(mode:GLenum, first:GLint@:const, count:GLsizei@:const):void = R'''
	GLsizei primcount = first.GetSize();
	if (primcount != count.GetSize()) {
		sig.SetError(ERR_ValueError, "first and count must have the same number of elements");
		return Value::Null;
	}
	glMultiDrawArrays(mode, first, count, primcount);
	return Value::Null;
'''

//glMultiDrawElements(mode:GLenum, count:GLsizei@:const, type:GLenum, indices:GLvoid@:const@:const, primcount:GLsizei):void = `unsupport

glWindowPos2d(x:GLdouble, y:GLdouble):void = `auto

glWindowPos2dv(v:GLdouble@2:const):void = `auto

glWindowPos2f(x:GLfloat, y:GLfloat):void = `auto

glWindowPos2fv(v:GLfloat@2:const):void = `auto

glWindowPos2i(x:GLint, y:GLint):void = `auto

glWindowPos2iv(v:GLint@2:const):void = `auto

glWindowPos2s(x:GLshort, y:GLshort):void = `auto

glWindowPos2sv(v:GLshort@2:const):void = `auto

glWindowPos3d(x:GLdouble, y:GLdouble, z:GLdouble):void = `auto

glWindowPos3dv(v:GLdouble@3:const):void = `auto

glWindowPos3f(x:GLfloat, y:GLfloat, z:GLfloat):void = `auto

glWindowPos3fv(v:GLfloat@3:const):void = `auto

glWindowPos3i(x:GLint, y:GLint, z:GLint):void = `auto

glWindowPos3iv(v:GLint@3:const):void = `auto

glWindowPos3s(x:GLshort, y:GLshort, z:GLshort):void = `auto

glWindowPos3sv(v:GLshort@3:const):void = `auto

glGenQueries(n:GLsizei) {block?} = R'''
	CArray<GLuint> ids(n);
	glGenQueries(n, ids);
	return ReturnValue(env, sig, args, Value::CreateList(env, ids, n));
'''

glDeleteQueries(ids:GLuint@:const):void = R'''
	GLsizei n = ids.GetSize();
	glDeleteQueries(n, ids);
	return Value::Null;
'''

glIsQuery(id:GLuint):GLboolean {block?} = `auto

glBeginQuery(target:GLenum, id:GLuint):void {block?} = R'''
	glBeginQuery(target, id);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		glEndQuery(target);
	}
	return Value::Null;
'''

glEndQuery(target:GLenum):void = `auto

glGetQueryiv(target:GLenum, pname:GLenum, params:GLint@):void = `unsupport

glGetQueryObjectiv(id:GLuint, pname:GLenum, params:GLint@):void = `unsupport

glGetQueryObjectuiv(id:GLuint, pname:GLenum, params:GLuint@):void = `unsupport

glBindBuffer(target:GLenum, buffer:GLuint):void = `auto

glDeleteBuffers(buffers:GLuint@:const):void = R'''
	GLsizei n = buffers.GetSize();
	glDeleteBuffers(n, buffers);
	return Value::Null;
'''

glGenBuffers(n:GLsizei) {block?} = R'''
	CArray<GLuint> buffers(n);
	glGenBuffers(n, buffers);
	return Value::CreateList(env, buffers, n);
'''

glIsBuffer(buffer:GLuint):GLboolean {block?} = `auto

//glBufferData(target:GLenum, size:GLsizeiptr, data:GLvoid@:const, usage:GLenum):void = `unsupport

//glBufferSubData(target:GLenum, offset:GLintptr, size:GLsizeiptr, data:GLvoid@:const):void = `unsupport

//glGetBufferSubData(target:GLenum, offset:GLintptr, size:GLsizeiptr, data:GLvoid@):void = `unsupport

//glMapBuffer(target:GLenum, access:GLenum):GLvoid {block?}@

glUnmapBuffer(target:GLenum):GLboolean {block?} = `auto

glGetBufferParameteriv(target:GLenum, pname:GLenum, params:GLint@):void = `unsupport

//glGetBufferPointerv(target:GLenum, pname:GLenum, params:GLvoid@@):void = `unsupport

glDrawBuffers(bufs:GLenum@:const):void = R'''
	GLsizei n = bufs.GetSize();
	glDrawBuffers(n, bufs);
	return Value::Null;
'''

glVertexAttrib1d(index:GLuint, x:GLdouble):void = `auto

glVertexAttrib1dv(index:GLuint, v:GLdouble@1:const):void = `auto

glVertexAttrib1f(index:GLuint, x:GLfloat):void = `auto

glVertexAttrib1fv(index:GLuint, v:GLfloat@1:const):void = `auto

glVertexAttrib1s(index:GLuint, x:GLshort):void = `auto

glVertexAttrib1sv(index:GLuint, v:GLshort@1:const):void = `auto

glVertexAttrib2d(index:GLuint, x:GLdouble, y:GLdouble):void = `auto

glVertexAttrib2dv(index:GLuint, v:GLdouble@2:const):void = `auto

glVertexAttrib2f(index:GLuint, x:GLfloat, y:GLfloat):void = `auto

glVertexAttrib2fv(index:GLuint, v:GLfloat@2:const):void = `auto

glVertexAttrib2s(index:GLuint, x:GLshort, y:GLshort):void = `auto

glVertexAttrib2sv(index:GLuint, v:GLshort@2:const):void = `auto

glVertexAttrib3d(index:GLuint, x:GLdouble, y:GLdouble, z:GLdouble):void = `auto

glVertexAttrib3dv(index:GLuint, v:GLdouble@3:const):void = `auto

glVertexAttrib3f(index:GLuint, x:GLfloat, y:GLfloat, z:GLfloat):void = `auto

glVertexAttrib3fv(index:GLuint, v:GLfloat@3:const):void = `auto

glVertexAttrib3s(index:GLuint, x:GLshort, y:GLshort, z:GLshort):void = `auto

glVertexAttrib3sv(index:GLuint, v:GLshort@3:const):void = `auto

glVertexAttrib4Nbv(index:GLuint, v:GLbyte@4:const):void = `auto

glVertexAttrib4Niv(index:GLuint, v:GLint@4:const):void = `auto

glVertexAttrib4Nsv(index:GLuint, v:GLshort@4:const):void = `auto

glVertexAttrib4Nub(index:GLuint, x:GLubyte, y:GLubyte, z:GLubyte, w:GLubyte):void = `auto

glVertexAttrib4Nubv(index:GLuint, v:GLubyte@4:const):void = `auto

glVertexAttrib4Nuiv(index:GLuint, v:GLuint@4:const):void = `auto

glVertexAttrib4Nusv(index:GLuint, v:GLushort@4:const):void = `auto

glVertexAttrib4bv(index:GLuint, v:GLbyte@4:const):void = `auto

glVertexAttrib4d(index:GLuint, x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void = `auto

glVertexAttrib4dv(index:GLuint, v:GLdouble@4:const):void = `auto

glVertexAttrib4f(index:GLuint, x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void = `auto

glVertexAttrib4fv(index:GLuint, v:GLfloat@4:const):void = `auto

glVertexAttrib4iv(index:GLuint, v:GLint@4:const):void = `auto

glVertexAttrib4s(index:GLuint, x:GLshort, y:GLshort, z:GLshort, w:GLshort):void = `auto

glVertexAttrib4sv(index:GLuint, v:GLshort@4:const):void = `auto

glVertexAttrib4ubv(index:GLuint, v:GLubyte@4:const):void = `auto

glVertexAttrib4uiv(index:GLuint, v:GLuint@4:const):void = `auto

glVertexAttrib4usv(index:GLuint, v:GLushort@4:const):void = `auto

//glVertexAttribPointer(index:GLuint, size:GLint, type:GLenum, normalized:GLboolean, stride:GLsizei, pointer:GLvoid@:const):void = `unsupport

glEnableVertexAttribArray(index:GLuint):void = `auto

glDisableVertexAttribArray(index:GLuint):void = `auto

glGetVertexAttribdv(index:GLuint, pname:GLenum, params:GLdouble@):void = `unsupport

glGetVertexAttribfv(index:GLuint, pname:GLenum, params:GLfloat@):void = `unsupport

glGetVertexAttribiv(index:GLuint, pname:GLenum, params:GLint@):void = `unsupport

//glGetVertexAttribPointerv(index:GLuint, pname:GLenum, pointer:GLvoid@@):void = `unsupport

glDeleteShader(shader:GLuint):void = `auto

glDetachShader(program:GLuint, shader:GLuint):void = `auto

glCreateShader(type:GLenum):GLuint {block?} = `auto

glShaderSource(shader:GLuint, count:GLsizei, string:GLchar@:const@:const, length:GLint@:const):void = `unsupport

glCompileShader(shader:GLuint):void = `auto

glCreateProgram():GLuint {block?} = `auto

glAttachShader(program:GLuint, shader:GLuint):void = `auto

glLinkProgram(program:GLuint):void = `auto

glUseProgram(program:GLuint):void = `auto

glDeleteProgram(program:GLuint):void = `auto

glValidateProgram(program:GLuint):void = `auto

glUniform1f(location:GLint, v0:GLfloat):void = `auto

glUniform2f(location:GLint, v0:GLfloat, v1:GLfloat):void = `auto

glUniform3f(location:GLint, v0:GLfloat, v1:GLfloat, v2:GLfloat):void = `auto

glUniform4f(location:GLint, v0:GLfloat, v1:GLfloat, v2:GLfloat, v3:GLfloat):void = `auto

glUniform1i(location:GLint, v0:GLint):void = `auto

glUniform2i(location:GLint, v0:GLint, v1:GLint):void = `auto

glUniform3i(location:GLint, v0:GLint, v1:GLint, v2:GLint):void = `auto

glUniform4i(location:GLint, v0:GLint, v1:GLint, v2:GLint, v3:GLint):void = `auto

glUniform1fv(location:GLint, count:GLsizei, value:GLfloat@1:const):void = `auto

glUniform2fv(location:GLint, count:GLsizei, value:GLfloat@2:const):void = `auto

glUniform3fv(location:GLint, count:GLsizei, value:GLfloat@3:const):void = `auto

glUniform4fv(location:GLint, count:GLsizei, value:GLfloat@4:const):void = `auto

glUniform1iv(location:GLint, count:GLsizei, value:GLint@1:const):void = `auto

glUniform2iv(location:GLint, count:GLsizei, value:GLint@2:const):void = `auto

glUniform3iv(location:GLint, count:GLsizei, value:GLint@3:const):void = `auto

glUniform4iv(location:GLint, count:GLsizei, value:GLint@4:const):void = `auto

glUniformMatrix2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@2:const):void = `auto

glUniformMatrix3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@3:const):void = `auto

glUniformMatrix4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@4:const):void = `auto

glIsShader(shader:GLuint):GLboolean {block?} = `auto

glIsProgram(program:GLuint):GLboolean {block?} = `auto

glGetShaderiv(shader:GLuint, pname:GLenum, params:GLint@):void = `unsupport

glGetProgramiv(program:GLuint, pname:GLenum, params:GLint@):void = `unsupport

glGetAttachedShaders(program:GLuint, maxCount:GLsizei, count:GLsizei@, shaders:GLuint@):void = `unsupport

glGetShaderInfoLog(shader:GLuint, bufSize:GLsizei, length:GLsizei@, infoLog:GLchar@):void = `unsupport

glGetProgramInfoLog(program:GLuint, bufSize:GLsizei, length:GLsizei@, infoLog:GLchar@):void = `unsupport

glGetUniformLocation(program:GLuint, name:GLchar@:const):GLint {block?} = `unsupport

glGetActiveUniform(program:GLuint, index:GLuint, bufSize:GLsizei, length:GLsizei@, size:GLint@, type:GLenum@, name:GLchar@):void = `unsupport

glGetUniformfv(program:GLuint, location:GLint, params:GLfloat@):void = `unsupport

glGetUniformiv(program:GLuint, location:GLint, params:GLint@):void = `unsupport

glGetShaderSource(shader:GLuint, bufSize:GLsizei, length:GLsizei@, source:GLchar@):void = `unsupport

glBindAttribLocation(program:GLuint, index:GLuint, name:GLchar@:const):void = `unsupport

glGetActiveAttrib(program:GLuint, index:GLuint, bufSize:GLsizei, length:GLsizei@, size:GLint@, type:GLenum@, name:GLchar@):void = `unsupport

glGetAttribLocation(program:GLuint, name:GLchar@:const):GLint {block?} = `unsupport

glStencilFuncSeparate(face:GLenum, func:GLenum, ref:GLint, mask:GLuint):void = `auto

glStencilOpSeparate(face:GLenum, fail:GLenum, zfail:GLenum, zpass:GLenum):void = `auto

glStencilMaskSeparate(face:GLenum, mask:GLuint):void = `auto

glUniformMatrix2x3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void = `unsupport

glUniformMatrix3x2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void = `unsupport

glUniformMatrix2x4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void = `unsupport

glUniformMatrix4x2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void = `unsupport

glUniformMatrix3x4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void = `unsupport

glUniformMatrix4x3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void = `unsupport
}

typeConvDict = %{
	'GLenum' => TypeConv(
			'number', 'Once', [],
			'GLenum ${arg.name} = static_cast<GLenum>(args.GetInt(${idx}));',
			nil,
			R'''
			GLenum _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLboolean' => TypeConv(
			'boolean', 'Once', [],
			'GLboolean ${arg.name} = (args.GetBoolean(${idx})? GL_TRUE : GL_FALSE);',
			nil,
			R'''
			GLboolean _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn != GL_FALSE));''')
	'GLbitfield' => TypeConv(
			'number', 'Once', [],
			'GLbitfield ${arg.name} = args.GetUInt(${idx});',
			nil,
			R'''
			GLbitfield _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLbyte' => TypeConv(
			'number', 'Once', [],
			'GLbyte ${arg.name} = args.GetChar(${idx});',
			nil,
			R'''
			GLbyte _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLshort' => TypeConv(
			'number', 'Once', [],
			'GLshort ${arg.name} = args.GetShort(${idx});',
			nil,
			R'''
			GLshort _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLint' => TypeConv(
			'number', 'Once', [],
			'GLint ${arg.name} = args.GetInt(${idx});',
			nil,
			R'''
			GLint _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLsizei' => TypeConv(
			'number', 'Once', [],
			'GLsizei ${arg.name} = args.GetInt(${idx});',
			nil,
			R'''
			GLsizei _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLubyte' => TypeConv(
			'number', 'Once', [],
			'GLubyte ${arg.name} = args.GetUChar(${idx});',
			nil,
			R'''
			GLubyte _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLushort' => TypeConv(
			'number', 'Once', [],
			'GLushort ${arg.name} = args.GetUShort(${idx});',
			nil,
			R'''
			GLushort _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLuint' => TypeConv(
			'number', 'Once', [],
			'GLuint ${arg.name} = args.GetUInt(${idx});',
			nil,
			R'''
			GLuint _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLfloat' => TypeConv(
			'number', 'Once', [],
			'GLfloat ${arg.name} = args.GetFloat(${idx});',
			nil,
			R'''
			GLfloat _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLclampf' => TypeConv(
			'number', 'Once', [],
			'GLclampf ${arg.name} = args.GetFloat(${idx});',
			nil,
			R'''
			GLclampf _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLdouble' => TypeConv(
			'number', 'Once', [],
			'GLdouble ${arg.name} = args.GetDouble(${idx});',
			nil,
			R'''
			GLdouble _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLclampd' => TypeConv(
			'number', 'Once', [],
			'GLclampd ${arg.name} = args.GetDouble(${idx});',
			nil,
			R'''
			GLclampd _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLenum@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLenum> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLenum@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLenum> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@' => TypeConv(
			'boolean', 'Once', ['List'],
			'CArray<GLboolean> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@:const' => TypeConv(
			'boolean', 'Once', ['List'],
			'CArray<GLboolean> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLboolean@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLboolean@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLbyte@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLbyte> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLbyte@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLbyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLbyte@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLbyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLchar@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLchar> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLchar@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLchar> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLubyte@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLubyte> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLubyte@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLubyte> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLubyte@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLubyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLubyte@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLubyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLshort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLshort@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLushort@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLushort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLushort@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLushort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLushort@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLushort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLushort@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLushort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLint@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLint@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLsizei@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLsizei> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLsizei@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLsizei> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLuint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLuint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLuint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLuint@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLuint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLfloat> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLfloat@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLfloat> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLfloat@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@16:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 16) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLclampf@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLclampf> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLdouble> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLdouble> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@16:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 16) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
}

tmplSource = R"""
// Don't edit this file. This has been generated by Functions.cpp.gura.
#include "stdafx.h"

Gura_BeginModuleScope(opengl)

${renderer.RenderImplementation()}

void AssignFunctions(Environment &env)
{
	${renderer.RenderAssignment()}
}

Gura_EndModuleScope(opengl)
""".template()

Renderer('opengl', decls.children, typeConvDict, &{$funcName}) {|renderer|
	if (sys.argv.len() > 1 && sys.argv[1] == 'test') {
		print(renderer.RenderImplementation())
		print(renderer.RenderAssignment())
	} else {
		fileNameOut = 'Functions.cpp'
		tmplSource.render(fileNameOut)
		println(fileNameOut, ' was created')
	}
}
