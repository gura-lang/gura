#!/usr/bin/env gura
import(cbridge_glcmn)

cbridge_glcmn.Implement {

glAccum(op:GLenum, value:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	operate on the accumulation buffer
	'''
}

glAlphaFunc(func:GLenum, ref:GLclampf):void:map = `auto % {`en, 'markdown',
	R'''
	specify the alpha test function
	'''
}

glAreTexturesResident(textures:GLuint@:const):GLboolean:map {block?} = R'''
	GLsizei n = _textures->GetSize();
	AutoPtr<Array<GLboolean> > _residences(new Array<GLboolean>(n));
	GLboolean *residences = _residences->GetPointer();
	GLboolean _rtn = glAreTexturesResident(n, textures, residences);
	if (_rtn == 0) return Value::Nil;
	Value _rtnVal;
	Object_list *pObjList = _rtnVal.InitAsList(env, n);
	for (GLsizei i = 0; i < n; i++) {
		pObjList->Add(residences[i] != 0);
	}
	return ReturnValue(env, arg, _rtnVal);
''' % {`en, 'markdown',
	R'''
	determine if textures are loaded in texture memory
	'''
}

glArrayElement(i:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	render a vertex using the specified vertex array element
	'''
}

glBegin(mode:GLenum):void:map {block?} = R'''
	glBegin(mode);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glEnd();
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	delimit the vertices of a primitive or a group of like primitives
	'''
}

glBindTexture(target:GLenum, texture:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glBitmap(width:GLsizei, height:GLsizei, xorig:GLfloat, yorig:GLfloat, xmove:GLfloat, ymove:GLfloat, bitmap:GLubyte@:const:nil):void:map = R'''
	if (_bitmap != nullptr) {
		size_t bytesReq = ((width + 7) / 8) * height;
		if (_bitmap->GetSize() < bytesReq) {
			env.SetError(ERR_ValueError, "array doesn\'t contain enough data");
			return Value::Nil;
		}
	}
	glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

/*
glBlendColor(red:GLclampf, green:GLclampf, blue:GLclampf, alpha:GLclampf):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/
	
/*
glBlendEquation(mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glBlendEquationSeparate(modeRGB:GLenum, modeAlpha:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

glBlendFunc(sfactor:GLenum, dfactor:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glCallList(list:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glCallLists(type:GLenum, lists[]:number):void:map = R'''
	const ValueList &lists_in = arg.GetList(1);
	GLsizei n = static_cast<GLsizei>(lists.size());
	AutoPtr<Memory> pListsBuff;
	if (type == GL_BYTE) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLbyte) * n));
		GLbyte *p = reinterpret_cast<GLbyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetChar(); }
	} else if (type == GL_UNSIGNED_BYTE) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUChar(); }
	} else if (type == GL_SHORT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLshort) * n));
		GLshort *p = reinterpret_cast<GLshort *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetShort(); }
	} else if (type == GL_UNSIGNED_SHORT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLushort) * n));
		GLushort *p = reinterpret_cast<GLushort *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUShort(); }
	} else if (type == GL_INT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLint) * n));
		GLint *p = reinterpret_cast<GLint *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetInt(); }
	} else if (type == GL_UNSIGNED_INT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLuint) * n));
		GLuint *p = reinterpret_cast<GLuint *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetUInt(); }
	} else if (type == GL_FLOAT) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLfloat) * n));
		GLfloat *p = reinterpret_cast<GLfloat *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) { *p++ = pValue->GetFloat(); }
	} else if (type == GL_2_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 2 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			UShort num = pValue->GetUShort();
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else if (type == GL_3_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 3 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			ULong num = pValue->GetULong();
			*p++ = static_cast<GLubyte>(num >> 16);
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else if (type == GL_4_BYTES) {
		pListsBuff.reset(new MemoryHeap(sizeof(GLubyte) * 4 * n));
		GLubyte *p = reinterpret_cast<GLubyte *>(pListsBuff->GetPointer());
		foreach_const (ValueList, pValue, lists_in) {
			ULong num = pValue->GetULong();
			*p++ = static_cast<GLubyte>(num >> 24);
			*p++ = static_cast<GLubyte>(num >> 16);
			*p++ = static_cast<GLubyte>(num >> 8);
			*p++ = static_cast<GLubyte>(num);
		}
	} else {
		env.SetError(ERR_ValueError, "invalid type specification");
		return Value::Nil;
	}
	// GLsizei n, GLenum type, const GLvoid *lists
	glCallLists(n, type, pListsBuff->GetPointer());
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glClear(mask:GLbitfield):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glClearAccum(red:GLfloat, green:GLfloat, blue:GLfloat, alpha:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glClearColor(red:GLclampf, green:GLclampf, blue:GLclampf, alpha:GLclampf):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glClearDepth(depth:GLclampd):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glClearIndex(c:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glClearStencil(s:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glClipPlane(plane:GLenum, equation:GLdouble@4):map:void {block?} = R'''
	glClipPlane(plane, equation);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glColor3b(red:GLbyte, green:GLbyte, blue:GLbyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3bv(v:GLbyte@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3d(red:GLdouble, green:GLdouble, blue:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3dv(v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3f(red:GLfloat, green:GLfloat, blue:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3fv(v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3i(red:GLint, green:GLint, blue:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3iv(v:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3s(red:GLshort, green:GLshort, blue:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3sv(v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3ub(red:GLubyte, green:GLubyte, blue:GLubyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3ubv(v:GLubyte@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3ui(red:GLuint, green:GLuint, blue:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3uiv(v:GLuint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3us(red:GLushort, green:GLushort, blue:GLushort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor3usv(v:GLushort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4b(red:GLbyte, green:GLbyte, blue:GLbyte, alpha:GLbyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4bv(v:GLbyte@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4d(red:GLdouble, green:GLdouble, blue:GLdouble, alpha:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4dv(v:GLdouble@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4f(red:GLfloat, green:GLfloat, blue:GLfloat, alpha:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4fv(v:GLfloat@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4i(red:GLint, green:GLint, blue:GLint, alpha:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4iv(v:GLint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4s(red:GLshort, green:GLshort, blue:GLshort, alpha:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4sv(v:GLshort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4ub(red:GLubyte, green:GLubyte, blue:GLubyte, alpha:GLubyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4ubv(v:GLubyte@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4ui(red:GLuint, green:GLuint, blue:GLuint, alpha:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4uiv(v:GLuint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4us(red:GLushort, green:GLushort, blue:GLushort, alpha:GLushort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColor4usv(v:GLushort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColorMask(red:GLboolean, green:GLboolean, blue:GLboolean, alpha:GLboolean):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glColorMaterial(face:GLenum, mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glColorPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

//glColorSubTable(target:GLenum, start:GLsizei, count:GLsizei, format:GLenum, type:GLenum, data:GLvoid@:const):void:map = `unsupport

//glColorTable(target:GLenum, internalformat:GLenum, width:GLsizei, format:GLenum, type:GLenum, table:GLvoid@:const):void:map = `unsupport

/*
glColorTableParameterfv(target:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glColorTableParameteriv(target:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

//glConvolutionFilter1D(target:GLenum, internalformat:GLenum, width:GLsizei, format:GLenum, type:GLenum, image:GLvoid@:const):void:map = `unsupport

//glConvolutionFilter2D(target:GLenum, internalformat:GLenum, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, image:GLvoid@:const):void:map = `unsupport

/*
glConvolutionParameterf(target:GLenum, pname:GLenum, params:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glConvolutionParameterfv(target:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glConvolutionParameteri(target:GLenum, pname:GLenum, params:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glConvolutionParameteriv(target:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glCopyColorSubTable(target:GLenum, start:GLsizei, x:GLint, y:GLint, width:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glCopyColorTable(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glCopyConvolutionFilter1D(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glCopyConvolutionFilter2D(target:GLenum, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

glCopyPixels(x:GLint, y:GLint, width:GLsizei, height:GLsizei, type:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glCopyTexImage1D(target:GLenum, level:GLint, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, border:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glCopyTexImage2D(target:GLenum, level:GLint, internalformat:GLenum, x:GLint, y:GLint, width:GLsizei, height:GLsizei, border:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glCopyTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, x:GLint, y:GLint, width:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glCopyTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

/*
glCopyTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

glCullFace(mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDeleteLists(list:GLuint, range:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDeleteTextures(textures:GLuint@:const):void:map = R'''
	GLsizei n = _textures->GetSize();
	glDeleteTextures(n, textures);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glDepthFunc(func:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDepthMask(flag:GLboolean):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDepthRange(zNear:GLclampd, zFar:GLclampd):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDisable(cap:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDisableClientState(array:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDrawArrays(mode:GLenum, first:GLint, count:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDrawBuffer(mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glDrawElements(mode:GLenum, count:GLsizei, type:GLenum, indices:GLvoid@:const):void:map = `unsupport

glDrawPixels(width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, pixels:any):void:map = R'''	
	const void *p = GetArrayPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glDrawPixels(width, height, format, type, p);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glDrawPixelsFromImage(image:image):void:map = R'''	
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = image->GetBuffer();
	// GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels
	glDrawPixels(width, height, format, type, pixels);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

//glDrawRangeElements(mode:GLenum, start:GLuint, end:GLuint, count:GLsizei, type:GLenum, indices:GLvoid@:const):void:map = `unsupport

glEdgeFlag(flag:GLboolean):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glEdgeFlagPointer(stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glEdgeFlagv(flag:GLboolean@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEnable(cap:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEnableClientState(array:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEnd():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glEndList():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalCoord1d(u:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalCoord1dv(u:GLdouble@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalCoord1f(u:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalCoord1fv(u:GLfloat@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalCoord2d(u:GLdouble, v:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalCoord2dv(u:GLdouble@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalCoord2f(u:GLfloat, v:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalCoord2fv(u:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalMesh1(mode:GLenum, i1:GLint, i2:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalMesh2(mode:GLenum, i1:GLint, i2:GLint, j1:GLint, j2:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalPoint1(i:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glEvalPoint2(i:GLint, j:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glFeedbackBuffer(type:GLenum, buffer:array@float:nil):void = R'''
	if (buffer == nullptr) {
		glFeedbackBuffer(0, type, nullptr);
	} else {
		glFeedbackBuffer(buffer->GetSize(), type, buffer->GetPointer());
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glFinish():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glFlush():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glFogf(pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glFogfv(pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glFogi(pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glFogiv(pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glFrontFace(mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glFrustum(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble, zNear:GLdouble, zFar:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glGenLists(range:GLsizei):GLuint:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glGenTextures(n:GLsizei):map {block?} = R'''
	AutoPtr<Array<GLuint> > _textures(new Array<GLuint>(n));
	GLuint *textures = _textures->GetPointer();
	glGenTextures(n, textures);
	return Value::CreateList(env, textures, n);
''' % {`en, 'markdown',
	R'''
	'''
}

glGetBooleanv(pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLboolean> > _params(new Array<GLboolean>(n));
	GLboolean *params = _params->GetPointer();
	glGetBooleanv(pname, params);
	Value _rtnVal;
	Object_list *pObjList = _rtnVal.InitAsList(env, n);
	for (GLsizei i = 0; i < n; i++) {
		pObjList->Add(params[i] != 0);
	}
	return ReturnValue(env, arg, _rtnVal);
''' % {`en, 'markdown',
	R'''
	'''
}

glGetClipPlane(plane:GLenum):map = R'''
	GLdouble equation[4];
	glGetClipPlane(plane, equation);
	return ReturnValue(env, arg, Value::CreateList(env, equation, ArraySizeOf(equation)));
''' % {`en, 'markdown',
	R'''
	'''
}

//glGetColorTable(target:GLenum, format:GLenum, type:GLenum, table:GLvoid@):void:map = `unsupport

/*
glGetColorTableParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetColorTableParameterfv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glGetColorTableParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetColorTableParameteriv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/

//glGetConvolutionFilter(target:GLenum, format:GLenum, type:GLenum, image:GLvoid@):void:map = `unsupport

/*
glGetConvolutionParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetColorTableParameterfv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glGetConvolutionParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetColorTableParameteriv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/

glGetDoublev(pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLdouble> > _params(new Array<GLdouble>(n));
	GLdouble *params = _params->GetPointer();
	glGetDoublev(pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetError():GLenum {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glGetFloatv(pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetFloatv(pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

//glGetHistogram(target:GLenum, reset:GLboolean, format:GLenum, type:GLenum, values:GLvoid@):void:map = `unsupport

/*
glGetHistogramParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetHistogramParameterfv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glGetHistogramParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetHistogramParameteriv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/

glGetIntegerv(pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetIntegerv(pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetLightfv(light:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetLightfv(light, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetLightiv(light:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetLightiv(light, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetMapdv(target:GLenum, query:GLenum, v:GLdouble@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetMapfv(target:GLenum, query:GLenum, v:GLfloat@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetMapiv(target:GLenum, query:GLenum, v:GLint@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetMaterialfv(face:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetMaterialfv(face, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetMaterialiv(face:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetMaterialiv(face, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

//glGetMinmax(target:GLenum, reset:GLboolean, format:GLenum, type:GLenum, values:GLvoid@):void:map = `unsupport

/*
glGetMinmaxParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetMinmaxParameterfv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetMinmaxParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetMinmaxParameteriv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/

glGetPixelMapfv(map:GLenum, values:GLfloat@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetPixelMapuiv(map:GLenum, values:GLuint@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetPixelMapusv(map:GLenum, values:GLushort@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

//glGetPointerv(pname:GLenum, params:GLvoid@@):void:map = `unsupport

glGetPolygonStipple(mask:GLubyte@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

//glGetSeparableFilter(target:GLenum, format:GLenum, type:GLenum, row:GLvoid@, column:GLvoid@, span:GLvoid@):void:map = `unsupport

glGetString(name:GLenum):map {block?} = R'''
	const GLubyte *_rtn = glGetString(name);
	if (_rtn == nullptr) {
		env.SetError(ERR_ValueError, "invalid name");
		return Value::Nil;
	}
	return ReturnValue(env, arg, Value(reinterpret_cast<const char *>(_rtn)));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetTexEnvfv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetTexEnvfv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetTexEnviv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetTexEnviv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetTexGendv(coord:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLdouble> > _params(new Array<GLdouble>(n));
	GLdouble *params = _params->GetPointer();
	glGetTexGendv(coord, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetTexGenfv(coord:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetTexGenfv(coord, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetTexGeniv(coord:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetTexGeniv(coord, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

//glGetTexImage(target:GLenum, level:GLint, format:GLenum, type:GLenum, pixels:GLvoid@):void:map = `unsupport

glGetTexLevelParameterfv(target:GLenum, level:GLint, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetTexLevelParameterfv(target, level, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetTexLevelParameteriv(target:GLenum, level:GLint, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetTexLevelParameteriv(target, level, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetTexParameterfv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetTexParameterfv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetTexParameteriv(target:GLenum, pname:GLenum):map {block?} = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetTexParameteriv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glHint(target:GLenum, mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

/*
glHistogram(target:GLenum, width:GLsizei, internalformat:GLenum, sink:GLboolean):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

glIndexMask(mask:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glIndexPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glIndexd(c:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexdv(c:GLdouble@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexf(c:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexfv(c:GLfloat@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexi(c:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexiv(c:GLint@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexs(c:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexsv(c:GLshort@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexub(c:GLubyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glIndexubv(c:GLubyte@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glInitNames():void = `auto % {`en, 'markdown',
	R'''
	'''
}

//glInterleavedArrays(format:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glIsEnabled(cap:GLenum):GLboolean:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glIsList(list:GLuint):GLboolean:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glIsTexture(texture:GLuint):GLboolean:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glLightModelf(pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLightModelfv(pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLightModeli(pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLightModeliv(pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
	
glLightf(light:GLenum, pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLightfv(light:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLighti(light:GLenum, pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLightiv(light:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLineStipple(factor:GLint, pattern:GLushort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLineWidth(width:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glListBase(base:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLoadIdentity():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glLoadMatrixd(m:GLdouble@matrix:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}

glLoadMatrixf(m:GLfloat@matrix:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}

glLoadName(name:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLogicOp(opcode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMap1d(target:GLenum, u1:GLdouble, u2:GLdouble, stride:GLint, order:GLint, points:array@double):void:map = R'''
	glMap1d(target, u1, u2, stride, order, points->GetPointer());
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glMap1f(target:GLenum, u1:GLfloat, u2:GLfloat, stride:GLint, order:GLint, points:array@float):void:map = R'''
	glMap1f(target, u1, u2, stride, order, points->GetPointer());
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glMap2d(target:GLenum, u1:GLdouble, u2:GLdouble, ustride:GLint, uorder:GLint, v1:GLdouble, v2:GLdouble, vstride:GLint, vorder:GLint, points:array@double):void:map = R'''
	glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points->GetPointer());
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glMap2f(target:GLenum, u1:GLfloat, u2:GLfloat, ustride:GLint, uorder:GLint, v1:GLfloat, v2:GLfloat, vstride:GLint, vorder:GLint, points:array@float):void:map = R'''
	glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points->GetPointer());
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glMapGrid1d(un:GLint, u1:GLdouble, u2:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMapGrid1f(un:GLint, u1:GLfloat, u2:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMapGrid2d(un:GLint, u1:GLdouble, u2:GLdouble, vn:GLint, v1:GLdouble, v2:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMapGrid2f(un:GLint, u1:GLfloat, u2:GLfloat, vn:GLint, v1:GLfloat, v2:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMaterialf(face:GLenum, pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMaterialfv(face:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMateriali(face:GLenum, pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMaterialiv(face:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glMatrixMode(mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

/*
glMinmax(target:GLenum, internalformat:GLenum, sink:GLboolean):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

glMultMatrixd(m:GLdouble@matrix:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}

glMultMatrixf(m:GLfloat@matrix:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}

glNewList(list:GLuint, mode:GLenum):void:map {block?} = R'''
	glNewList(list, mode);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glEndList();
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glNormal3(v:vertex):void:map = R'''
	glNormal3d(v->x, v->y, v->z);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glNormal3b(nx:GLbyte, ny:GLbyte, nz:GLbyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3bv(v:GLbyte@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3d(nx:GLdouble, ny:GLdouble, nz:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3dv(v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3f(nx:GLfloat, ny:GLfloat, nz:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3fv(v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3i(nx:GLint, ny:GLint, nz:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3iv(v:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3s(nx:GLshort, ny:GLshort, nz:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glNormal3sv(v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glNormalPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glOrtho(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble, zNear:GLdouble, zFar:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPassThrough(token:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPixelMapfv(map:GLenum, mapsize:GLint, values:GLfloat@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPixelMapuiv(map:GLenum, mapsize:GLint, values:GLuint@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPixelMapusv(map:GLenum, mapsize:GLint, values:GLushort@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPixelStoref(pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPixelStorei(pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPixelTransferf(pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPixelTransferi(pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPixelZoom(xfactor:GLfloat, yfactor:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPointSize(size:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPolygonMode(face:GLenum, mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPolygonOffset(factor:GLfloat, units:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPolygonStipple(mask:GLubyte@:const):void:map = R'''
	if (_mask->GetSize() != 32 * 4) {
		env.SetError(ERR_ValueError, "mask must contain 32 * 4 elements");
		return Value::Nil;
	}
	glPolygonStipple(mask);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glPopAttrib():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glPopClientAttrib():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glPopMatrix():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glPopName():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glPrioritizeTextures(textures:GLuint@:const, priorities:GLclampf@:const):void:map = R'''
	GLsizei n = _textures->GetSize();
	if (n != _priorities->GetSize()) {
		env.SetError(ERR_ValueError, "textures and priorities must have the same number of elements");
		return Value::Nil;
	}
	glPrioritizeTextures(n, textures, priorities);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glPushAttrib(mask:GLbitfield):void:map {block?} = R'''
	glPushAttrib(mask);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glPopAttrib();
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glPushClientAttrib(mask:GLbitfield):void:map {block?} = R'''
	glPushClientAttrib(mask);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glPopClientAttrib();
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glPushMatrix():void {block?} = R'''
	glPushMatrix();
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glPopMatrix();
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glPushName(name:GLuint):void:map {block?} = R'''
	glPushName(name);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glPopName();
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glRasterPos2d(x:GLdouble, y:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos2dv(v:GLdouble@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos2f(x:GLfloat, y:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos2fv(v:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos2i(x:GLint, y:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos2iv(v:GLint@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos2s(x:GLshort, y:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos2sv(v:GLshort@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos3d(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos3dv(v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos3f(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos3fv(v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos3i(x:GLint, y:GLint, z:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos3iv(v:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos3s(x:GLshort, y:GLshort, z:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos3sv(v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos4d(x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos4dv(v:GLdouble@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos4f(x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos4fv(v:GLfloat@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos4i(x:GLint, y:GLint, z:GLint, w:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos4iv(v:GLint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos4s(x:GLshort, y:GLshort, z:GLshort, w:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRasterPos4sv(v:GLshort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glReadBuffer(mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glReadPixels(x:GLint, y:GLint, width:GLsizei, height:GLsizei, format:symbol):map {block?} = R'''
	Signal &sig = env.GetSignal();
	Image::Format fmt = Image::SymbolToFormat(sig, format);
	if (env.IsSignalled()) return Value::Nil;
	AutoPtr<Image> pImage(new Image(fmt));
	GLenum _format = GetImageFormat(env, pImage.get());
	if (env.IsSignalled()) return Value::Nil;
	if (!pImage->AllocBuffer(sig, width, height, 0xff)) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	glReadPixels(x, y, width, height, _format, type, pImage->GetBuffer());
	return ReturnValue(env, arg, Value(new Object_image(env, pImage.release())));
''' % {`en, 'markdown',
	R'''
	'''
}

glRectd(x1:GLdouble, y1:GLdouble, x2:GLdouble, y2:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRectdv(v1:GLdouble@2:const, v2:GLdouble@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRectf(x1:GLfloat, y1:GLfloat, x2:GLfloat, y2:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRectfv(v1:GLfloat@2:const, v2:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRecti(x1:GLint, y1:GLint, x2:GLint, y2:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRectiv(v1:GLint@2:const, v2:GLint@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRects(x1:GLshort, y1:GLshort, x2:GLshort, y2:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRectsv(v1:GLshort@2:const, v2:GLshort@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRenderMode(mode:GLenum):GLint:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

/*
glResetHistogram(target:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glResetMinmax(target:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

glRotated(angle:GLdouble, x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glRotatef(angle:GLfloat, x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glScaled(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glScalef(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glScissor(x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSelectBuffer(buffer:array@uint:nil):void = R'''
	if (buffer == nullptr) {
		glSelectBuffer(0, nullptr);
	} else {
		glSelectBuffer(buffer->GetSize(), buffer->GetPointer());
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

//glSeparableFilter2D(target:GLenum, internalformat:GLenum, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, row:GLvoid@:const, column:GLvoid@:const):void:map = `unsupport

glShadeModel(mode:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glStencilFunc(func:GLenum, ref:GLint, mask:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glStencilMask(mask:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glStencilOp(fail:GLenum, zfail:GLenum, zpass:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord1d(s:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord1dv(v:GLdouble@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord1f(s:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord1fv(v:GLfloat@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord1i(s:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord1iv(v:GLint@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord1s(s:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord1sv(v:GLshort@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord2d(s:GLdouble, t:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord2dv(v:GLdouble@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord2f(s:GLfloat, t:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord2fv(v:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord2i(s:GLint, t:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord2iv(v:GLint@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord2s(s:GLshort, t:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord2sv(v:GLshort@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord3d(s:GLdouble, t:GLdouble, r:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord3dv(v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord3f(s:GLfloat, t:GLfloat, r:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord3fv(v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord3i(s:GLint, t:GLint, r:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord3iv(v:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord3s(s:GLshort, t:GLshort, r:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord3sv(v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord4d(s:GLdouble, t:GLdouble, r:GLdouble, q:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord4dv(v:GLdouble@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord4f(s:GLfloat, t:GLfloat, r:GLfloat, q:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord4fv(v:GLfloat@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord4i(s:GLint, t:GLint, r:GLint, q:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord4iv(v:GLint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord4s(s:GLshort, t:GLshort, r:GLshort, q:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexCoord4sv(v:GLshort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glTexCoordPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glTexEnvf(target:GLenum, pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexEnvfv(target:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexEnvi(target:GLenum, pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexEnviv(target:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexGend(coord:GLenum, pname:GLenum, param:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexGendv(coord:GLenum, pname:GLenum, params:GLdouble@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexGenf(coord:GLenum, pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexGenfv(coord:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexGeni(coord:GLenum, pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexGeniv(coord:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexImage1D(target:GLenum, level:GLint, internalformat:GLint,
			width:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:any):void:map = R'''
	// check pixels->size()
	const void *p = GetArrayPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glTexImage1D(target, level, internalformat, width, border, format, type, p);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glTexImage1DFromImage(target:GLenum, level:GLint,
			 internalformat:GLint, border:GLint, image:image):void:map = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth()) + border * 2;
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glTexImage2D(target:GLenum, level:GLint, internalformat:GLint,
		width:GLsizei, height:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:any):void:map = R'''
	// check pixels->size()
	const void *p = GetArrayPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glTexImage2D(target, level, internalformat, width, height, border, format, type, p);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}
	
glTexImage2DFromImage(target:GLenum, level:GLint,
			 internalformat:GLint, border:GLint, image:image):void:map = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth()) + border * 2;
	GLsizei height = static_cast<GLsizei>(image->GetHeight()) + border * 2;
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}
	
//glTexImage3D(target:GLenum, level:GLint, internalformat:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, border:GLint, format:GLenum, type:GLenum, pixels:GLvoid@:const):void:map = `unsupport

glTexParameterf(target:GLenum, pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexParameterfv(target:GLenum, pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexParameteri(target:GLenum, pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexParameteriv(target:GLenum, pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint,
			 width:GLsizei, format:GLenum, type:GLenum, pixels:any):void:map = R'''
	// check pixels->size()
	const void *p = GetArrayPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glTexSubImage1D(target, level, xoffset, width, format, type, p);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glTexSubImage1DFromImage(target:GLenum, level:GLint, xoffset:GLint, image:image):void:map = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint,
		width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, pixels:any):void:map = R'''
	// check pixels->size()
	const void *p = GetArrayPointer(env, type, pixels);
	if (p == nullptr) return Value::Nil;
	glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, p);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glTexSubImage2DFromImage(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, image:image):void:map = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = GetImageFormat(env, image);
	if (env.IsSignalled()) return Value::Nil;
	GLenum type = GL_UNSIGNED_BYTE;
	const GLvoid *pixels = reinterpret_cast<const GLvoid *>(image->GetBuffer());
	glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

//glTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, type:GLenum, pixels:GLvoid@:const):void:map = `unsupport

glTranslated(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glTranslatef(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3(v:vertex):void:map = R'''
	glVertex3d(v->x, v->y, v->z);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glVertex4(v:vertex, w:GLdouble):void:map = R'''
	glVertex4d(v->x, v->y, v->z, w);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glVertex2d(x:GLdouble, y:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex2dv(v:GLdouble@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex2f(x:GLfloat, y:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex2fv(v:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex2i(x:GLint, y:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex2iv(v:GLint@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex2s(x:GLshort, y:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex2sv(v:GLshort@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3d(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3dv(v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3f(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3fv(v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3i(x:GLint, y:GLint, z:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3iv(v:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3s(x:GLshort, y:GLshort, z:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex3sv(v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex4d(x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex4dv(v:GLdouble@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex4f(x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex4fv(v:GLfloat@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex4i(x:GLint, y:GLint, z:GLint, w:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex4iv(v:GLint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex4s(x:GLshort, y:GLshort, z:GLshort, w:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertex4sv(v:GLshort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glVertexPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glViewport(x:GLint, y:GLint, width:GLsizei, height:GLsizei):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

/*
glSampleCoverage(value:GLclampf, invert:GLboolean):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glLoadTransposeMatrixf(m:GLfloat@matrix:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glLoadTransposeMatrixd(m:GLdouble@matrix:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultTransposeMatrixf(m:GLfloat@matrix:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultTransposeMatrixd(m:GLdouble@matrix:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

//glCompressedTexImage3D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, height:GLsizei, depth:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexImage2D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, height:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexImage1D(target:GLenum, level:GLint, internalformat:GLenum, width:GLsizei, border:GLint, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexSubImage3D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, zoffset:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexSubImage2D(target:GLenum, level:GLint, xoffset:GLint, yoffset:GLint, width:GLsizei, height:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glCompressedTexSubImage1D(target:GLenum, level:GLint, xoffset:GLint, width:GLsizei, format:GLenum, imageSize:GLsizei, data:GLvoid@:const):void:map = `unsupport

//glGetCompressedTexImage(target:GLenum, lod:GLint, img:GLvoid@):void:map = `unsupport

/*
glActiveTexture(texture:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glClientActiveTexture(texture:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord1d(target:GLenum, s:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord1dv(target:GLenum, v:GLdouble@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord1f(target:GLenum, s:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord1fv(target:GLenum, v:GLfloat@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord1i(target:GLenum, s:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord1iv(target:GLenum, v:GLint@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord1s(target:GLenum, s:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord1sv(target:GLenum, v:GLshort@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord2d(target:GLenum, s:GLdouble, t:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord2dv(target:GLenum, v:GLdouble@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord2f(target:GLenum, s:GLfloat, t:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord2fv(target:GLenum, v:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord2i(target:GLenum, s:GLint, t:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord2iv(target:GLenum, v:GLint@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord2s(target:GLenum, s:GLshort, t:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord2sv(target:GLenum, v:GLshort@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord3d(target:GLenum, s:GLdouble, t:GLdouble, r:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord3dv(target:GLenum, v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord3f(target:GLenum, s:GLfloat, t:GLfloat, r:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord3fv(target:GLenum, v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord3i(target:GLenum, s:GLint, t:GLint, r:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord3iv(target:GLenum, v:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord3s(target:GLenum, s:GLshort, t:GLshort, r:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord3sv(target:GLenum, v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord4d(target:GLenum, s:GLdouble, t:GLdouble, r:GLdouble, q:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord4dv(target:GLenum, v:GLdouble@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord4f(target:GLenum, s:GLfloat, t:GLfloat, r:GLfloat, q:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord4fv(target:GLenum, v:GLfloat@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord4i(target:GLenum, s:GLint, t:GLint, r:GLint, q:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord4iv(target:GLenum, v:GLint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord4s(target:GLenum, s:GLshort, t:GLshort, r:GLshort, q:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiTexCoord4sv(target:GLenum, v:GLshort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glFogCoordf(coord:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glFogCoordfv(coord:GLfloat@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glFogCoordd(coord:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glFogCoorddv(coord:GLdouble@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

//glFogCoordPointer(type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

/*
glSecondaryColor3b(red:GLbyte, green:GLbyte, blue:GLbyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3bv(v:GLbyte@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3d(red:GLdouble, green:GLdouble, blue:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3dv(v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3f(red:GLfloat, green:GLfloat, blue:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3fv(v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3i(red:GLint, green:GLint, blue:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3iv(v:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3s(red:GLshort, green:GLshort, blue:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3sv(v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3ub(red:GLubyte, green:GLubyte, blue:GLubyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3ubv(v:GLubyte@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3ui(red:GLuint, green:GLuint, blue:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3uiv(v:GLuint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3us(red:GLushort, green:GLushort, blue:GLushort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glSecondaryColor3usv(v:GLushort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

//glSecondaryColorPointer(size:GLint, type:GLenum, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

/*
glPointParameterf(pname:GLenum, param:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPointParameterfv(pname:GLenum, params:GLfloat@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPointParameteri(pname:GLenum, param:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glPointParameteriv(pname:GLenum, params:GLint@pname:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glBlendFuncSeparate(srcRGB:GLenum, dstRGB:GLenum, srcAlpha:GLenum, dstAlpha:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glMultiDrawArrays(mode:GLenum, first:GLint@:const, count:GLsizei@:const):void:map = R'''
	GLsizei primcount = first.GetSize();
	if (primcount != count.GetSize()) {
		env.SetError(ERR_ValueError, "first and count must have the same number of elements");
		return Value::Nil;
	}
	glMultiDrawArrays(mode, first, count, primcount);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}
*/

//glMultiDrawElements(mode:GLenum, count:GLsizei@:const, type:GLenum, indices:GLvoid@:const@:const, primcount:GLsizei):void:map = `unsupport

/*
glWindowPos2d(x:GLdouble, y:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos2dv(v:GLdouble@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos2f(x:GLfloat, y:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos2fv(v:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos2i(x:GLint, y:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos2iv(v:GLint@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos2s(x:GLshort, y:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos2sv(v:GLshort@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos3d(x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos3dv(v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos3f(x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos3fv(v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos3i(x:GLint, y:GLint, z:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos3iv(v:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos3s(x:GLshort, y:GLshort, z:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glWindowPos3sv(v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glGenQueries(n:GLsizei):map {block?} = R'''
	AutoPtr<Array<GLuint> > _ids(new Array<GLuint>(n));
	GLuint *ids = _ids->GetPointer();
	glGenQueries(n, ids);
	return ReturnValue(env, arg, Value::CreateList(env, ids, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glDeleteQueries(ids:GLuint@:const):void:map = R'''
	GLsizei n = ids.GetSize();
	glDeleteQueries(n, ids);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glIsQuery(id:GLuint):GLboolean:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glBeginQuery(target:GLenum, id:GLuint):void:map {block?} = R'''
	glBeginQuery(target, id);
	if (arg.IsBlockSpecified()) {
		const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
		if (env.IsSignalled()) return Value::Nil;
		pExprBlock->Exec(env);
		glEndQuery(target);
	}
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glEndQuery(target:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glGetQueryiv(target:GLenum, pname:GLenum):map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetQueryiv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetQueryObjectiv(id:GLuint, pname:GLenum):map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetQueryObjectiv(id, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetQueryObjectuiv(id:GLuint, pname:GLenum):map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLuint> > _params(new Array<GLuint>(n));
	GLuint *params = _params->GetPointer();
	glGetQueryObjectuiv(id, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/
	
/*
glBindBuffer(target:GLenum, buffer:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDeleteBuffers(buffers:GLuint@:const):void:map = R'''
	GLsizei n = buffers.GetSize();
	glDeleteBuffers(n, buffers);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glGenBuffers(n:GLsizei):map {block?} = R'''
	AutoPtr<Array<GLuint> > _buffers(new Array<GLuint>(n));
	GLuint *buffers = _buffers->GetPointer();
	glGenBuffers(n, buffers);
	return Value::CreateList(env, buffers, n);
''' % {`en, 'markdown',
	R'''
	'''
}

glIsBuffer(buffer:GLuint):GLboolean:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

//glBufferData(target:GLenum, size:GLsizeiptr, data:GLvoid@:const, usage:GLenum):void:map = `unsupport

//glBufferSubData(target:GLenum, offset:GLintptr, size:GLsizeiptr, data:GLvoid@:const):void:map = `unsupport

//glGetBufferSubData(target:GLenum, offset:GLintptr, size:GLsizeiptr, data:GLvoid@):void:map = `unsupport

//glMapBuffer(target:GLenum, access:GLenum):GLvoid {block?}@

glUnmapBuffer(target:GLenum):GLboolean:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glGetBufferParameteriv(target:GLenum, pname:GLenum):void:map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetBufferParameteriv(target, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

//glGetBufferPointerv(target:GLenum, pname:GLenum, params:GLvoid@@):void:map = `unsupport

glDrawBuffers(bufs:GLenum@:const):void:map = R'''
	GLsizei n = bufs.GetSize();
	glDrawBuffers(n, bufs);
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glVertexAttrib1d(index:GLuint, x:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib1dv(index:GLuint, v:GLdouble@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib1f(index:GLuint, x:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib1fv(index:GLuint, v:GLfloat@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib1s(index:GLuint, x:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib1sv(index:GLuint, v:GLshort@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib2d(index:GLuint, x:GLdouble, y:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib2dv(index:GLuint, v:GLdouble@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib2f(index:GLuint, x:GLfloat, y:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib2fv(index:GLuint, v:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib2s(index:GLuint, x:GLshort, y:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib2sv(index:GLuint, v:GLshort@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib3d(index:GLuint, x:GLdouble, y:GLdouble, z:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib3dv(index:GLuint, v:GLdouble@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib3f(index:GLuint, x:GLfloat, y:GLfloat, z:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib3fv(index:GLuint, v:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib3s(index:GLuint, x:GLshort, y:GLshort, z:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib3sv(index:GLuint, v:GLshort@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4Nbv(index:GLuint, v:GLbyte@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4Niv(index:GLuint, v:GLint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4Nsv(index:GLuint, v:GLshort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4Nub(index:GLuint, x:GLubyte, y:GLubyte, z:GLubyte, w:GLubyte):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4Nubv(index:GLuint, v:GLubyte@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4Nuiv(index:GLuint, v:GLuint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4Nusv(index:GLuint, v:GLushort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4bv(index:GLuint, v:GLbyte@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4d(index:GLuint, x:GLdouble, y:GLdouble, z:GLdouble, w:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4dv(index:GLuint, v:GLdouble@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4f(index:GLuint, x:GLfloat, y:GLfloat, z:GLfloat, w:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4fv(index:GLuint, v:GLfloat@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4iv(index:GLuint, v:GLint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4s(index:GLuint, x:GLshort, y:GLshort, z:GLshort, w:GLshort):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4sv(index:GLuint, v:GLshort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4ubv(index:GLuint, v:GLubyte@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4uiv(index:GLuint, v:GLuint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glVertexAttrib4usv(index:GLuint, v:GLushort@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glVertexAttribPointer(index:GLuint, size:GLint, type:GLenum, normalized:GLboolean, stride:GLsizei, pointer:GLvoid@:const):void:map = `unsupport

glEnableVertexAttribArray(index:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDisableVertexAttribArray(index:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glGetVertexAttribdv(index:GLuint, pname:GLenum):map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLdouble> > _params(new Array<GLdouble>(n));
	GLdouble *params = _params->GetPointer();
	glGetVertexAttribdv(index, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetVertexAttribfv(index:GLuint, pname:GLenum):map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLfloat> > _params(new Array<GLfloat>(n));
	GLfloat *params = _params->GetPointer();
	glGetVertexAttribfv(index, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetVertexAttribiv(index:GLuint, pname:GLenum):map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetVertexAttribiv(index, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

//glGetVertexAttribPointerv(index:GLuint, pname:GLenum, pointer:GLvoid@@):void:map = `unsupport
*/

/*
glDeleteShader(shader:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDetachShader(program:GLuint, shader:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glCreateShader(type:GLenum):GLuint:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glShaderSource(shader:GLuint, string[]:string):void:map = R'''
	GLsizei count = static_cast<GLsizei>(string.size());
	const GLchar **_string = new const GLchar *[count];
	GLint *length = new GLint[count];
	for (GLint i = 0; i < count; i++) {
		_string[i] = reinterpret_cast<const GLchar *>(string[i].GetString());
		length[i] = static_cast<GLint>(string[i].GetStringSTL().size());
	}
	glShaderSource(shader, count, _string, length);
	delete[] _string;
	delete[] length;
	return Value::Nil;
''' % {`en, 'markdown',
	R'''
	'''
}

glCompileShader(shader:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glCreateProgram():GLuint {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glAttachShader(program:GLuint, shader:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glLinkProgram(program:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUseProgram(program:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glDeleteProgram(program:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glValidateProgram(program:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glUniform1f(location:GLint, v0:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform2f(location:GLint, v0:GLfloat, v1:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform3f(location:GLint, v0:GLfloat, v1:GLfloat, v2:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform4f(location:GLint, v0:GLfloat, v1:GLfloat, v2:GLfloat, v3:GLfloat):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform1i(location:GLint, v0:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform2i(location:GLint, v0:GLint, v1:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform3i(location:GLint, v0:GLint, v1:GLint, v2:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform4i(location:GLint, v0:GLint, v1:GLint, v2:GLint, v3:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform1fv(location:GLint, count:GLsizei, value:GLfloat@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform2fv(location:GLint, count:GLsizei, value:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform3fv(location:GLint, count:GLsizei, value:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform4fv(location:GLint, count:GLsizei, value:GLfloat@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform1iv(location:GLint, count:GLsizei, value:GLint@1:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform2iv(location:GLint, count:GLsizei, value:GLint@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform3iv(location:GLint, count:GLsizei, value:GLint@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniform4iv(location:GLint, count:GLsizei, value:GLint@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniformMatrix2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@2:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniformMatrix3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@3:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glUniformMatrix4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@4:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glIsShader(shader:GLuint):GLboolean:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glIsProgram(program:GLuint):GLboolean:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glGetShaderiv(shader:GLuint, pname:GLenum):void:map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetShaderiv(shader, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}

glGetProgramiv(program:GLuint, pname:GLenum):void:map = R'''
	size_t n = GetParamCount(pname);
	AutoPtr<Array<GLint> > _params(new Array<GLint>(n));
	GLint *params = _params->GetPointer();
	glGetProgramiv(program, pname, params);
	return ReturnValue(env, arg, Value::CreateList(env, params, n));
''' % {`en, 'markdown',
	R'''
	'''
}
*/

glGetAttachedShaders(program:GLuint, maxCount:GLsizei, count:GLsizei@, shaders:GLuint@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetShaderInfoLog(shader:GLuint, bufSize:GLsizei, length:GLsizei@, infoLog:GLchar@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetProgramInfoLog(program:GLuint, bufSize:GLsizei, length:GLsizei@, infoLog:GLchar@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetUniformLocation(program:GLuint, name:GLchar@:const):GLint:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetActiveUniform(program:GLuint, index:GLuint, bufSize:GLsizei, length:GLsizei@, size:GLint@, type:GLenum@, name:GLchar@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetUniformfv(program:GLuint, location:GLint, params:GLfloat@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetUniformiv(program:GLuint, location:GLint, params:GLint@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetShaderSource(shader:GLuint, bufSize:GLsizei, length:GLsizei@, source:GLchar@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glBindAttribLocation(program:GLuint, index:GLuint, name:GLchar@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetActiveAttrib(program:GLuint, index:GLuint, bufSize:GLsizei, length:GLsizei@, size:GLint@, type:GLenum@, name:GLchar@):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glGetAttribLocation(program:GLuint, name:GLchar@:const):GLint:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}

/*
glStencilFuncSeparate(face:GLenum, func:GLenum, ref:GLint, mask:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glStencilOpSeparate(face:GLenum, fail:GLenum, zfail:GLenum, zpass:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glStencilMaskSeparate(face:GLenum, mask:GLuint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

glUniformMatrix2x3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glUniformMatrix3x2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glUniformMatrix2x4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glUniformMatrix4x2fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glUniformMatrix3x4fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glUniformMatrix4x3fv(location:GLint, count:GLsizei, transpose:GLboolean, value:GLfloat@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

}

tmplSource = R"""
// Don't edit this file. This has been generated by Functions.cpp.gura.
#include "stdafx.h"

#if defined(GURA_ON_MSWIN)
typedef char GLchar;
#endif

Gura_BeginModuleScope(${renderer.moduleName})

${renderer.RenderImplementation()}

void AssignFunctions(Environment &env)
{
	${renderer.RenderAssignment()}
}

Gura_EndModuleScope(${renderer.moduleName})
""".template()

cbridge_glcmn.Renderer('opengl', nil).Render(tmplSource, 'Functions.cpp')
