#!/usr/bin/env gura
import(markdown)
import(re)

funcdoc_iterable(funcs+:function) = {
	markdown._funcdoc(
			funcs.each(),
			function.getfullname(funcs):*replace('iterator#', 'iterable#'),
			function.getformat(funcs):*replace('iterator#', 'iterable#'))
}

text = R'''
# re Module

The `re` module provides measures to operate strings with a regular expression.
To utilize it, import the `re` module using `import` function.

This module uses Oniguruma to handle regular expressions.
The official site of Oniguruma is:

[http://www.geocities.jp/kosako3/oniguruma/index.html](http://www.geocities.jp/kosako3/oniguruma/index.html)

This module provides three different forms of function that has the same feature as below:

- Module function
- Method of `re.pattern` class
- Method of `string` class

For example, a feature to match a string with a regular expression can be described as below:

Using a module function:

    m = re.match('gur[ai]', str)

Using a method of `re.pattern` class:

    m = re.pattern('gur[ai]').match(str)

Using a method of `string` class:

    m = str.match('gur[ai]')

The table below shows the features related to regular-expression and functions that provides them.

<table>
<tr><th>Feature</th><th>Module Function</th><th>Method of re.pattern</th><th>Method of string</th></tr>
<tr><td>Match</td>
<td><code>re.match</code></td>
<td><code>re.pattern#match</code></td>
<td><code>string#match</code></td>
</tr>
<tr><td>Subtraction</td>
<td><code>re.sub</code></td>
<td><code>re.pattern#sub</code></td>
<td><code>string#sub</code></td>
</tr>
<tr><td>Split</td>
<td><code>re.split</code></td>
<td><code>re.pattern#split</code></td>
<td><code>string#splitsub</code></td>
</tr>
<tr><td>Scan</td>
<td><code>re.scan</code></td>
<td><code>re.pattern#scan</code></td>
<td><code>string#scan</code></td>
</tr>
</table>

## Regular Expression


## re.match Class

`re.match`, `re.pattern#match` and `string#match`


### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>re.match#string</code></td><td><code>string</code></td><td>R</td>
<td></td></tr>

</table>


### Index Access

A `re.match` instance can be indexed with a `number` or `string` value
that represents a grouping index or a group name.
This has the same effect as calling `re.match#group` method.


### Method

${markdown.funcdoc(
re.match.group
re.match.groups
re.match.start
re.match.end
)}


## Module Function

${markdown.funcdoc(
re.match
re.sub
re.split
re.scan
)}


## re.pattern Class

### Cast Operation

A function that expects a `re.pattern` instance in its argument can also take a value of
`string` below:

- `string` .. Recognized as a regular expression from which `re.pattern` instance is created.

Using the above casting feature, you can call a function `f(pattern:re.pattern)`
that takes a `re.pattern` instance in its argument as below:

- `f(re.pattern('gur[ai]'))` .. The most explicit way.
- `f('gur[ai]')` .. Implicit casting: from `string` to `re.pattern`.


### Function to Create Instance

${markdown.funcdoc(
re.pattern
)}

### Method

${markdown.funcdoc(
re.pattern.match
re.pattern.sub
re.pattern.split
re.pattern.scan
)}


## Extension to string Class

This module extends the `string` class with methods described here.

${markdown.funcdoc(
string.match
string.sub
string.splitreg
string.scan
)}


## Extension to iterable Classes

This module extends the iterable classes, `list` and `iterator`, with methods described here.

${funcdoc_iterable(
iterator.grep
)}

'''.template().render()

write(doc:markdown.document) = {
	doc << text
	doc
}

if (__name__ == '__main__') {
	write(markdown.document()).render@html(sys.stdout)
}
