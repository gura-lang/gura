%
% automatically generated by HelpGen $Revision: 42795 $ from
% include/wx/stream.h at 28/Oct/06 18:49:10
%

\section{\class{wxFilterClassFactory}}\label{wxfilterclassfactory}

Allows the creation of filter streams to handle compression formats such
as gzip and bzip2.

For example, given a filename you can search for a factory that will
handle it and create a stream to decompress it:

\begin{verbatim}
    factory = wxFilterClassFactory::Find(filename, wxSTREAM_FILEEXT);
    if (factory)
        stream = factory->NewStream(new wxFFileInputStream(filename));
\end{verbatim}

\helpref{Find()}{wxfilterclassfactoryfind} can also search
for a factory by MIME type, HTTP encoding or by wxFileSystem protocol.
The available factories can be enumerated
using \helpref{GetFirst() and GetNext()}{wxfilterclassfactorygetfirst}.

\wxheading{Derived from}

\helpref{wxObject}{wxobject}

\wxheading{Include files}

<wx/stream.h>

\wxheading{Data structures}

\begin{verbatim}
enum wxStreamProtocolType
{
    wxSTREAM_PROTOCOL,  // wxFileSystem protocol (should be only one)
    wxSTREAM_MIMETYPE,  // MIME types the stream handles
    wxSTREAM_ENCODING,  // The HTTP Content-Encodings the stream handles
    wxSTREAM_FILEEXT    // File extensions the stream handles
};

\end{verbatim}

\wxheading{See also}

\helpref{wxFilterInputStream}{wxfilterinputstream}\\
\helpref{wxFilterOutputStream}{wxfilteroutputstream}\\
\helpref{wxArchiveClassFactory}{wxarchiveclassfactory}\\
\helpref{Archive formats such as zip}{wxarc}

\latexignore{\rtfignore{\wxheading{Members}}}


\membersection{wxFilterClassFactory::CanHandle}\label{wxfilterclassfactorycanhandle}

\constfunc{bool}{CanHandle}{\param{const wxChar* }{protocol}, \param{wxStreamProtocolType }{type = wxSTREAM\_PROTOCOL}}

Returns true if this factory can handle the given protocol, MIME type, HTTP
encoding or file extension.

When using wxSTREAM\_FILEEXT for the second parameter, the first parameter
can be a complete filename rather than just an extension.


\membersection{wxFilterClassFactory::Find}\label{wxfilterclassfactoryfind}

\func{static const wxFilterClassFactory*}{Find}{\param{const wxChar* }{protocol}, \param{wxStreamProtocolType }{type = wxSTREAM\_PROTOCOL}}

A static member that finds a factory that can handle a given protocol, MIME
type, HTTP encoding or file extension.  Returns a pointer to the class
factory if found, or NULL otherwise. It does not give away ownership of the
factory.

When using wxSTREAM\_FILEEXT for the second parameter, the first parameter
can be a complete filename rather than just an extension.


\membersection{wxFilterClassFactory::GetFirst/GetNext}\label{wxfilterclassfactorygetfirst}

\func{static const wxFilterClassFactory*}{GetFirst}{\void}

\constfunc{const wxFilterClassFactory*}{GetNext}{\void}

GetFirst and GetNext can be used to enumerate the available factories.

For example, to list them:

\begin{verbatim}
    wxString list;
    const wxFilterClassFactory *factory = wxFilterClassFactory::GetFirst();

    while (factory) {
        list << factory->GetProtocol() << _T("\n");
        factory = factory->GetNext();
    }

\end{verbatim}

GetFirst()/GetNext() return a pointer to a factory or NULL if no more
are available. They do not give away ownership of the factory.


\membersection{wxFilterClassFactory::GetProtocol}\label{wxfilterclassfactorygetprotocol}

\constfunc{wxString}{GetProtocol}{\void}

Returns the wxFileSystem protocol supported by this factory. Equivalent
to wxString(*GetProtcols()).


\membersection{wxFilterClassFactory::GetProtocols}\label{wxfilterclassfactorygetprotocols}

\constfunc{const wxChar * const*}{GetProtocols}{\param{wxStreamProtocolType }{type = wxSTREAM\_PROTOCOL}}

Returns the protocols, MIME types, HTTP encodings or file extensions
supported by this factory, as an array of null terminated strings. It does
not give away ownership of the array or strings.

For example, to list the file extensions a factory supports:

\begin{verbatim}
    wxString list;
    const wxChar *const *p;

    for (p = factory->GetProtocols(wxSTREAM_FILEEXT); *p; p++)
        list << *p << _T("\n");

\end{verbatim}


\membersection{wxFilterClassFactory::NewStream}\label{wxfilterclassfactorynewstream}

\constfunc{wxFilterInputStream*}{NewStream}{\param{wxInputStream\& }{stream}}

\constfunc{wxFilterOutputStream*}{NewStream}{\param{wxOutputStream\& }{stream}}

\constfunc{wxFilterInputStream*}{NewStream}{\param{wxInputStream* }{stream}}

\constfunc{wxFilterOutputStream*}{NewStream}{\param{wxOutputStream* }{stream}}

Create a new input or output stream to decompress or compress a given stream.

If the parent stream is passed as a pointer then the new filter stream
takes ownership of it. If it is passed by reference then it does not.


\membersection{wxFilterClassFactory::PopExtension}\label{wxfilterclassfactorypopextension}

\constfunc{wxString}{PopExtension}{\param{const wxString\& }{location}}

Remove the file extension of {\it location} if it is one of the file
extensions handled by this factory.


\membersection{wxFilterClassFactory::PushFront}\label{wxfilterclassfactorypushfront}

\func{void}{PushFront}{\void}

Adds this class factory to the list returned
by \helpref{GetFirst()/GetNext()}{wxfilterclassfactorygetfirst}.

It is not necessary to do this to use the filter streams. It is usually
used when implementing streams, typically the implementation will 
add a static instance of its factory class.

It can also be used to change the order of a factory already in the list,
bringing it to the front. This isn't a thread safe operation
so can't be done when other threads are running that will be using the list.

The list does not take ownership of the factory.


\membersection{wxFilterClassFactory::Remove}\label{wxfilterclassfactoryremove}

\func{void}{Remove}{\void}

Removes this class factory from the list returned
by \helpref{GetFirst()/GetNext()}{wxfilterclassfactorygetfirst}.

Removing from the list isn't a thread safe operation
so can't be done when other threads are running that will be using the list.

The list does not own the factories, so removing a factory does not delete it.

