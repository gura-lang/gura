#!/usr/bin/env gura
import(markdown)

funcdoc_array(funcs+:function) = {
	markdown._funcdoc(
			funcs.each(),
			function.getfullname(funcs):*replace('@char', '@T'),
			function.getformat(funcs):*replace('@char', '@T'))
}

//-----------------------------------------------------------------------------
text = R'''
# Built-in Operators

<table>
<tr><th>Operation</th><th>Explanation</th></tr>
<tr><td><code>+number</code></td><td></td></tr>
<tr><td><code>+complex</code></td><td></td></tr>
<tr><td><code>+rational</code></td><td></td></tr>
<tr><td><code>+matrix</code></td><td></td></tr>
<tr><td><code>+timedelta</code></td><td></td></tr>
<tr><td><code>+array@char</code></td><td></td></tr>
<tr><td><code>+array@uchar</code></td><td></td></tr>
<tr><td><code>+array@short</code></td><td></td></tr>
<tr><td><code>+array@ushort</code></td><td></td></tr>
<tr><td><code>+array@long</code></td><td></td></tr>
<tr><td><code>+array@ulong</code></td><td></td></tr>
<tr><td><code>+array@int</code></td><td></td></tr>
<tr><td><code>+array@uint</code></td><td></td></tr>
<tr><td><code>+array@float</code></td><td></td></tr>
<tr><td><code>+array@double</code></td><td></td></tr>
<tr><td><code>-number</code></td><td></td></tr>
<tr><td><code>-complex</code></td><td></td></tr>
<tr><td><code>-rational</code></td><td></td></tr>
<tr><td><code>-matrix</code></td><td></td></tr>
<tr><td><code>-timedelta</code></td><td></td></tr>
<tr><td><code>-array@char</code></td><td></td></tr>
<tr><td><code>-array@uchar</code></td><td></td></tr>
<tr><td><code>-array@short</code></td><td></td></tr>
<tr><td><code>-array@ushort</code></td><td></td></tr>
<tr><td><code>-prray@long</code></td><td></td></tr>
<tr><td><code>-array@ulong</code></td><td></td></tr>
<tr><td><code>-array@int</code></td><td></td></tr>
<tr><td><code>-array@uint</code></td><td></td></tr>
<tr><td><code>-array@float</code></td><td></td></tr>
<tr><td><code>-array@double</code></td><td></td></tr>
<tr><td><code>~number</code></td><td></td></tr>
<tr><td><code>!any</code></td><td></td></tr>
<tr><td><code>number..</code></td><td></td></tr>
<tr><td><code>any?</code></td><td></td></tr>
<tr><td><code>any*</code></td><td></td></tr>
<tr><td><code>number + number</code></td><td></td></tr>
<tr><td><code>number + complex</code></td><td></td></tr>
<tr><td><code>number + rational</code></td><td></td></tr>
<tr><td><code>complex + number</code></td><td></td></tr>
<tr><td><code>complex + complex</code></td><td></td></tr>
<tr><td><code>rational + number</code></td><td></td></tr>
<tr><td><code>rational + rational</code></td><td></td></tr>
<tr><td><code>matrix + matrix</code></td><td></td></tr>
<tr><td><code>datetime + timedelta</code></td><td></td></tr>
<tr><td><code>timedelta + datetime</code></td><td></td></tr>
<tr><td><code>string + string</code></td><td></td></tr>
<tr><td><code>binary + binary</code></td><td></td></tr>
<tr><td><code>binary + string</code></td><td></td></tr>
<tr><td><code>string + binary</code></td><td></td></tr>
<tr><td><code>pointer + number</code></td><td></td></tr>
<tr><td><code>string + any</code></td><td></td></tr>
<tr><td><code>any + string</code></td><td></td></tr>
<tr><td><code>number - number</code></td><td></td></tr>
<tr><td><code>number - complex</code></td><td></td></tr>
<tr><td><code>number - rational</code></td><td></td></tr>
<tr><td><code>complex - number</code></td><td></td></tr>
<tr><td><code>complex - complex</code></td><td></td></tr>
<tr><td><code>rational - number</code></td><td></td></tr>
<tr><td><code>rational - rational</code></td><td></td></tr>
<tr><td><code>matrix - matrix</code></td><td></td></tr>
<tr><td><code>datetime - timedelta</code></td><td></td></tr>
<tr><td><code>datetime - datetime</code></td><td></td></tr>
<tr><td><code>timedelta - timedelta</code></td><td></td></tr>
<tr><td><code>color - color</code></td><td></td></tr>
<tr><td><code>pointer - number</code></td><td></td></tr>
<tr><td><code>pointer - pointer</code></td><td></td></tr>
</table>

# Built-in Classes
'''.template().render()

//-----------------------------------------------------------------------------
text@Class = R'''
## Class Class
'''.template().render()

//-----------------------------------------------------------------------------
text@Module = R'''
## Module Class
'''.template().render()

//-----------------------------------------------------------------------------
text@Sequence = R'''
## Sequence Class
'''.template().render()

//-----------------------------------------------------------------------------
text@any = R'''
## any Class
'''.template().render()

//-----------------------------------------------------------------------------
text@args = R'''
## args Class

The `args` class provides measures to access argument information that is passed to a function.
One of its purposes is to check if an attribute is specified in the function call.
It also provides a method to control a leader-trailer sequence,
a mechanism that flow controls such as `if-elsif-else` and `try-catch` utilize.

There's no constructor to realize an instance of `args` class.
Its instance is implicitly created when a function is called,
and you can refer to it by a variable named `__args__`.

Below is an example to use `args` class:

    func(v0, v1, v2):[attr1,attr2] = {
        printf('arg#%d %s\n', 0.., __args__.values)
        printf('attr1:%s attr2:%s\n', __args__.isset(`attr1), __args__.isset(`attr2))
    }

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>args#values</code></td><td><code>list</code></td><td>R</td>
<td>A list of argument values.</td></tr>

</table>

### Method

${markdown.funcdoc(
args.finalize_trailer
args.isset
args.quit_trailer
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@array = R'''
## array Class

An instance of the `array` class stores multiple numeric values in a seamless binary sequence,
which can be passed without any conversion to functions in C libraries
that expect arrays of `char`, `short`, `int` and so on.

There are several `array` classes depending on the element type they handle.
They're listed in the the table below:

<table>
<tr><th>Class Name</th><th>Element Type</th></tr>
<tr><td><code>array@char</code></td><td><code>char</code></td></tr>
<tr><td><code>array@uchar</code></td><td><code>unsigned char</code></td></tr>
<tr><td><code>array@short</code></td><td><code>short</code></td></tr>
<tr><td><code>array@ushort</code></td><td><code>unsigned short</code></td></tr>
<tr><td><code>array@long</code></td><td><code>long</code></td></tr>
<tr><td><code>array@ulong</code></td><td><code>unsigned long</code></td></tr>
<tr><td><code>array@int</code></td><td><code>int</code></td></tr>
<tr><td><code>array@uint</code></td><td><code>unsigned int</code></td></tr>
<tr><td><code>array@float</code></td><td><code>float</code></td></tr>
<tr><td><code>array@double</code></td><td><code>double</code></td></tr>
</table>

### Function to Create Instance

${funcdoc_array(
array@char
)}

### Method

${funcdoc_array(
array@char.dump
array@char.each
array@char.fill
array@char.head,
array@char.offset
array@char.paste
array@char.tail
)}

'''.template().render()

//-----------------------------------------------------------------------------
text@audio = R'''
## audio Class

The `audio` class provides measures to work on audio data.

### Method

${markdown.funcdoc(
audio.each
audio.get
audio.put
audio.sinewave
audio.store
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@binary = R'''
## binary Class

The `binary` class provides measures to work on binary data
that is a byte sequence without any format.

You can create a `binary` instance by calling `binary()` function.

You can also create the instance by specifying `b` prefix before a string literal.
For example, the code below creates a `binary` instance that contains a sequence
`0x41, 0x42, 0xfe, 0x03, 0x43, 0x44`.

    b'AB\xfe\x03CD'

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>binary#writable</code></td><td><code>boolean</code></td><td>R</td>
<td>Indicates if the content of the binary object is writable.</td></tr>

</table>

### Function to Create Instance

${markdown.funcdoc(
binary
)}

### Method

${markdown.funcdoc(
binary.add
binary.alloc
binary.decode
binary.dump
binary.each
binary.encodeuri
binary.hex
binary.len
binary.pack
binary.pointer
binary.reader
binary.store
binary.unpack
binary.unpacks
binary.writer
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@boolean = R'''
## boolean Class
'''.template().render()

//-----------------------------------------------------------------------------
text@codec = R'''
## codec Class

The `codec` class provides measures to convert character codes.

### Predefined Variable

<table>
<tr><th>Variable</th><th>Type</th><th>Explanation</th></tr>

<tr><td><code>codec.bom@utf8</code></td><td><code>binary</code></td>
<td>BOM sequence of UTF-8</td></tr>

<tr><td><code>codec.bom@utf16le</code></td><td><code>binary</code></td>
<td>BOM sequence of UTF-16 little endian</td></tr>

<tr><td><code>codec.bom@utf16be</code></td><td><code>binary</code></td>
<td>BOM sequence of UTF-16 big endian</td></tr>

<tr><td><code>codec.bom@utf32le</code></td><td><code>binary</code></td>
<td>BOM sequence of UTF-32 little endian</td></tr>

<tr><td><code>codec.bom@utf32be</code></td><td><code>binary</code></td>
<td>BOM sequence of UTF-32 big endian</td></tr>

</table>

### Function to Create Instance

${markdown.funcdoc(
codec
)}

### Method

${markdown.funcdoc(
codec.addcr
codec.decode
codec.delcr
codec.encode
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@color = R'''
## color Class

An instance of the `color` class represents a color data that consists of red, green, blue and alpha elements.

You can create a `color` instance by calling `color()` function.

There are class variables as shown below:

### Predefined Variable

<table>
<tr><th>Variable</th><th>Type</th><th>Explanation</th></tr>

<tr><td><code>color.names</code></td><td><code>string[]</code></td>
<td>A list of color names that can be passed to <code>color()</code> function.</td></tr>

<tr><td><code>color.zero</code></td><td><code>color</code></td>
<td>color instance created by <code>color(0, 0, 0, 0)</code></td></tr>

</table>

There are also predefined variables that are defined with `color` instances of 16 basic colors:
`color.black`, `color.maroon`, `color.green`, `color.olive`, `color.navy`, `color.purple`,
`color.teal`, `color.gray`, `color.silver`, `color.red`, `color.lime`, `color.yellow`,
`color.blue`, `color.fuchsia`, `color.aqua` and `color.white`.

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>color#r</code></td><td><code>number</code></td><td>R/W</td>
<td>Value of the red element.</td></tr>

<tr><td><code>color#g</code></td><td><code>number</code></td><td>R/W</td>
<td>Value of the green element.</td></tr>

<tr><td><code>color#b</code></td><td><code>number</code></td><td>R/W</td>
<td>Value of the blue element.</td></tr>

<tr><td><code>color#a</code></td><td><code>number</code></td><td>R/W</td>
<td>Value of the alpha element.</td></tr>

</table>

### Cast

A function that expects a `color` instance in its argument can take a value of
`symbol`, `string` and `list` as below:

- `symbol` .. Recognized as a color name to look up the color table.
- `string` .. Recognized as a color name to look up the color table.
- `list` .. Expected to contain elements in a format `[red, green, blue]` or
  `[red, green, blue, alpha]`.

With the above casting feature, you can call a function `f(c:color)`
that takes a `color` instance in its argument as below:

- ``f(color(`purple))`` .. The most explicit way.
- ``f(`purple)`` .. Implicit casting: from `symbol` to `color`.
- `f('purple')` .. Implicit casting: from `string` to `color`.
- `f([128, 0, 128])` .. Implicit casting: from `list` to `color`.


### Function to Create Instance

${markdown.funcdoc(
color
)}

### Method

${markdown.funcdoc(
color.getgray
color.html
color.tolist
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@complex = R'''
## complex Class

The `complex` class provides measures to calculate complex numbers.

You can create a `complex` instance by following ways:

- Use `complex()` function.
- Use `complex.polar()` function.
- Append `j` suffix after a number literal.

Below are examples to realize a complex number that has 2 as its real part
and 3 as its imaginal part.

    complex(2, 3)
    2 + 3j

### Function to Create Instance

${markdown.funcdoc(
complex
)}

### Method

${markdown.funcdoc(
complex.polar
complex.roundoff
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@datetime = R'''
## datetime Class

The `datetime` class provides measures to handle date and time information.

You can create a `datetime` instance by calling following functions:

- `datetime()` .. Creates from specified date and time.
- `datetime.now()` .. Creates from the current date and time.
- `datetime.today()` .. Creates from the current date. The time is set to 00:00:00.

You can calculate between `datetime` and `timedelta` to put it forward and backward.

### Predefined Variable

<table>
<tr><th>Variable</th><th>Type</th><th>Explanation</th></tr>

<tr><td><code>datetime.Sunday</code></td><td><code>number</code></td>
<td>Assigned with number 0 that represents Sunday.</td></tr>

<tr><td><code>datetime.Monday</code></td><td><code>number</code></td>
<td>Assigned with number 1 that represents Monday.</td></tr>

<tr><td><code>datetime.Tuesday</code></td><td><code>number</code></td>
<td>Assigned with number 2 that represents Tuesday.</td></tr>

<tr><td><code>datetime.Wednesday</code></td><td><code>number</code></td>
<td>Assigned with number 3 that represents Wednesday.</td></tr>

<tr><td><code>datetime.Thursday</code></td><td><code>number</code></td>
<td>Assigned with number 4 that represents Thursday.</td></tr>

<tr><td><code>datetime.Friday</code></td><td><code>number</code></td>
<td>Assigned with number 5 that represents Friday.</td></tr>

<tr><td><code>datetime.Saturday</code></td><td><code>number</code></td>
<td>Assigned with number 6 that represents Saturday.</td></tr>

</table>

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>datetime#year</code></td><td><code>number</code></td><td>R/W</td>
<td>Chritian year.</td></tr>

<tr><td><code>datetime#month</code></td><td><code>number</code></td><td>R/W</td>
<td>Month starting from 1. Numbers from 1 to 12 correspond to January to December.</td></tr>

<tr><td><code>datetime#day</code></td><td><code>number</code></td><td>R/W</td>
<td>Day in a month starting from 1. </td></tr>

<tr><td><code>datetime#hour</code></td><td><code>number</code></td><td>R/W</td>
<td>Hour in a day between 0 and 23.</td></tr>

<tr><td><code>datetime#min</code></td><td><code>number</code></td><td>R/W</td>
<td>Minute in an hour between 0 and 59.</td></tr>

<tr><td><code>datetime#sec</code></td><td><code>number</code></td><td>R/W</td>
<td>Second in a minute between 0 and 59.</td></tr>

<tr><td><code>datetime#usec</code></td><td><code>number</code></td><td>R/W</td>
<td>Millisecond in a second between 0 and 999.</td></tr>

<tr><td><code>datetime#wday</code></td><td><code>number</code></td><td>R</td>
<td>Week number starting from 0. Number from 0 to 6 corresponds to Sunday to Saturday.</td></tr>

<tr><td><code>datetime#week</code></td><td><code>number</code></td><td>R</td>
<td>
Week symbol that takes one of the followings:
<code>`sunday</code>, <code>`monday</code>, <code>`tuesday</code>, <code>`wednesday</code>,
<code>`thursday</code>, <code>`friday</code>, <code>`saturday</code>
</td></tr>

<tr><td><code>datetime#yday</code></td><td><code>number</code></td><td>R</td>
<td>Day in a year starting from 1.</td></tr>

<tr><td><code>datetime#unixtime</code></td><td><code>number</code></td><td>R</td>
<td>Seconds passed from 00:00:00 on January 1st in 1970 in UTC.</td></tr>

</table>

### Function to Create Instance

${markdown.funcdoc(
datetime
)}

### Method

${markdown.funcdoc(
datetime.clrtzoff
datetime.format
datetime.isleap
datetime.monthdays
datetime.now
datetime.parse
datetime.settzoff
datetime.time
datetime.today
datetime.utc
datetime.weekday
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@declaration = R'''
## declaration Class

The `declaration` class provides information about argument's declaration defined in a function.
You can get an iterator of `declaration` instances with the following measures
that the `function` class provides:

- `function#decls`
- `function.getdecls()`

Below is an example to print argument names declared in a function.

    f(a, b, c, d) = {}
	println(f.decls:*name)


### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>declaration#symbol</code></td><td><code>symbol</code></td><td>R</td>
<td>The name of the declaration in symbol.</td></tr>

<tr><td><code>declaration#name</code></td><td><code>string</code></td><td>R</td>
<td>The name of the declaration in string.</td></tr>

<tr><td><code>declaration#default</code></td><td><code>expr</code></td><td>R</td>
<td>The expression that provides a default value.</td></tr>

</table>

### Method

${markdown.funcdoc(
declaration.istype
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@dict = R'''
## dict Class

The `dict` class provides measures to handle dictionary data.

You can create a `dict` instance by calling `dict()` function.

You can also use a function named `%` to create an instance
that is an alias of `dict()` function.

### Function to Create Instance

${markdown.funcdoc(
dict
)}

### Method

${markdown.funcdoc(
dict.append
dict.clear
dict.erase
dict.get
dict.haskey
dict.items
dict.keys
dict.len
dict.put
dict.values
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@directory = R'''
## directory Class

The `directory` class handles information necessary to seek directory structure in a path.
Its instance usually works with functions in `path` module: `path.dir()` and `path.walk()`.

Though the instance can be created by `directory()` function,
you don't have to use it in many cases because a casting from `string` to `directory` instance
works implicitly in a function call.

### Function to Create Instance

${markdown.funcdoc(
directory
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@environment = R'''
## environment Class

The `environment` class provides measures to operate variables in an environment,
which is a fundamental mechanism to store variables.

### Method

${markdown.funcdoc(
environment.getprop!
environment.lookup
environment.setprop!
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@error = R'''
## error Class

The `error` class provides measures to access error information.

There is no measures to create an `error` instance.
They're instantiated and passed to a block of `catch()` function
when an error occurs within a `try` block in a `try-catch` sequence.

In the following code, `e` is an instance that contains information
about an error that has occured in the `try` block.

    try {
        // any jobs
    } catch {|e:error|
        // ...
    }

### Predefined Variable

<table>
<tr><th>Variable</th><th>Explanation</th></tr>

<tr><td><code>error.ArgumentError</code></td>
<td></td></tr>

<tr><td><code>error.ArithmeticError</code></td>
<td></td></tr>

<tr><td><code>error.AttributeError</code></td>
<td></td></tr>

<tr><td><code>error.CodecError</code></td>
<td></td></tr>

<tr><td><code>error.CommandError</code></td>
<td></td></tr>

<tr><td><code>error.DeclarationError</code></td>
<td></td></tr>

<tr><td><code>error.FormatError</code></td>
<td></td></tr>

<tr><td><code>error.IOError</code></td>
<td></td></tr>

<tr><td><code>error.ImportError</code></td>
<td></td></tr>

<tr><td><code>error.IndexError</code></td>
<td></td></tr>

<tr><td><code>error.IteratorError</code></td>
<td></td></tr>

<tr><td><code>error.KeyError</code></td>
<td></td></tr>

<tr><td><code>error.MemberAccessError</code></td>
<td></td></tr>

<tr><td><code>error.MemoryError</code></td>
<td></td></tr>

<tr><td><code>error.NameError</code></td>
<td></td></tr>

<tr><td><code>error.NotImplementedError</code></td>
<td></td></tr>

<tr><td><code>error.OutOfRange</code></td>
<td></td></tr>

<tr><td><code>error.ResourceError</code></td>
<td></td></tr>

<tr><td><code>error.RuntimeError</code></td>
<td></td></tr>

<tr><td><code>error.SyntaxError</code></td>
<td></td></tr>

<tr><td><code>error.SystemError</code></td>
<td></td></tr>

<tr><td><code>error.TypeError</code></td>
<td></td></tr>

<tr><td><code>error.ValueError</code></td>
<td></td></tr>

<tr><td><code>error.ZeroDivisionError</code></td>
<td></td></tr>

</table>

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>error#source</code></td><td><code>string</code></td><td>R</td>
<td>The name of the file that causes this error.</td></tr>

<tr><td><code>error#lineno</code></td><td><code>number</code></td><td>R</td>
<td>The number of line where the expression that causes this error starts.</td></tr>

<tr><td><code>error#linenobtm</code></td><td><code>number</code></td><td>R</td>
<td>The number of line where the expression that causes this error ends.</td></tr>

<tr><td><code>error#postext</code></td><td><code>string</code></td><td>R</td>
<td>A text that consists of a source name and a line number.</td></tr>

<tr><td><code>error#text</code></td><td><code>string</code></td><td>R</td>
<td>An error message.
If an attribute `:lineno` is specified, it would contain a line number.</td></tr>

<tr><td><code>error#trace</code></td><td><code>expr[]</code></td><td>R</td>
<td>Stack trace.</td></tr>

</table>

'''.template().render()

//-----------------------------------------------------------------------------
text@expr = R'''
## expr Class

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>expr#attrfront</code></td><td><code>symbol[]</code></td><td>R</td>
<td>Exists in "identifier" and "caller".</td></tr>

<tr><td><code>expr#attrs</code></td><td><code>symbol[]</code></td><td>R</td>
<td>Exists in "identifier" and "caller".</td></tr>

<tr><td><code>expr#attrsopt</code></td><td><code>symbol[]</code></td><td>R</td>
<td>Exists in "identifier" and "caller".</td></tr>

<tr><td><code>expr#block</code></td><td><code>expr</code></td><td>R</td>
<td>Exists in "caller".</td></tr>

<tr><td><code>expr#blockparam</code></td><td><code>iterator</code></td><td>R</td>
<td>Exists in "block".</td></tr>

<tr><td><code>expr#body</code></td><td><code>string</code></td><td>R</td>
<td>Exists in "suffixed".</td></tr>

<tr><td><code>expr#car</code></td><td><code>expr</code></td><td>R</td>
<td>Exists in "compound".</td></tr>

<tr><td><code>expr#cdr</code></td><td><code>iterator</code></td><td>R</td>
<td>Exists in "compound".</td></tr>

<tr><td><code>expr#child</code></td><td><code>expr</code></td><td>R</td>
<td>Exists in "unary".</td></tr>

<tr><td><code>expr#children</code></td><td><code>iterator</code></td><td>R</td>
<td>Exists in "collector".</td></tr>

<tr><td><code>expr#left</code></td><td><code>expr</code></td><td>R</td>
<td>Exists in "binary".</td></tr>

<tr><td><code>expr#lineno</code></td><td><code>number</code></td><td>R</td>
<td></td></tr>

<tr><td><code>expr#linenobtm</code></td><td><code>number</code></td><td>R</td>
<td></td></tr>

<tr><td><code>expr#operator</code></td><td><code>operator</code></td><td>R</td>
<td>Exists in "unaryop", "binaryop" and "assign".</td></tr>

<tr><td><code>expr#postext</code></td><td><code>string</code></td><td>R</td>
<td></td></tr>

<tr><td><code>expr#right</code></td><td><code>expr</code></td><td>R</td>
<td>Exists in "binary".</td></tr>

<tr><td><code>expr#source</code></td><td><code>string</code></td><td>R</td>
<td></td></tr>

<tr><td><code>expr#suffix</code></td><td><code>symbol</code></td><td>R</td>
<td>Exists in "suffixed".</td></tr>

<tr><td><code>expr#symbol</code></td><td><code>symbol</code></td><td>R</td>
<td>Exists in "identifier".</td></tr>

<tr><td><code>expr#trailer</code></td><td><code>expr</code></td><td>R</td>
<td>Exists in "caller".</td></tr>

<tr><td><code>expr#typename</code></td><td><code>string</code></td><td>R</td>
<td></td></tr>

<tr><td><code>expr#typesym</code></td><td><code>symbol</code></td><td>R</td>
<td></td></tr>

<tr><td><code>expr#value</code></td><td><code>any</code></td><td>R</td>
<td>Exists in "value".</td></tr>

</table>

### Function to Create Instance

${markdown.funcdoc(
expr
)}

### Method

${markdown.funcdoc(
expr.eval
expr.parse
expr.textize
expr.tofunction
expr.unquote
expr.write
// type chekers - Unary and descendants
expr.isunary
expr.isunaryop
expr.isquote
// type chekers - Binary and descendants
expr.isbinary
expr.isbinaryop
expr.isassign
expr.ismember
// type chekers - Collector and descendants
expr.iscollector
expr.isroot
expr.isblock
expr.islister
expr.isiterer
// type chekers - Compound and descendants
expr.iscompound
expr.isindexer
expr.iscaller
// type chekers - others
expr.isvalue
expr.isidentifier
expr.issuffixed
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@formatter = R'''
## formatter Class

The `formatter` class provides information about a format specifier.

The function `printf()` has the following declaration:

    printf(format:string, values*)

The argument `format` is a string containing format specifiers like `%d` and `%s`
that correspond to instances specified by the arguments `values`.
When a qualifier is found during the evaluation of the function,
a format handler associated with an corresponding instance is called.
Format handlers are instance methods named like `__format_X__()`
where `X` is the symbol of the specifier.
For example, the instance method `__format_d__()` is responsible to work on a spcifier `%d`.

The `formatter` instance is created for each specifier and passed to a method like
`__format_X__(fmt:formatter)`. Below is a table showing specifiers and corresponding method names:

<table>
<tr><th>Specifier</th><th>Method Name</th></tr>
<tr><td><code>%d</code></td><td><code>__format_d__</code></td></tr>
<tr><td><code>%u</code></td><td><code>__format_u__</code></td></tr>
<tr><td><code>%b</code></td><td><code>__format_b__</code></td></tr>
<tr><td><code>%o</code></td><td><code>__format_o__</code></td></tr>
<tr><td><code>%x</code></td><td><code>__format_x__</code></td></tr>
<tr><td><code>%e</code></td><td><code>__format_e__</code></td></tr>
<tr><td><code>%f</code></td><td><code>__format_f__</code></td></tr>
<tr><td><code>%g</code></td><td><code>__format_g__</code></td></tr>
<tr><td><code>%s</code></td><td><code>__format_s__</code></td></tr>
<tr><td><code>%c</code></td><td><code>__format_c__</code></td></tr>
</table>

### Method

${markdown.funcdoc(
formatter.getminwidth
formatter.getpadding
formatter.getplusmode
formatter.getprecision
formatter.isleftalign
formatter.issharp
formatter.isuppercase
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@function = R'''
## function Class

The `function` class provides measure to inspect information about the instance.

All the functions are instances of `function` class,
so an implementation of a function means a realization of a `function` instance.
You can also create the instance using `function()` constructor.
The following two codes have the same result:

    f(a:number, b:number, c:number) = {
        (a + b + c) / 3
    }

    f = function(a:number, b:number, c:number) {
        (a + b + c) / 3
    }

Using `function()`, you can use variables prefixed by a dollar character
so that they are automatically added to the argument list.
In such a case, the variables are added to the argument list in the same order as
they appear in the function body.
The code below creates a function with a declaration `f($a, $b, $c)`.

    f = function {
        ($a + $b + $c) / 3
    }

You can use `&` as an alias of `function()` as shown below:

    f = &{
        ($a + $b + $c) / 3
    }


### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>function#decls</code></td><td><code>iterator</code></td><td>R</td>
<td>iterator of <code>declaration</code> instances that provide information about argument declaration the function defines.</td></tr>

<tr><td><code>function#expr</code></td><td><code>expr</code></td><td>R/W</td>
<td>an expression of the function.</td></tr>

<tr><td><code>function#format</code></td><td><code>string</code></td><td>R</td>
<td>a string showing a declared format of the function.</td></tr>

<tr><td><code>function#fullname</code></td><td><code>string</code></td><td>R</td>
<td>a full name of the function that is prefixed by a name of the module or the class it belongs to. </td></tr>

<tr><td><code>function#name</code></td><td><code>string</code></td><td>R</td>
<td>a name of the function in <code>string</code>.</td></tr>

<tr><td><code>function#symbol</code></td><td><code>symbol</code></td><td>R/W</td>
<td>a name of the function in <code>symbol</code>. </td></tr>

</table>

### Operator

You can print a function's help from the interactive prompt using the unary operator `~`.
Below is an example to print the help of `printf()` function:

    >>> ~printf

### Function to Create Instance

${markdown.funcdoc(
function
)}

### Method

${markdown.funcdoc(
function.addhelp
function.getdecls
function.getexpr
function.getformat
function.getfullname
function.gethelp
function.getname
function.getsymbol
function.mathdiff
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@help = R'''
## help Class

The `help` class provides measures to access help information
associated with a `function` instance.

You can get a `help` instance by calling the class method `function.gethelp()`.

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>help#format</code></td><td><code>string</code></td><td>R</td>
<td>A name of the syntax format in which the help text is described such as <code>'markdown'</code>.</td></tr>

<tr><td><code>help#lang</code></td><td><code>symbol</code></td><td>R</td>
<td>A symbol of the natural language in which the help text is written.
For example, <code>`en</code> for English and <code>`ja</code> for Japanese.</td></tr>

<tr><td><code>help#text</code></td><td><code>string</code></td><td>R</td>
<td>The help text.</td></tr>

</table>
'''.template().render()

//-----------------------------------------------------------------------------
text@image = R'''
## image Class

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>image#format</code></td><td><code>symbol</code></td><td>R</td>
<td></td></tr>

<tr><td><code>image#height</code></td><td><code>number</code></td><td>R</td>
<td></td></tr>

<tr><td><code>image#palette</code></td><td><code>palette</code></td><td>R/W</td>
<td></td></tr>

<tr><td><code>image#width</code></td><td><code>number</code></td><td>R</td>
<td></td></tr>

</table>

### Function to Create Instance

${markdown.funcdoc(
image
)}

### Method

${markdown.funcdoc(
image.allocbuff
image.blur
image.clear
image.crop
image.delpalette
image.extract
image.fill
image.fillrect
image.flip
image.getpixel
image.grayscale
image.mapcolorlevel
image.paste
image.putpixel
image.size
image.store
image.read
image.reducecolor
image.replacecolor
image.resize
image.rotate
image.scan
image.setalpha
image.thumbnail
image.write
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@iterator = R'''
## iterator Class

### Function to Create Instance

${markdown.funcdoc(
iterator
)}

### Method Specific to Iterator Class

${markdown.funcdoc(
iterator.delay
iterator.isinfinite
iterator.next
iterator.repeater
)}

### Method Common between Iterator and List Class

${markdown.funcdoc(
iterator.after
iterator.align
iterator.and
iterator.average
iterator.before
iterator.contains
iterator.count
iterator.cycle
iterator.each
iterator.filter
iterator.find
iterator.flat
iterator.fold
iterator.format
iterator.head
iterator.join
iterator.joinb
iterator.len
iterator.map
iterator.max
iterator.min
iterator.nilto
iterator.offset
iterator.or
iterator.pack
iterator.pingpong
iterator.print
iterator.printf
iterator.println
iterator.rank
iterator.reduce
iterator.replace
iterator.reverse
iterator.roundoff
iterator.runlength
iterator.since
iterator.skip
iterator.skipnil
iterator.sort
iterator.stddev
iterator.sum
iterator.tail
iterator.until
iterator.variance
iterator.walk
iterator.while
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@list = R'''
## list Class

### Function to Create Instance

${markdown.funcdoc(
list
xlist
set
xset
)}

### Method Specific to List Class

${markdown.funcdoc(
list.add
list.append
list.clear
list.combination
list.erase
list.first
list.flat
list.get
list.insert
list.isempty
list.last
list.permutation
list.put
list.shift
list.shuffle
list.zip
)}

### Method Common between Iterator and List Class

${markdown.funcdoc(
list.after
list.align
list.and
list.average
list.before
list.contains
list.count
list.cycle
list.each
list.filter
list.find
list.fold
list.format
list.head
list.join
list.joinb
list.len
list.map
list.max
list.min
list.nilto
list.offset
list.or
list.pack
list.pingpong
list.print
list.printf
list.println
list.rank
list.reduce
list.replace
list.reverse
list.roundoff
list.runlength
list.since
list.skip
list.skipnil
list.sort
list.stddev
list.sum
list.tail
list.until
list.variance
list.walk
list.while
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@matrix = R'''
## matrix Class

### Function to Create Instance

${markdown.funcdoc(
matrix
)}

### Method

${markdown.funcdoc(
matrix.col
matrix.colsize
matrix.each
matrix.eachcol
matrix.eachrow
matrix.identity
matrix.invert
matrix.issquare
matrix.rotation
matrix.rotation@x
matrix.rotation@y
matrix.rotation@z
matrix.roundoff
matrix.row
matrix.rowsize
matrix.set
matrix.setcol
matrix.setrow
matrix.submat
matrix.tolist
matrix.transpose
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@nil = R'''
## nil Class
'''.template().render()

//-----------------------------------------------------------------------------
text@number = R'''
## number Class

The `number` class provides measures to calculate numbers.

### Method

${markdown.funcdoc(
number.roundoff
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@operator = R'''
## operator Class

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>operator#symbol</code></td><td><code>symbol</code></td><td>R</td>
<td>Operator symbol.</td></tr>

</table>

### Function to Create Instance

${markdown.funcdoc(
operator
)}

### Method

${markdown.funcdoc(
operator.assign
operator.entries
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@palette = R'''
## palette Class

The `palette` instance has a set of `color` instance.



### Function to Create Instance

${markdown.funcdoc(
palette
)}

### Method

${markdown.funcdoc(
palette.each
palette.nearest
palette.shrink
palette.updateby
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@pointer = R'''
## pointer Class

### Method

${markdown.funcdoc(
pointer.forward
pointer.pack
pointer.reset
pointer.unpack
pointer.unpacks
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@quote = R'''
## quote Class
'''.template().render()

//-----------------------------------------------------------------------------
text@rational = R'''
## rational Class

The `rational` class provides measures to handle rational numbers.

You can create a `rational` instance with following ways:

- Use `rational()` function.
- Append `r` suffix after a number literal.

Below are examples to realize a common fraction two-thirds:

    rational(2, 3)
    2r / 3
    2 / 3r

### Function to Create Instance

${markdown.funcdoc(
rational
)}

### Method

${markdown.funcdoc(
rational.reduce
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@semaphore = R'''
## semaphore Class

### Function to Create Instance

${markdown.funcdoc(
semaphore
)}

### Method

${markdown.funcdoc(
semaphore.release
semaphore.session
semaphore.wait
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@stream = R'''
## stream Class


### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>stream#stat</code></td><td><code>object</code></td><td>R</td>
<td>Status of the stream.</td></tr>

<tr><td><code>stream#name</code></td><td><code>string</code></td><td>R</td>
<td>Name of the stream.</td></tr>

<tr><td><code>stream#identifier</code></td><td><code>string</code></td><td>R</td>
<td>Identifier of the stream.</td></tr>

<tr><td><code>stream#readable</code></td><td><code>boolean</code></td><td>R</td>
<td>Indicates whether the stream is readable.</td></tr>

<tr><td><code>stream#writable</code></td><td><code>boolean</code></td><td>R</td>
<td>Indicates whether the stream is writable.</td></tr>

<tr><td><code>stream#codec</code></td><td><code>codec</code></td><td>R</td>
<td>`codec` instance associated with the stream.</td></tr>

</table>

### Operator

You can use the operator `<<` to output a content of a value to a `stream`.
It comes like `stream << obj` and `obj` is converted to a string before output to the stream.

    sys.stdout << 'Hello World.'
    
Since the operator returns the `stream` instance specified on the left as its result,
you can chain multiple operations as below:

    sys.stdout << 'First' << 'Second'


### Cast

A function that expects a `stream` instance in its argument can take a value of
`string` and `binary` as below:

- `string` .. Recognized as a path name from which `stream` instance is created.
- `binary` .. Creates a `stream` instance that contains the specified binary data.

Using the above casting feature, you can call a function `f(stream:stream)`
that takes a `stream` instance in its argument as below:

- `f(stream('foo.txt'))` .. The most explicit way.
- `f('foo.txt')` .. Implicit casting: from `string` to `stream`.
- `f(b'\x00\x12\x34\x56')` .. Implicit casting: from `binary` to `stream`.


### Function to Create Instance

${markdown.funcdoc(
open
stream
readlines
)}

### Method

${markdown.funcdoc(
stream.addcr
stream.close
stream.compare
stream.copy
stream.copyfrom
stream.copyto
stream.delcr
stream.deserialize
stream.flush
stream.peek
//stream.prefetch
stream.print
stream.printf
stream.println
stream.read
stream.readchar
stream.readline
stream.readlines
stream.readtext
stream.seek
stream.serialize
stream.setcodec
stream.tell
stream.write
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@string = R'''
## string Class

The `string` class provides measures to operate on strings.

You can create a `string` instance by embracing a sequence of characters
with a pair of single- or double-quotes.

    'Hello World'

    "Hello World'

If you need to declare a string that contains multiple lines,
embrace it with a pair of sequences of three single- or double-quotes.
''' R"""

    '''first line
    second line
    third line
    '''
""" R'''

    """first line
    second line
    third line
    """

### Suffix Management

When an string literal is suffixed by a character `$`,
a handler registered by `string.translate()` function that is supposed to translate
the string into other natural languages would be evaluated.

### Method

${markdown.funcdoc(
string.align
string.binary
string.capitalize
string.chop
string.decodeuri
string.each
string.eachline
string.encode
string.encodeuri
string.endswith
string.escapehtml
string.find
string.fold
string.foldw
string.format
string.isempty
string.left
string.len
string.lower
string.mid
string.print
string.println
string.reader
string.replace
string.right
string.split
string.startswith
string.strip
string.template
string.tosymbol
string.translator
string.unescapehtml
string.upper
string.width
string.zentohan
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@suffixmgr = R'''
## suffixmgr Class

The `suffixmgr` class provides measures to access suffix managers
that are responsible to handle suffix symbols appended to number or string literals.

Below is an example to register a suffix `X` that converts a string into upper case
after being appended to a string literal:

    suffixmgr(`string).assign(`X) {|body| body.upper()}

You can use that suffix like below:

    'hello world'X

### Function to Create Instance

${markdown.funcdoc(
suffixmgr
)}

### Method

${markdown.funcdoc(
suffixmgr.assign
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@symbol = R'''
## symbol Class

### Method

${markdown.funcdoc(
symbol.eval
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@template = R'''
## template Class

### Cast

A function that expects a `template` instance in its argument can take a value of
`stream` as below:

- `stream` .. Creates a `template` instance by parsing the content of the stream.

As a `stream` is capable of being casted from `string` and `binary`,
such values can also be passed to the argument that expects `template`.

Using the above casting feature, you can call a function `f(tmpl:template)`
that takes a `template` instance in its argument as below:

- `f(template(stream('foo.txt')))` .. The most explicit way.
- `f(stream('foo.txt'))` .. Implicit casting: from `stream` to `template`.
- `f(template('foo.txt'))` .. Implicit casting: from `string` to `stream`.
- `f('foo.txt')` .. Implicit casting: from `string` to `stream`, then from `stream` to `template`.

### Function to Create Instance

${markdown.funcdoc(
template
)}

### Method

${markdown.funcdoc(
template.parse
template.read
template.render
)}

### Method Called by Template Directive

${markdown.funcdoc(
template.block
template.call
template.define
template.embed
template.extends
template.super
)}

'''.template().render()

//-----------------------------------------------------------------------------
text@timedelta = R'''
## timedelta Class

The `timedelta` instance provides a time delta information that works with `datetime` instance.
You can shift time information of `datetime` by applying addition or subtraction
of `timedelta` to it.

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>timedelta#days</code></td><td><code>number</code></td><td>R/W</td>
<td>Offset of days.</td></tr>

<tr><td><code>timedelta#secs</code></td><td><code>number</code></td><td>R/W</td>
<td>Offset of seconds.</td></tr>

<tr><td><code>timedelta#usec</code></td><td><code>number</code></td><td>R/W</td>
<td>Offset of micro seconds.</td></tr>

</table>

### Function to Create Instance

${markdown.funcdoc(
timedelta
)}
'''.template().render()

//-----------------------------------------------------------------------------
text@undefined = R'''
## undefined Class
'''.template().render()

//-----------------------------------------------------------------------------
text@uri = R'''
## uri Class

### Property

<table>
<tr><th>Property</th><th>Type</th><th>R/W</th><th>Explanation</th></tr>

<tr><td><code>uri#scheme</code></td><td><code>string</code></td><td>R/W</td>
<td></td></tr>

<tr><td><code>uri#user</code></td><td><code>string</code></td><td>R/W</td>
<td></td></tr>

<tr><td><code>uri#password</code></td><td><code>string</code></td><td>R/W</td>
<td></td></tr>

<tr><td><code>uri#host</code></td><td><code>string</code></td><td>R/W</td>
<td></td></tr>

<tr><td><code>uri#port</code></td><td><code>string</code></td><td>R/W</td>
<td></td></tr>

<tr><td><code>uri#urlpath</code></td><td><code>string</code></td><td>R/W</td>
<td></td></tr>

<tr><td><code>uri#misc</code></td><td><code>string</code></td><td>R/W</td>
<td></td></tr>

</table>

### Function to Create Instance

${markdown.funcdoc(
uri
)}

### Method

${markdown.funcdoc(
uri.getfragment
uri.getpath
uri.getquery
uri.parsequery
)}
'''.template().render()

write(doc:markdown.document) = {
	doc << text
	//doc << text@Class
	//doc << text@Module
	//doc << text@Sequence
	//doc << text@any
	doc << text@args
	doc << text@array
	doc << text@audio
	doc << text@boolean
	doc << text@binary
	doc << text@codec
	doc << text@color
	doc << text@complex
	doc << text@datetime
	doc << text@declaration
	doc << text@dict
	doc << text@directory
	doc << text@environment
	doc << text@error
	doc << text@expr
	doc << text@formatter
	doc << text@function
	doc << text@help
	doc << text@image
	doc << text@iterator
	doc << text@list
	doc << text@matrix
	doc << text@nil
	doc << text@number
	doc << text@operator
	doc << text@palette
	doc << text@pointer
	doc << text@quote
	doc << text@rational
	doc << text@semaphore
	doc << text@stream
	doc << text@string
	doc << text@suffixmgr
	doc << text@symbol
	doc << text@template
	doc << text@timedelta
	//doc << text@undefined
	doc << text@uri
	doc
}

if (__name__ == '__main__') {
	write(markdown.document()).render@html(sys.stdout)
}
