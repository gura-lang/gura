#!/usr/bin/env gura
import(argopt)

argopt.Parser {|p|
	p.addFlag('verbose',	'v', 'verbose mode')
	p.addFlag('debug',		'd', 'build module with debug information')
	p.addFlag('rebuild',	'r', 'clean output files before building')
	p.addParam('exclude',	'x', 'specify module to exclude', 'NAME', '')
	try {
		[cfg, argv] = p.parse(sys.argv)
	} catch {|e|
		sys.stderr.println(e.text)
		sys.exit(1)
	}
	command = if (argv.len() == 0) {
		`build
	} elsif (argv[0] == 'help') {
		sys.stderr.printf('usage: %s [options] command\n', path.filename(sys.argv[0]))
		sys.stderr.println('command:')
		sys.stderr.println(' clean    clean output files')
		sys.stderr.println(' install  install produced files to root directory')
		sys.stderr.println('options:')
		sys.stderr.println(' ', p.formatHelp())
		sys.exit(1)
	} elsif (argv[0] == 'clean') {
		`clean
	} elsif (argv[0] == 'install') {
		`install
	} else {
		sys.stderr.println('unknown command: ', argv[0])
		sys.exit(1)
	}
}
ModuleInfo = struct(moduleName:string, platforms[]:symbol)
moduleInfos = @(ModuleInfo) {
	['sample',		[`mswin, `linux]]
	['csv',			[`mswin, `linux]]
	['re',			[`mswin, `linux]]
	['sqlite3',		[`mswin, `linux]]
//	['mysql',		[`mswin, `linux]]
//	['postgresql',	[`mswin, `linux]]
	['xml',			[`mswin, `linux]]
	['yaml',		[`mswin, `linux]]
	['sdl',			[`mswin, `linux]]
	['cairo',		[`mswin, `linux]]
	['opengl',		[`mswin, `linux]]
	['glu',			[`mswin, `linux]]
	['bmp',			[`mswin, `linux]]
	['ppm',			[`mswin, `linux]]
	['xpm',			[`mswin, `linux]]
	['msico',		[`mswin, `linux]]
	['jpeg',		[`mswin, `linux]]
	['png',			[`mswin, `linux]]
	['gif',			[`mswin, `linux]]
	['tiff',		[`mswin, `linux]]
	['freetype',	[`mswin, `linux]]
	['tcl',			[`mswin, `linux]]
	['hash',		[`mswin, `linux]]
	['gzip',		[`mswin, `linux]]
	['bzip2',		[`mswin, `linux]]
	['zip',			[`mswin, `linux]]
	['tar',			[`mswin, `linux]]
	['http',		[`mswin, `linux]]
	['curl',		[`mswin, `linux]]
	['wx',			[`mswin, `linux]]
	['guri',		[`mswin, `linux]]
	['midi',		[`mswin, `linux]]
	['wav',			[`mswin, `linux]]
	['markdown',	[`mswin, `linux]]
	['uuid',		[`mswin]]
	['canvas',		[`mswin]]
	['mswin',		[`mswin]]
}
moduleNamesExcept = cfg['exclude'].split(',')
moduleNames = moduleInfos.filter(moduleInfos:*platforms:*iscontain(sys.platform))::moduleName
dirNamePre = path.dirname(sys.argv[0])
moduleNamesError = []
debFiles = []
rpmFiles = []
for (moduleName in moduleNames) {
	if (moduleName in moduleNamesExcept) {
		printf('[%s]', moduleName)
		conio.setcolor(`bright_red) {
			printf('...skipped\n')
		}
		continue
	}
	printf('[%s]\n', moduleName)
	if (!dirNamePre.isempty()) {
		pathName = path.join(dirNamePre, 'module-' + moduleName)
	}
	argvOrg = sys.argv
	sys.argv = ['build.gura']
	if (command == `build) {
		// nothing to do
	} elsif (command == `clean) {
		sys.argv.append('clean')
	} elsif (command == `install) {
		sys.argv.append('install-root')
	} else {
		// nothing to do
	}
	cfg['verbose'] && sys.argv.append('--verbose')
	cfg['debug'] && sys.argv.append('--debug')
	cfg['rebuild'] && sys.argv.append('--rebuild')
	sys.argv.append('--basedir=' + path.join(fs.getcwd(), 'module-' + moduleName))
	fs.chdir(pathName) {
		scope {
			builder = open('build.gura').parse().eval()
			builder.errorFlag && moduleNamesError.append(moduleName)
			builder.debFiles && debFiles.append(builder.debFiles)
			builder.rpmFiles && rpmFiles.append(builder.rpmFiles)
		}
		sys.argv = argvOrg
	}
}
if (sys.argv.len() < 2 || command != `install) {
	if (!moduleNamesError.isempty()) {
		println('**** error while buiding ', moduleNamesError)
	}
	if (!debFiles.isempty()) {
		fileName = 'install-deb.sh'
		open(fileName, 'w').println('apt-get install -y ', set(debFiles))
		fs.chmod('a+x', fileName)
		println(fileName, ' was created. Execute this to install guest Debian packages.')
	}
	if (!rpmFiles.isempty()) {
		fileName = 'install-rpm.sh'
		open(fileName, 'w').println('yum install -y ', set(rpmFiles))
		fs.chmod('a+x', fileName)
		println(fileName, ' was created. Execute this to install guest RPM packages.')
	}
	!moduleNamesError.isempty() && sys.exit(1);
}
