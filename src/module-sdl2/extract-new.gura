#!/usr/bin/env gura
import(re)

decls = `{
//-----------------------------------------------------------------------------
// Basics - Initialization and Shutdown

Init(flags:Uint32):negerr

InitSubSystem(flags:Uint32):negerr

Quit():void

QuitSubSystem(flags:Uint32):void

SetMainReady():void

WasInit(flags:Uint32):Uint32

//-----------------------------------------------------------------------------
// Basics - Configuration Variables

AddHintCallback$()

ClearHints$()

DelhintCallback$()

GetHint$()

SetHint$()

SetHintWithPriority$()

//-----------------------------------------------------------------------------
// Basics - Error Handling

ClearError():void

GetError():char@:const

SetError$()

//-----------------------------------------------------------------------------
// Basics - Log Handling

Log$()

LogCritical$()

LogDebug$()

LogError$()

LogGetOutputFunction$()

LogGetPriority$()

LogInfo$()

LogMessage$()

LogMessageV$()

LogResetPriorities$()

LogSetAllPriority$()

LogSetOutputFunction$()

LogSetPriority$()

LogVerbose$()

LogWarn$()

//-----------------------------------------------------------------------------
// Basics - Assertions

GetAssertionHandler$()

GetAssertionReport$()

GetDefaultAssertionHandler$()

ResetAssertionReport$()

SetAssertionHandler$()

TriggerBreakpoint$()

assert$()

assert_paranoid$()

assert_release$()

GetRevision():char@:const

GetRevisionNumber():int

//-----------------------------------------------------------------------------
// Basics - Querying SDL Version

GetVersion() = R'''
	SDL_version ver;
	SDL_GetVersion(&ver);
	return ReturnValue(env, sig, args, Value::CreateList(env,
					Value(ver.major), Value(ver.minor), Value(ver.patch)));
'''

VERSION() = R'''
	SDL_version ver;
	SDL_VERSION(&ver);
	return ReturnValue(env, sig, args, Value::CreateList(env,
					Value(ver.major), Value(ver.minor), Value(ver.patch)));
'''

VERSION_ATLEAST(X:int, Y:int, Z:int):bool

//-----------------------------------------------------------------------------
// Video - Display and Window Management

CreateWindow(title:char@:const, x:int, y:int, w:int, h:int, flags:Uint32):SDL_Window@

CreateWindowAndRenderer(width:int, height:int, window_flags:Uint32) = R'''
	SDL_Window *window = NULL;
	SDL_Renderer *renderer = NULL;
	int _rtn = SDL_CreateWindowAndRenderer(width, height, window_flags, &window, &renderer);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
			Value(new Object_Window(window)), Value(new Object_Renderer(renderer))));
'''

CreateWindowFrom$()

DestroyWindow(window:SDL_Window@):void

DisableScreenSaver():void

EnableScreenSaver():void

GL_CreateContext(window:SDL_Window@) = R'''
	SDL_GLContext _rtn = SDL_GL_CreateContext(window);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_GLContext(_rtn)));
'''

GL_DeleteContext(context:SDL_GLContext):void

GL_ExtensionSupported(extension:char@:const):SDL_bool

GL_GetAttribute(attr:SDL_GLattr) = R'''
	int value = 0;
	int _rtn = SDL_GL_GetAttribute(attr, &value);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(value));
'''

GL_GetCurrentContext() = R'''
	SDL_GLContext _rtn = SDL_GL_GetCurrentContext();
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_GLContext(_rtn)));
'''

GL_GetCurrentWindow():SDL_Window@

GL_GetDrawableSize(window:SDL_Window@) = R'''
	int w = 0;
	int h = 0;
	SDL_GL_GetDrawableSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

GL_GetProcAddress$()

GL_GetSwapInterval():negerr_boolean

GL_LoadLibrary(path:char@:const):negerr

GL_MakeCurrent(window:SDL_Window@, context:SDL_GLContext):negerr

GL_ResetAttributes():void

GL_SetAttribute(attr:SDL_GLattr, value:int):negerr

GL_SetSwapInterval(interval:int):negerr

GL_SwapWindow(window:SDL_Window@):void

GL_UnloadLibrary():void

GetClosestDisplayMode(displayIndex:int, mode:SDL_DisplayMode@:const) = R'''
	SDL_DisplayMode closest;
	SDL_DisplayMode* _rtn = SDL_GetClosestDisplayMode(displayIndex, mode, &closest);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(closest)));
'''

GetCurrentDisplayMode(displayIndex:int) = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetCurrentDisplayMode(displayIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

GetCurrentVideoDriver():char@:const

GetDesktopDisplayMode(displayIndex:int) = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetDesktopDisplayMode(displayIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

GetDisplayBounds(displayIndex:int) = R'''
	SDL_Rect rect;
	int _rtn = SDL_GetDisplayBounds(displayIndex, &rect);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

GetDisplayMode(displayIndex:int, modeIndex:int) = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetDisplayMode(displayIndex, modeIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

GetDisplayName(dipslayIndex:int):char@:const

GetNumDisplayModes(displayIndex:int):negerr_number

GetNumVideoDisplays():negerr_number

GetNumVideoDrivers():negerr_number

GetVideoDriver(index:int):char@:const

GetWindowBrightness(window:SDL_Window@):float

GetWindowData$(window:SDL_Window@, name:char@:const)

GetWindowDisplayIndex(window:SDL_Window@):negerr_number

GetWindowDisplayMode(window:SDL_Window@, mode:SDL_DisplayMode@):negerr

GetWindowFlags(window:SDL_Window@):Uint32

GetWindowFromID(id:Uint32):SDL_Window@

GetWindowGammaRamp(window:SDL_Window@) = R'''
	Uint16 red = 0;
	Uint16 green = 0;
	Uint16 blue = 0;
	int _rtn = SDL_GetWindowGammaRamp(window, &red, &green, &blue);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
								Value(red), Value(green), Value(blue)));
'''

GetWindowGrab(window:SDL_Window@):SDL_bool

GetWindowID(window:SDL_Window@):Uint32

GetWindowMaximumSize(window:SDL_Window@) = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowMaximumSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

GetWindowMinimumSize(window:SDL_Window@) = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowMinimumSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

GetWindowPixelFormat(window:SDL_Window@) = R'''
	Uint32 _rtn = SDL_GetWindowPixelFormat(window);
	if (_rtn == SDL_PIXELFORMAT_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

GetWindowPosition(window:SDL_Window@) = R'''
	int x = 0;
	int y = 0;
	SDL_GetWindowPosition(window, &x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(x), Value(y)));
'''

GetWindowSize(window:SDL_Window@) = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

GetWindowSurface(window:SDL_Window@):SDL_Surface@

GetWindowTitle(window:SDL_Window@):char@:const

GetWindowWMInfo$(window:SDL_Window@) = R'''
	SDL_SysWMinfo info;
	SDL_bool _rtn = SDL_GetWindowWMInfo(window, &info);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_SysWMinfo(info)));
'''

HideWindow(window:SDL_Window@):void

IsScreenSaverEnabled():SDL_bool

MaximizeWindow(window:SDL_Window@):void

MinimizeWindow(window:SDL_Window@):void

RaiseWindow(window:SDL_Window@):void

RestoreWindow(window:SDL_Window@):void

SetWindowBordered(window:SDL_Window@, bordered:SDL_bool):void

SetWindowBrightness(window:SDL_Window@, brightness:float):negerr

SetWindowData$(window:SDL_Window@, name:char@:const)

SetWindowDisplayMode(window:SDL_Window@, mode:SDL_DisplayMode@:const):negerr

SetWindowFullscreen(window:SDL_Window@, flags:Uint32):negerr

SetWindowGammaRamp(window:SDL_Window@, red[]:Uint16, green[]:Uint16, blue[]:Uint16) = R'''
	if (red.GetSize() != 256 || green.GetSize() != 256 || blue.GetSize() != 256) {
		sig.SetError(ERR_ValueError, "red, green and blue must have 256 elements");
		return Value::Null;
	}
	int _rtn = SDL_SetWindowGammaRamp(window, red, green, blue);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SetWindowGrab(window:SDL_Window@, grabbed:SDL_bool):void

SetWindowHitTest$(window:SDL_Window@):negerr

SetWindowIcon(window:SDL_Window@, icon:SDL_Surface@):void

SetWindowMaximumSize(window:SDL_Window@, max_w:int, max_h:int):void

SetWindowMinimumSize(window:SDL_Window@, min_w:int, min_h:int):void

SetWindowPosition(window:SDL_Window@, x:int, y:int):void

SetWindowSize(window:SDL_Window@, w:int, h:int):void

SetWindowTitle(window:SDL_Window@, title:char@:const):void

ShowMessageBox$():negerr

ShowSimpleMessageBox(flags:Uint32, title:char@:const, message:char@:const, window:SDL_Window@):negerr

ShowWindow(window:SDL_Window@):void

UpdateWindowSurface(window:SDL_Window@):negerr

UpdateWindowSurfaceRects(window:SDL_Window@, rects[]:SDL_Rect) = R'''
	int numrects = static_cast<int>(rects.GetSize());
	int _rtn = SDL_UpdateWindowSurfaceRects(window, rects, numrects);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

VideoInit(driver_name:char@:const):negerr

VideoQuit():void

//-----------------------------------------------------------------------------
// Video - 2D Accelerated Rendering

CreateRenderer(window:SDL_Window@, index:int, flags:Uint32):SDL_Renderer@

CreateSoftwareRenderer(surface:SDL_Surface@):SDL_Renderer@

CreateTexture(renderer:SDL_Renderer@, format:Uint32, access:int, w:int, h:int):SDL_Texture@

CreateTextureFromSurface(renderer:SDL_Renderer@, surface:SDL_Surface@):SDL_Texture@

DestroyRenderer(renderer:SDL_Renderer@):void

DestroyTexture(texture:SDL_Texture@):void

GL_BindTexture(texture:SDL_Texture@) = R'''
	float texw = 0;
	float texh = 0;
	SDL_GL_BindTexture(texture, &texw, &texh);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(texw), Value(texh)));
'''

GL_UnbindTexture(texture:SDL_Texture@):negerr

GetNumRenderDrivers():negerr_number

GetRenderDrawBlendMode(renderer:SDL_Renderer@) = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetRenderDrawBlendMode(renderer, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

GetRenderDrawColor(renderer:SDL_Renderer@) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	Uint8 a = 0;
	int _rtn = SDL_GetRenderDrawColor(renderer, &r, &g, &b, &a);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
								Value(r), Value(g), Value(b), Value(a)));
'''

GetRenderDriverInfo(index:int) = R'''
	SDL_RendererInfo info;
	int _rtn = SDL_GetRenderDriverInfo(index, &info);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_RendererInfo(info)));
'''

GetRenderTarget(renderer:SDL_Renderer@) = R'''
	SDL_Texture *_rtn = SDL_GetRenderTarget(renderer);
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = Value(new Object_Texture(_rtn));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

GetRenderer(window:SDL_Window@):SDL_Renderer@

GetRendererInfo(renderer:SDL_Renderer@) = R'''
	SDL_RendererInfo info;
	int _rtn = SDL_GetRendererInfo(renderer, &info);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_RendererInfo(info)));
'''

GetRenderOutputSize(renderer:SDL_Renderer@) = R'''
	int w = 0;
	int h = 0;
	int _rtn = SDL_GetRendererOutputSize(renderer, &w, &h);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

GetTextureAlphaMod(texture:SDL_Texture@) = R'''
	Uint8 alpha = 0;
	int _rtn = SDL_GetTextureAlphaMod(texture, &alpha);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(alpha));
'''

GetTextureBlendMode(texture:SDL_Texture@) = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetTextureBlendMode(texture, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

GetTextureColorMod(texture:SDL_Texture@) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	int _rtn = SDL_GetTextureColorMod(texture, &r, &g, &b);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
											Value(r), Value(g), Value(b)));
'''

LockTexture$(texture:SDL_Texture@, rect:SDL_Rect@:const):negerr

QueryTexture(texture:SDL_Texture@) = R'''
	Uint32 format = 0;
	int access = 0;
	int w = 0;
	int h = 0;
	int _rtn = SDL_QueryTexture(texture, &format, &access, &w, &h);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
							Value(format), Value(access), Value(w), Value(h)));
'''

RenderClear(renderer:SDL_Renderer@):negerr

RenderCopy(renderer:SDL_Renderer@, texture:SDL_Texture@, srcrect:SDL_Rect@:const:nil, dstrect:SDL_Rect@:const:nil):negerr

RenderCopyEx(renderer:SDL_Renderer@, texture:SDL_Texture@, srcrect:SDL_Rect@:const:nil, dstrect:SDL_Rect@:const:nil, angle:double, center:SDL_Point@:const:nil, flip:SDL_RendererFlip):negerr

RenderDrawLine(renderer:SDL_Renderer@, x1:int, y1:int, x2:int, y2:int):negerr

RenderDrawLines(renderer:SDL_Renderer@, points[]:SDL_Point) = R'''
	int count = static_cast<int>(points.GetSize());
	int _rtn = SDL_RenderDrawLines(renderer, points, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

RenderDrawPoint(renderer:SDL_Renderer@, x:int, y:int):negerr

RenderDrawPoints(renderer:SDL_Renderer@, points[]:SDL_Point) = R'''
	int count = static_cast<int>(points.GetSize());
	int _rtn = SDL_RenderDrawPoints(renderer, points, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

RenderDrawRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr

RenderDrawRects(renderer:SDL_Renderer@, rects[]:SDL_Rect) = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_RenderDrawRects(renderer, rects, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

RenderFillRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr

RenderFillRects(renderer:SDL_Renderer@, rects[]:SDL_Rect) = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_RenderFillRects(renderer, rects, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

RenderGetClipRect(renderer:SDL_Renderer@) = R'''
	SDL_Rect rect;
	SDL_RenderGetClipRect(renderer, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

RenderGetLogicalSize(renderer:SDL_Renderer@) = R'''
	int w = 0;
	int h = 0;
	SDL_RenderGetLogicalSize(renderer, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

RenderGetScale(renderer:SDL_Renderer@) = R'''
	float scaleX = 0;
	float scaleY = 0;
	SDL_RenderGetScale(renderer, &scaleX, &scaleY);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(scaleX), Value(scaleY)));
'''

RenderGetViewport(renderer:SDL_Renderer@) = R'''
	SDL_Rect rect;
	SDL_RenderGetViewport(renderer, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

RenderIsClipEnabled$(renderer:SDL_Renderer@):SDL_bool

RenderPresent(renderer:SDL_Renderer@):void

RenderReadPixels(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil, format:symbol@) = R'''
	Uint32 _format = SDL_PIXELFORMAT_UNKNOWN;
	Image::Format fmtImage = Image::FORMAT_None;
	if (format->IsIdentical(Gura_Symbol(rgb))) {
		_format = SDL_PIXELFORMAT_BGR888;
		fmtImage = Image::FORMAT_RGB;
	} else if (format->IsIdentical(Gura_Symbol(rgba))) {
		_format = SDL_PIXELFORMAT_BGRA8888;
		fmtImage = Image::FORMAT_RGBA;
	} else {
		sig.SetError(ERR_ValueError, "format must be `rgb or `rgba");
		return Value::Null;
	}
	AutoPtr<Image> pImage(new Image(fmtImage));
	if (!pImage->AllocBuffer(sig, rect->w, rect->h, 0x00)) return Value::Null;
	void *pixels = pImage->GetBuffer();
	int pitch = pImage->GetBytesPerLine();
	int _rtn = SDL_RenderReadPixels(renderer, rect, _format, pixels, pitch);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_image(env, pImage.release())));
'''

RenderSetClipRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr

RenderSetLogicalSize(renderer:SDL_Renderer@, w:int, h:int):negerr

RenderSetScale(renderer:SDL_Renderer@, scaleX:float, scaleY:float):negerr

RenderSetViewport(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr

RenderTargetSupported(renderer:SDL_Renderer@):SDL_bool

SetRenderDrawBlendMode(renderer:SDL_Renderer@, blendMode:SDL_BlendMode):void

SetRenderDrawColor(renderer:SDL_Renderer@, r:Uint8, g:Uint8, b:Uint8, a:Uint8):negerr

SetRenderTarget(renderer:SDL_Renderer@, texture:SDL_Texture@:nil):negerr

SetTextureAlphaMod(texture:SDL_Texture@, alpha:Uint8):negerr

SetTextureBlendMode(texture:SDL_Texture@, blendMode:SDL_BlendMode):negerr

SetTextureColorMod(texture:SDL_Texture@, r:Uint8, g:Uint8, b:Uint8):negerr

UnlockTexture(texture:SDL_Texture@):void

UpdateTexture$(texture:SDL_Texture@, rect:SDL_Rect@:const:nil, pitch:int):negerr

UpdateYUVTexture$()

//-----------------------------------------------------------------------------
// Video - Pixel Formats and Conversion Routines

AllocFormat(pixel_format:Uint32):SDL_PixelFormat@

AllocPalette(ncolors:int):SDL_Palette@

CalculateGammaRamp(gamma:float) = R'''
	Uint16 ramp[256];
	SDL_CalculateGammaRamp(gamma, ramp);
	return ReturnValue(env, sig, args, Value::CreateList(env, ramp, ArraySizeOf(ramp)));
'''

FreeFormat(format:SDL_PixelFormat@):void

FreePalette(palette:SDL_Palette@):void

GetPixelFormatName(format:Uint32):char@:const

GetRGB(pixel:Uint32, format:SDL_PixelFormat@:const) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	SDL_GetRGB(pixel, format, &r, &g, &b);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(r), Value(g), Value(b)));
'''

GetRGBA(pixel:Uint32, format:SDL_PixelFormat@:const) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	Uint8 a = 0;
	SDL_GetRGBA(pixel, format, &r, &g, &b, &a);
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(r), Value(g), Value(b), Value(a)));
'''

MapRGB(format:SDL_PixelFormat@:const, r:Uint8, g:Uint8, b:Uint8):Uint32

MapRGBA(format:SDL_PixelFormat@:const, r:Uint8, g:Uint8, b:Uint8, a:Uint8):Uint32

MasksToPixelFormatEnum(bpp:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32):Uint32

PixelFormatEnumToMasks(format:Uint32) = R'''
	int bpp = 0;
	Uint32 Rmask = 0;
	Uint32 Gmask = 0;
	Uint32 Bmask = 0;
	Uint32 Amask = 0;
	SDL_bool _rtn = SDL_PixelFormatEnumToMasks(format, &bpp, &Rmask, &Gmask, &Bmask, &Amask);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(bpp), Value(Rmask), Value(Gmask), Value(Bmask), Value(Amask)));
'''

SetPaletteColors(palette:SDL_Palette@, colors[]:SDL_Color, firstcolor:int, ncolors:int) = R'''
	int nmax = static_cast<int>(colors.GetSize());
	if (firstcolor + ncolors > nmax) {
		sig.SetError(ERR_IndexError, "out of range");
		return Value::Null;
	}
	int _rtn = SDL_SetPaletteColors(palette, colors, firstcolor, ncolors);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SetPixelFormatPalette(format:SDL_PixelFormat@, palette:SDL_Palette@):negerr

//-----------------------------------------------------------------------------
// Video - Rectangle Functions

EnclosePoints(points[]:SDL_Point, clip:SDL_Rect@:const) = R'''
	int count = static_cast<int>(points.GetSize());
	SDL_Rect result;
	SDL_bool _rtn = SDL_EnclosePoints(points, count, clip, &result);
	Value _rtnVal;
	if (_rtn == SDL_TRUE) {
		_rtnVal = Value(new Object_Rect(result));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

HasIntersection(A:SDL_Rect@:const, B:SDL_Rect@:const):SDL_bool

IntersectRect(A:SDL_Rect@:const, B:SDL_Rect@:const) = R'''
	SDL_Rect result;
	SDL_bool _rtn = SDL_IntersectRect(A, B, &result);
	Value _rtnVal;
	if (_rtn == SDL_TRUE) {
		_rtnVal = Value(new Object_Rect(result));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

IntersectRectAndLine$(rect:SDL_Rect@:const, X1:int, Y1:int, X2:int, Y2:int):SDL_bool

PointInRect$(p:SDL_Point@:const, r:SDL_Rect@:const):SDL_bool

RectEmpty(r:SDL_Rect@:const):SDL_bool

RectEquals(a:SDL_Rect@:const, b:SDL_Rect@:const):SDL_bool

UnionRect(A:SDL_Rect@:const, B:SDL_Rect@:const) = R'''
	SDL_Rect result;
	SDL_UnionRect(A, B, &result);
	Value _rtnVal = Value(new Object_Rect(result));
	return ReturnValue(env, sig, args, _rtnVal);
'''

//-----------------------------------------------------------------------------
// Video - Surface Creation and Simple Drawing

BlitScaled(src:SDL_Surface@, srcrect:SDL_Rect@:const:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr

BlitSurface(src:SDL_Surface@, srcrect:SDL_Rect@:const:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr

ConvertPixels$(width:int, height:int, src_format:Uint32, dst_format:Uint32):negerr

ConvertSurface(src:SDL_Surface@, fmt:SDL_PixelFormat@:const, flags:Uint32):SDL_Surface@

ConvertSurfaceFormat(src:SDL_Surface@, pixel_format:Uint32, flags:Uint32):SDL_Surface@

CreateRGBSurface(flags:Uint32, width:int, height:int, depth:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32):SDL_Surface@

CreateRGBSurfaceFrom(pixels:binary, width:int, height:int, depth:int, pitch:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32) = R'''
	if (pixels.size() < static_cast<size_t>(height * pitch)) {
		sig.SetError(ERR_ValueError, "pixels doesn not contain enough data");
		return Value::Null;
	}
	void *_pixels = const_cast<char *>(pixels.data());
	SDL_Surface *_rtn = SDL_CreateRGBSurfaceFrom(_pixels, width, height,
								depth, pitch, Rmask, Gmask, Bmask, Amask);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Surface(_rtn)));
'''

CreateRGBSurfaceFromImage(image:image) = R'''
	Object_Surface *pObjSurface = Object_Surface::CreateSurfaceFromImage(sig, image);
	if (pObjSurface == NULL) return Value::Null;
	return ReturnValue(env, sig, args, Value(pObjSurface));
'''

FillRect(dst:SDL_Surface@, rect:SDL_Rect@:const:nil, color:Uint32):negerr

FillRects(dst:SDL_Surface@, rects[]:SDL_Rect, color:Uint32) = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_FillRects(dst, rects, count, color);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

FreeSurface(surface:SDL_Surface@):void

GetClipRect(surface:SDL_Surface@) = R'''
	SDL_Rect rect;
	SDL_GetClipRect(surface, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

GetColorKey(surface:SDL_Surface@) = R'''
	Uint32 key = 0;
	int _rtn = SDL_GetColorKey(surface, &key);
	Value _rtnVal;
	if (_rtn >= 0) {
		_rtnVal = Value(key);
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

GetSurfaceAlphaMod(surface:SDL_Surface@) = R'''
	Uint8 alpha = 0;
	int _rtn = SDL_GetSurfaceAlphaMod(surface, &alpha);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(alpha));
'''

GetSurfaceBlendMode(surface:SDL_Surface@) = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetSurfaceBlendMode(surface, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

GetSurfaceColorMod(surface:SDL_Surface@) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	int _rtn = SDL_GetSurfaceColorMod(surface, &r, &g, &b);
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(r), Value(g), Value(b)));
'''

LoadBMP(src:stream) = R'''
	std::auto_ptr<SDL_RWops> _src(CreateRWopsStream(&src, &sig));
	SDL_Surface *_rtn = SDL_LoadBMP_RW(_src.get(), 0);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Surface(_rtn)));
'''

LoadBMP_RW$()

LockSurface(surface:SDL_Surface@):negerr

LowerBlit(src:SDL_Surface@, srcrect:SDL_Rect@:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr

LowerBlitScaled(src:SDL_Surface@, srcrect:SDL_Rect@:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr

MUSTLOCK(surface:SDL_Surface@):bool

SaveBMP(surface:SDL_Surface@, dst:stream) = R'''
	std::auto_ptr<SDL_RWops> context(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveBMP_RW(surface, context.get(), 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SaveBMP_RW$()

SetClipRect(surface:SDL_Surface@, rect:SDL_Rect@:const):SDL_bool

SetColorKey(surface:SDL_Surface@, flag:int, key:Uint32):negerr

SetSurfaceAlphaMod(surface:SDL_Surface@, alpha:Uint8):negerr

SetSurfaceBlendMode(surface:SDL_Surface@, blendMode:SDL_BlendMode):negerr

SetSurfaceColorMod(surface:SDL_Surface@, r:Uint8, g:Uint8, b:Uint8):negerr

SetSurfacePalette(surface:SDL_Surface@, palette:SDL_Palette@):negerr

SetSurfaceRLE(surface:SDL_Surface@, flag:int):negerr

UnlockSurface(surface:SDL_Surface@):void

//-----------------------------------------------------------------------------
// Video - Clipboard Handling

GetClipboardText() = R'''
	char *_rtn = SDL_GetClipboardText();
	Value _rtnVal(_rtn);
	SDL_free(_rtn);
	return ReturnValue(env, sig, args, _rtnVal);
'''

HasClipboardText():SDL_bool

//-----------------------------------------------------------------------------
// Input Events - Event Handling

SetClipboardText(text:char@:const):negerr

AddEventWatch$()

DelEventWatch$()

EventState(type:Uint32, state:int):Uint8

FilterEvents$()

FlushEvent(type:Uint32):void

FlushEvents(minType:Uint32, maxType:Uint32):void

GetEventFilter$()

GetNumTouchDevices():int

GetNumTouchFingers(touchId:SDL_TouchID):negerr_number

GetTouchDevice(index:int) = R'''
	SDL_TouchID _rtn = SDL_GetTouchDevice(index);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

GetTouchFinger(touchId:SDL_TouchID, index:int):SDL_Finger@

HasEvent(type:Uint32):SDL_bool

HasEvents(minType:Uint32, maxType:Uint32):SDL_bool

LoadDollarTemplates(touchId:SDL_TouchID, src:stream) = R'''
	std::auto_ptr<SDL_RWops> _src(CreateRWopsStream(&src, &sig));
	int _rtn = SDL_LoadDollarTemplates(touchId, _src.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

AddEvents(events[]:SDL_Event) = R'''
	int numevents = static_cast<int>(events.GetSize());
	int _rtn = SDL_PeepEvents(events, numevents, SDL_ADDEVENT, 0, 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

PeekEvents(numevents:int, minType:Uint32, maxType:Uint32) = R'''
	CArray<SDL_Event> events(numevents);
	int _rtn = SDL_PeepEvents(events, numevents, SDL_PEEKEVENT, minType, maxType);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, _rtn);
	for (int i = 0; i < _rtn; i++) {
		_valList.push_back(Value(new Object_Event(events[i])));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

GetEvents(numevents:int, minType:Uint32, maxType:Uint32) = R'''
	CArray<SDL_Event> events(numevents);
	int _rtn = SDL_PeepEvents(events, numevents, SDL_GETEVENT, minType, maxType);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, _rtn);
	for (int i = 0; i < _rtn; i++) {
		_valList.push_back(Value(new Object_Event(events[i])));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

PollEvent() = R'''
	SDL_Event event;
	int _rtn = SDL_PollEvent(&event);
	if (_rtn == 0) return Value::Null;
	return ReturnValue(env, sig, args, Value(new Object_Event(event)));
'''

PumpEvents():void

PushEvent(event:SDL_Event@):negerr_boolean

QuitRequested():bool

RecordGesture(touchId:SDL_TouchID):negerr_number

RegisterEvents(numevents:int) = R'''
	Uint32 _rtn = SDL_RegisterEvents(numevents);
	Value _rtnVal;
	if (_rtn != (Uint32)-1) {
		_rtnVal = Value(_rtn);
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SaveAllDollarTemplates(dst:stream) = R'''
	std::auto_ptr<SDL_RWops> _dst(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveAllDollarTemplates(_dst.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SaveDollarTemplate(gestureId:SDL_GestureID, dst:stream) = R'''
	std::auto_ptr<SDL_RWops> _dst(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveDollarTemplate(gestureId, _dst.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SetEventFilter$()

WaitEvent() = R'''
	SDL_Event event;
	int _rtn = SDL_WaitEvent(&event);
	if (_rtn == 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Event(event)));
'''

WaitEventTimeout(timeout:int) = R'''
	SDL_Event event;
	int _rtn = SDL_WaitEventTimeout(&event, timeout);
	Value _rtnVal;
	if (_rtn > 0) {
		_rtnVal = Value(new Object_Event(event));
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

//-----------------------------------------------------------------------------
// Input Events - Keyboard Support

CheckKeyboardState(scancode:SDL_Scancode) = R'''
	int numkeys = 0;
	const Uint8 *_keystate = SDL_GetKeyboardState(&numkeys);
	bool _rtn = (0 <= scancode && scancode < numkeys && _keystate[scancode] != 0);
	return ReturnValue(env, sig, args, Value(_rtn));
'''

GetKeyFromName(name:char@:const) = R'''
	SDL_Keycode _rtn = SDL_GetKeyFromName(name);
	if (_rtn == SDLK_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

GetKeyFromScancode(scancode:SDL_Scancode):SDL_Keycode

GetKeyName(key:SDL_Keycode):char@:const

GetKeyboardFocus():SDL_Window@

GetKeyboardState() = R'''
	int numkeys = 0;
	const Uint8 *_keystate = SDL_GetKeyboardState(&numkeys);
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, numkeys);
	for (int i = 0; i < numkeys; i++) {
		_valList.push_back(Value(_keystate[i] != 0));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

GetModState():SDL_Keymod

GetScancodeFromKey(key:SDL_Keycode):SDL_Scancode

GetScancodeFromName(name:char@:const) = R'''
	SDL_Scancode _rtn = SDL_GetScancodeFromName(name);
	if (_rtn == SDL_SCANCODE_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

GetScancodeName(scancode:SDL_Scancode):char@:const

HasScreenKeyboardSupport():SDL_bool

IsScreenKeyboardShown(window:SDL_Window@):SDL_bool

IsTextInputActive():SDL_bool

SetModState(modstate:SDL_Keymod):void

SetTextInputRect(rect:SDL_Rect@):void

StartTextInput():void

StopTextInput():void

//-----------------------------------------------------------------------------
// Input Events - Mouse Support

CaptureMouse$(enalbed:SDL_bool):negerr

CreateColorCursor(surface:SDL_Surface@, hot_x:int, hot_y:int):SDL_Cursor@

CreateCursor(data:binary, mask:binary, w:int, h:int, hot_x:int, hot_y:int) = R'''
	size_t bytesLeast = int((w + 7) / 8) * h;
	if (data.size() < bytesLeast) {
		sig.SetError(ERR_ValueError, "data has insufficient content");
		return Value::Null;
	}
	if (mask.size() < bytesLeast) {
		sig.SetError(ERR_ValueError, "mask has insufficient content");
		return Value::Null;
	}
	const Uint8 *_data = reinterpret_cast<const Uint8 *>(data.data());
	const Uint8 *_mask = reinterpret_cast<const Uint8 *>(mask.data());
	SDL_Cursor *_rtn = SDL_CreateCursor(_data, _mask, w, h, hot_x, hot_y);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Cursor(_rtn, true)));
'''

CreateSystemCursor(id:SDL_SystemCursor):SDL_Cursor@

FreeCursor(cursor:SDL_Cursor@):void

GetCursor() = R'''
	SDL_Cursor *_rtn = SDL_GetCursor();
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = Value(new Object_Cursor(_rtn, false));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

GetDefaultCursor():SDL_Cursor@

GetGlobalMouseState$() = R'''
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetGlobalMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
'''

GetMouseFocus():SDL_Window@

GetMouseState() = R'''
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
'''

GetRelativeMouseMode():SDL_bool

GetRelativeMouseState() = R'''
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetRelativeMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
'''

SetCursor(cursor:SDL_Cursor@):void

SetRelativeMouseMode(enabled:SDL_bool):negerr

ShowCursor(toggle:int):negerr

WarpMouseGlobal$(x:int, y:int)

WarpMouseInWindow(window:SDL_Window@, x:int, y:int):void

//-----------------------------------------------------------------------------
// Input Events - Joystick Support

JoystickClose(joystick:SDL_Joystick@):void

JoystickEventState(state:int):negerr_boolean

JoystickGetAttached(joystick:SDL_Joystick@):SDL_bool

JoystickGetAxis(joystick:SDL_Joystick@, axis:int):Sint16

JoystickGetBall(joystick:SDL_Joystick@, ball:int) = R'''
	int dx = 0;
	int dy = 0;
	int _rtn = SDL_JoystickGetBall(joystick, ball, &dx, &dy);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(dx), Value(dy)));
'''

JoystickGetButton(joystick:SDL_Joystick@, button:int) = R'''
	Uint8 _rtn = SDL_JoystickGetButton(joystick, button);
	return ReturnValue(env, sig, args, Value(_rtn != 0));
'''

JoystickGetDeviceGUID(device_index:int):SDL_JoystickGUID

JoystickGetGUID(joystick:SDL_Joystick@):SDL_JoystickGUID

JoystickGetGUIDFromString(pchGUID:char@:const):SDL_JoystickGUID

JoystickGetGUIDString(guid:SDL_JoystickGUID) = R'''
	char szGUID[64];
	int cbGUID = sizeof(szGUID);
	SDL_JoystickGetGUIDString(guid, szGUID, cbGUID);
	return ReturnValue(env, sig, args, Value(szGUID));
'''

JoystickGetHat(joystick:SDL_Joystick@, hat:int):Uint8

JoystickInstanceID(joystick:SDL_Joystick@) = R'''
	SDL_JoystickID _rtn = SDL_JoystickInstanceID(joystick);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

JoystickName(joystick:SDL_Joystick@):char@:const

JoystickNameForIndex(device_index:int):char@:const

JoystickNumAxes(joystick:SDL_Joystick@):negerr_number

JoystickNumBalls(joystick:SDL_Joystick@):negerr_number

JoystickNumButtons(joystick:SDL_Joystick@):negerr_number

JoystickNumHats(joystick:SDL_Joystick@):negerr_number

JoystickOpen(device_index:int):SDL_Joystick@

JoystickUpdate():void

NumJoysticks():negerr_number

//-----------------------------------------------------------------------------
// Input Events - Game Controller Support

GameControllerAddMapping(mappingString:char@:const):negerr_boolean

GameControllerAddMappingsFromFile(file:stream) = R'''
	std::auto_ptr<SDL_RWops> _file(CreateRWopsStream(&file, &sig));
	int _rtn = SDL_GameControllerAddMappingsFromRW(_file.get(), 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

GameControllerAddMappingsFromRW$()

GameControllerClose(gamecontroller:SDL_GameController@):void

GameControllerEventState(state:int):int

GameControllerGetAttached(gamecontroller:SDL_GameController@):SDL_bool

GameControllerGetAxis(gamecontroller:SDL_GameController@, axis:SDL_GameControllerAxis):Sint16

GameControllerGetAxisFromString(pchString:char@:const):SDL_GameControllerAxis

GameControllerGetBindForAxis(gamecontroller:SDL_GameController@, axis:SDL_GameControllerAxis):SDL_GameControllerButtonBind

GameControllerGetBindForButton(gamecontroller:SDL_GameController@, button:SDL_GameControllerButton):SDL_GameControllerButtonBind

GameControllerGetButton(gamecontroller:SDL_GameController@, button:SDL_GameControllerButton) = R'''
	Uint8 _rtn = SDL_GameControllerGetButton(gamecontroller, button);
	if (_rtn == 0 && *SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn != 0));
'''

GameControllerGetButtonFromString(pchString:char@:const):SDL_GameControllerButton

GameControllerGetJoystick(gamecontroller:SDL_GameController@):SDL_Joystick@

GameControllerGetStringForAxis(axis:SDL_GameControllerAxis):char@:const

GameControllerGetStringForButton(button:SDL_GameControllerButton):char@:const

GameControllerMapping(gamecontroller:SDL_GameController@):char@:const

GameControllerMappingForGUID(guid:SDL_JoystickGUID):char@:const

GameControllerName(gamecontroller:SDL_GameController@):char@:const

GameControllerNameForIndex(joystick_index:int):char@:const

GameControllerOpen(joystick_index:int):SDL_GameController@

GameControllerUpdate():void

IsGameController(joystick_index:int):SDL_bool

//-----------------------------------------------------------------------------
// Force Feedback - Force Feedback Support

HapticClose(haptic:SDL_Haptic@):void

HapticDestroyEffect(haptic:SDL_Haptic@, effect:int):void

HapticEffectSupported(haptic:SDL_Haptic@, effect:SDL_HapticEffect@):negerr_boolean

HapticGetEffectStatus(haptic:SDL_Haptic@, effect:int):negerr_boolean

HapticIndex(haptic:SDL_Haptic@):negerr_number

HapticName(device_index:int):char@:const

HapticNewEffect(haptic:SDL_Haptic@, effect:SDL_HapticEffect@):negerr_number

HapticNumAxes(haptic:SDL_Haptic@):negerr_number

HapticNumEffects(haptic:SDL_Haptic@):negerr_number

HapticNumEffectsPlaying(haptic:SDL_Haptic@):negerr_number

HapticOpen(device_index:int):SDL_Haptic@

HapticOpenFromJoystick(joystick:SDL_Joystick@):SDL_Haptic@

HapticOpenFromMouse():SDL_Haptic@

HapticOpened(device_index:int):negerr_boolean

HapticPause(haptic:SDL_Haptic@):negerr

HapticQuery(haptic:SDL_Haptic@):unsigned_int

HapticRumbleInit(haptic:SDL_Haptic@):negerr

HapticRumblePlay(haptic:SDL_Haptic@, strength:float, length:Uint32):negerr

HapticRumbleStop(haptic:SDL_Haptic@):negerr

HapticRumbleSupported(haptic:SDL_Haptic@):negerr_boolean

HapticRunEffect(haptic:SDL_Haptic@, effect:int, iterations:Uint32):negerr

HapticSetAutocenter(haptic:SDL_Haptic@, autocenter:int):negerr

HapticSetGain(haptic:SDL_Haptic@, gain:int):negerr

HapticStopAll(haptic:SDL_Haptic@):negerr

HapticStopEffect(haptic:SDL_Haptic@, effect:int):negerr

HapticUnpause(haptic:SDL_Haptic@):negerr

HapticUpdateEffect(haptic:SDL_Haptic@, effect:int, data:SDL_HapticEffect@):negerr

JoystickIsHaptic(joystick:SDL_Joystick@):negerr_boolean

MouseIsHaptic():negerr_boolean

NumHaptics():negerr_number

//-----------------------------------------------------------------------------
// Audio - Audio Device Management, Playing and Recording

AudioInit(driver_name:char@:const):negerr

AudioQuit():void

BuildAudioCVT(cvt:SDL_AudioCVT@, src_format:SDL_AudioFormat, src_channels:Uint8, src_rate:int, dst_format:SDL_AudioFormat, dst_channels:Uint8, dst_rate:int):negerr_boolean

ClearQueuedAudio$(dev:SDL_AudioDeviceID)

CloseAudio():void

CloseAudioDevice(dev:SDL_AudioDeviceID):void

ConvertAudio(cvt:SDL_AudioCVT@):negerr

FreeWAV(wav:Wav@) = R'''
	Object_Wav *pObj = Object_Wav::GetObject(args, 0);
	Uint8 *buffer = pObj->GetBuffer();
	SDL_FreeWAV(buffer);
	return Value::Null;
'''

GetAudioDeviceName(index:int, iscapture:int):char@:const

GetAudioDeviceStatus(dev:SDL_AudioDeviceID):SDL_AudioStatus

GetAudioDriver(index:int):char@:const

GetAudioStatus():SDL_AudioStatus

GetCurrentAudioDriver():char@:const

GetNumAudioDevices(iscapture:int):negerr_number

GetNumAudioDrivers():int

GetQueuedAudioSize$(dev:SDL_AudioDeviceID):Uint32

LoadWAV(file:stream) = R'''
	std::auto_ptr<SDL_RWops> _file(CreateRWopsStream(&file, &sig));
	SDL_AudioSpec spec;
	Uint8 *audio_buf = NULL;
	Uint32 audio_len = 0;
	SDL_AudioSpec *_rtn = SDL_LoadWAV_RW(_file.get(), 0, &spec, &audio_buf, &audio_len);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Wav(spec, audio_buf, audio_len)));
'''

LoadWAV_RW$()

LockAudio():void

LockAudioDevice(dev:SDL_AudioDeviceID):void

MixAudio$(volume:int)

MixAudioFormat$(format:SDL_AudioFormat, volume:int)

OpenAudio(desired:SDL_AudioSpec@) = R'''
	SDL_AudioSpec obtained;
	int _rtn = SDL_OpenAudio(desired, &obtained);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_AudioSpec(obtained)));
'''

OpenAudioDevice$(device:char@:const, iscapture:int, desired:SDL_AudioSpec@:const, allowed_changes:int):SDL_AudioDeviceID

PauseAudio(pause_on:int):void

PauseAudioDevice(dev:SDL_AudioDeviceID, pause_on:int):void

QueueAudio$(dev:SDL_AudioDeviceID):negerr

UnlockAudio():void

UnlockAudioDevice(dev:SDL_AudioDeviceID):void

AUDIO_BITSIZE(x:Uint16):Uint16

AUDIO_ISFLOAT(x:Uint16):Uint16_boolean

AUDIO_ISBIGENDIAN(x:Uint16):Uint16_boolean

AUDIO_ISSIGNED(x:Uint16):Uint16_boolean

AUDIO_ISINT(x:Uint16):bool

AUDIO_ISLITTLEENDIAN(x:Uint16):bool

AUDIO_ISUNSIGNED(x:Uint16):bool

//-----------------------------------------------------------------------------
// Threads - Thread Management

CreateThread$()

DetachThread$()

GetThreadID$()

GetThreadName$()

GetThreadPriority$()

TLSCreate$()

TLSGet$()

TLSSet$()

ThreadID$()

WaitThread$()

//-----------------------------------------------------------------------------
// Threads - Thread Synchronization Primitives

CondBroadcast$()

CondSignal$()

CondWait$()

CondWaitTimeout$()

CreateCond$()

CreateMutex$()

CreateSemaphore$()

DestroyCond$()

DestroyMutex$()

DestroySemaphore$()

LockMutex$()

SemPost$()

SemTryWait$()

SemValue$()

SemWait$()

SemWaitTimeout$()

TryLockMutex$()

UnlockMutex$()

//-----------------------------------------------------------------------------
// Threads - Atomic Operations

AtomicAdd$()

AtomicCAS$()

AtomicCASPtr$()

AtomicDecRef$()

AtomicGet$()

AtomicGetPtr$()

AtomicIncRef$()

AtomicLock$()

AtomicSet$()

AtomicSetPtr$()

AtomicTryLock$()

AtomicUnlock$()

CompilerBarrier$()

//-----------------------------------------------------------------------------
// Timers - Timer Support

AddTimer$(interval:Uint32):SDL_TimerID

Delay(ms:Uint32):void

GetPerformanceCounter():Uint64

GetPerformanceFrequency():Uint64

GetTicks():Uint32

RemoveTimer(id:SDL_TimerID):SDL_bool

TICKS_PASSED(A:Uint32, B:Uint32):bool

//-----------------------------------------------------------------------------
// File Abstraction - Filesystem Paths

GetBasePath$():char@

GetPrefPath$(org:char@:const, app:char@:const):char@

//-----------------------------------------------------------------------------
// File Abstraction - File I/O Abstraction

AllocRW$()

FreeRW$()

RWFromConstMem$()

RWFromFP$()

RWFromFile$()

RWFromMem$()

RWclose$()

RWread$()

RWseek$()

RWtell$()

RWwrite$()

ReadBE16$()

ReadBE32$()

ReadBE64$()

ReadLE16$()

ReadLE32$()

ReadLE64$()

WriteBE16$()

WriteBE32$()

WriteBE64$()

WriteLE16$()

WriteLE32$()

WriteLE64$()

//-----------------------------------------------------------------------------
// Shared Object Support - Shared Object Loading and Function Lookup

//-----------------------------------------------------------------------------
// Platform and CPU Information - Platform Detection

GetPlatform():char@:const

//-----------------------------------------------------------------------------
// Platform and CPU Information - CPU Feature Detection

GetCPUCacheLineSize():int

GetCPUCount():int

GetSystemRAM():int

Has3DNow():SDL_bool

HasAVX():SDL_bool

HasAVX2$():SDL_bool

HasAltiVec():SDL_bool

HasMMX():SDL_bool

HasRDTSC():SDL_bool

HasSSE():SDL_bool

HasSSE2():SDL_bool

HasSSE3():SDL_bool

HasSSE41():SDL_bool

HasSSE42():SDL_bool

//-----------------------------------------------------------------------------
// Platform and CPU Information - Byte Order and Byte Swapping

Swap16$()

Swap32$()

Swap64$()

SwapBE16$()

SwapBE32$()

SwapBE64$()

SwapFloat$()

SwapFloatBE$()

SwapFloatLE$()

SwapLE16$()

SwapLE32$()

SwapLE64$()

//-----------------------------------------------------------------------------
// Platform and CPU Information - Bit Manipulation

MostSignificantBitIndex32$(x:Uint32):int

//-----------------------------------------------------------------------------
// Power Management - Power Management Status

GetPowerInfo() = R'''
	int secs = 0;
	int pct = 0;
	SDL_PowerState _rtn = SDL_GetPowerInfo(&secs, &pct);
	return ReturnValue(env, sig, args, Value::CreateList(env,
									Value(_rtn), Value(secs), Value(pct)));
'''

//-----------------------------------------------------------------------------
// Additional - Platform-specific functionality

AndroidGetActivity$()

AndroidGetExternalStoragePath$()

AndroidGetExternalStorageState$()

AndroidGetInternalStoragePath$()

AndroidGetJNIEnv$()

//-----------------------------------------------------------------------------
// Additional - Other

acos(x:double):double
}

ArgInfo = struct(name:string, declGura:string:nil,
				 typeC:string, fmtGetter:string:nil, flags[]:string) {
	GetArg(idx:number) = format(this.fmtGetter, idx)
}

ReturnInfo = struct(typeC:string, fmtReturn:string:nil, bodyPre:string:nil) {
}

TypeConv = struct(declGura:string, flags[]:string, typeC:string,
				  fmtGetter:string:nil, fmtReturn:string:nil, bodyPre?:string)

TypeConv_Enum(typeName:string) = {
	typeName => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			typeName,
			'static_cast<' + typeName + '>(args.GetInt(%d))',
			'Value(_rtn)')
}

TypeConv_Class(typeName:string) = {
	fields = typeName.split(':'):list
	if (fields.len() > 1) {
		[typeNameTmp, attr] = fields
		constFlag = (attr == 'const')
	} else {
		typeNameTmp = fields[0]
		constFlag = false
	}
	pointerFlag = typeNameTmp.find('@')
	typeNameTmp = typeNameTmp.replace('@', '')
	typeNameBase = typeNameTmp.replace('SDL_', '')
	typeName => TypeConv(
			'VTYPE_' + typeNameBase + ', OCCUR_Once', [],
			cond(constFlag, 'const ', '') + typeNameTmp + cond(pointerFlag, ' *', ''),
			'Object_' + typeNameBase + '::GetObject(args, %d)->GetEntity()',
			'Value(new Object_' + typeNameBase + '(_rtn))')
}

typeConvDict = %{
	'bool' => TypeConv(
			'VTYPE_boolean, OCCUR_Once', [],
			'bool', 'args.GetBoolean(%d)',
			'Value(_rtn)')
	'char' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'char', 'args.GetChar(%d)',
			'Value(_rtn)')
	'short' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'short', 'args.GetShort(%d)',
			'Value(_rtn)')
	'int' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'int', 'args.GetInt(%d)',
			'Value(_rtn)')
	'unsigned_char' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'unsigned char', 'args.GetUChar(%d)',
			'Value(_rtn)')
	'unsigned_short' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'unsigned short', 'args.GetUShort(%d)',
			'Value(_rtn)')
	'unsigned_int' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'unsigned int', 'args.GetUInt(%d)',
			'Value(_rtn)')
	'float' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'float', 'args.GetFloat(%d)',
			'Value(_rtn)')
	'double' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'double', 'args.GetDouble(%d)',
			'Value(_rtn)')
	'char@' => TypeConv(
			'VTYPE_string, OCCUR_Once', [],
			'char *', 'args.GetString(%d)',
			'Value(_rtn)')
	'char@:const' => TypeConv(
			'VTYPE_string, OCCUR_Once', [],
			'const char *', 'args.GetString(%d)',
			'Value(_rtn)')
	'symbol@' => TypeConv(
			'VTYPE_symbol, OCCUR_Once', [],
			'const Symbol *', 'args.GetSymbol(%d)',
			'Value(_rtn)')
	'binary' => TypeConv(
			'VTYPE_binary, OCCUR_Once', [],
			'const Binary &', 'Object_binary::GetObject(args, %d)->GetBinary()',
			nil)
	'stream' => TypeConv(
			'VTYPE_stream, OCCUR_Once', [],
			'Stream &', 'Object_stream::GetObject(args, %d)->GetStream()',
			nil)
	'image' => TypeConv(
			'VTYPE_image, OCCUR_Once', [],
			'Image *', 'Object_image::GetObject(args, %d)->GetImage()',
			nil)
	'Uint16[]' => TypeConv(
			'VTYPE_number, OCCUR_Once', ['List'],
			'CArray<Uint16>', 'args.GetList(%d)',
			nil)
	'Sint8' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'Sint8', 'args.GetChar(%d)',
			'Value(_rtn)')
	'Sint16' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'Sint16', 'args.GetShort(%d)',
			'Value(_rtn)')
	'Sint32' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'Sint32', 'args.GetLong(%d)',
			'Value(_rtn)')
	'Sint64' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'Sint64', 'static_cast<Sint64>(args.GetDouble(%d))',
			'Value(_rtn)')
	'Uint8' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'Uint8', 'args.GetUChar(%d)',
			'Value(_rtn)')
	'Uint16' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'Uint16', 'args.GetUShort(%d)',
			'Value(_rtn)')
	'Uint32' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'Uint32', 'args.GetULong(%d)',
			'Value(_rtn)')
	'Uint64' => TypeConv(
			'VTYPE_number, OCCUR_Once', [],
			'Uint64', 'static_cast<Uint64>(args.GetDouble(%d))',
			'Value(_rtn)')
	'Wav@' => TypeConv(
			'VTYPE_Wav, OCCUR_Once', [],
			'Object_Wav *', 'Object_Wav::GetObject(args, %d)',
			nil);
	'SDL_bool' => TypeConv(
			'VTYPE_boolean, OCCUR_Once', [],
			'SDL_bool', '(args.GetBoolean(%d)? SDL_TRUE : SDL_FALSE)',
			'Value(_rtn != SDL_FALSE)')
	'SDL_Color[]' => TypeConv(
			'VTYPE_Color, OCCUR_Once', ['List'],
			'CArray<SDL_Color>',
			'CreateCArray<SDL_Color, Object_Color>(args.GetList(%d))',
			nil)
	'SDL_Event[]' => TypeConv(
			'VTYPE_Event, OCCUR_Once', ['List'],
			'CArray<SDL_Event>',
			'CreateCArray<SDL_Event, Object_Event>(args.GetList(%d))',
			nil)
	'SDL_Point[]' => TypeConv(
			'VTYPE_Point, OCCUR_Once', ['List'],
			'CArray<SDL_Point>',
			'CreateCArray<SDL_Point, Object_Point>(args.GetList(%d))',
			nil)
	'SDL_Rect[]' => TypeConv(
			'VTYPE_Rect, OCCUR_Once', ['List'],
			'CArray<SDL_Rect>',
			'CreateCArray<SDL_Rect, Object_Rect>(args.GetList(%d))',
			nil)
	'' => TypeConv(
			nil, [],
			nil, '',
			'')
	'void' => TypeConv(
			nil, [],
			nil, nil,
			nil)
	'negerr' => TypeConv(
			nil, [],
			'int', nil,
			nil, R'''
				if (_rtn < 0) {
					SetError_SDL(sig);
					return Value::Null;
				}
			''')
	'negerr_boolean' => TypeConv(
			nil, [],
			'int', nil,
			'Value(_rtn != 0)', R'''
				if (_rtn < 0) {
					SetError_SDL(sig);
					return Value::Null;
				}
			''')
	'negerr_number' => TypeConv(
			nil, [],
			'int', nil,
			'Value(_rtn)', R'''
				if (_rtn < 0) {
					SetError_SDL(sig);
					return Value::Null;
				}
			''')
	'Uint16_boolean' => TypeConv(
			nil, [],
			'Uint16', nil,
			'Value(_rtn != 0)')
	TypeConv_Enum('SDL_AudioFormat')
	TypeConv_Enum('SDL_AudioDeviceID')
	TypeConv_Enum('SDL_AudioStatus')
	TypeConv_Enum('SDL_BlendMode')
	TypeConv_Enum('SDL_GameControllerAxis')
	TypeConv_Enum('SDL_GameControllerButton')
	TypeConv_Enum('SDL_GestureID')
	TypeConv_Enum('SDL_GLattr')
	TypeConv_Enum('SDL_Keycode')
	TypeConv_Enum('SDL_Keymod')
	TypeConv_Enum('SDL_RendererFlip')
	TypeConv_Enum('SDL_Scancode')
	TypeConv_Enum('SDL_SystemCursor')
	TypeConv_Enum('SDL_TimerID')
	TypeConv_Enum('SDL_TouchID')
	TypeConv_Class('SDL_AudioCVT@')
	TypeConv_Class('SDL_AudioSpec@')
	TypeConv_Class('SDL_AudioSpec@:const')
	//TypeConv_Class('SDL_Cursor@')
	'SDL_Cursor@' => TypeConv(
			'VTYPE_Cursor, OCCUR_Once', [],
			'SDL_Cursor *', 'Object_Cursor::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Cursor(_rtn, true))')
	TypeConv_Class('SDL_DisplayMode@')
	TypeConv_Class('SDL_DisplayMode@:const')
	TypeConv_Class('SDL_Event@')
	TypeConv_Class('SDL_Event@:const')
	TypeConv_Class('SDL_Finger@')
	TypeConv_Class('SDL_GameController@')
	TypeConv_Class('SDL_GameControllerButtonBind')
	TypeConv_Class('SDL_GLContext')
	TypeConv_Class('SDL_Haptic@')
	TypeConv_Class('SDL_HapticEffect@')
	TypeConv_Class('SDL_Joystick@')
	TypeConv_Class('SDL_JoystickGUID')
	TypeConv_Class('SDL_Palette@')
	TypeConv_Class('SDL_PixelFormat@')
	TypeConv_Class('SDL_PixelFormat@:const')
	TypeConv_Class('SDL_Point@:const')
	TypeConv_Class('SDL_Rect@')
	TypeConv_Class('SDL_Rect@:const')
	TypeConv_Class('SDL_Renderer@')
	TypeConv_Class('SDL_Surface@')
	TypeConv_Class('SDL_Texture@')
	TypeConv_Class('SDL_Window@')
}

tmplImplementation = R'''
// sdl2.${fi.funcName}
Gura_DeclareFunction(${fi.funcName})
{
	${if (fi.rtnInfo.fmtReturn)}
	SetMode(RSLTMODE_Normal, FLAG_Map);
	DeclareBlock(OCCUR_ZeroOrOnce);
	${else}
	SetMode(RSLTMODE_Void, FLAG_None);
	${end}
	${for (arg in fi.args)}
	DeclareArg(env, "${arg.name}", ${arg.declGura}, ${('FLAG_' + arg.flags).join('|')});
	${end}
	AddHelp(Gura_Symbol(en), Help::FMT_markdown,
	"");
}

Gura_ImplementFunction(${fi.funcName})
{
	${if (!fi.validFlag)}
#if 0
	${end}
	${argsJoined = fi.args:*name.join(', '), -}
	${for (arg in fi.args) {|idx|}}
	${if (arg.fmtGetter)}
	${arg.typeC.sub(r'([\w>])$', r'\1 ') + arg.name} = ${
		if (!arg.typeC.endswith('*')) {
			arg.GetArg(idx)
		} elsif (arg.flags.find('Nil')) {
			format('args.IsValid(%d)? ', idx) + arg.GetArg(idx) + ' : NULL'
		} else {
			arg.GetArg(idx)
		}
	};
	${end}
	${end}
	${if (fi.body)}
${fi.body}
	${else}
	${if (fi.rtnInfo.typeC && !fi.rtnInfo.typeC.isempty())}
	${fi.rtnInfo.typeC.sub(r'(\w)$', r'\1 ')}_rtn = SDL_${fi.funcName}(${argsJoined});
	${else}
	SDL_${fi.funcName}(${argsJoined});
	${end}
${fi.rtnInfo.bodyPre}
	${if (fi.rtnInfo.fmtReturn)}
	${if (fi.rtnInfo.typeC.endswith('*'))}
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = ${fi.rtnInfo.fmtReturn};
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	${else}
	Value _rtnVal = ${fi.rtnInfo.fmtReturn};
	${end}
	return ReturnValue(env, sig, args, _rtnVal);
	${else}
	return Value::Null;
	${end}
	${end}
	${if (!fi.validFlag)}
#endif
	SetError_NotImpFunction(sig, "${fi.funcName}");
	return Value::Null;
	${end}
}
'''.template()

tmplAssignment = R'''
	Gura_AssignFunction(${fi.funcName});
'''.template()

FuncInfo = class {
	public {
		funcName, args, rtnInfo, body
	}
	__init__(decl:expr):map = {
		if (decl.isassign()) {
			caller = decl.left
			if (!(decl.right.isvalue() && isstring(decl.right.value))) {
				this.PrintError(decl, 'assigned value must be a string')
				sys.exit(1)
			}
			body = decl.right.value
		} else {
			caller = decl
			body = nil
		}
		funcNameRaw:string = caller.car.symbol
		this.funcName = funcNameRaw.replace('$', '')
		this.validFlag = !funcNameRaw.find('$')
		this.body = body
		rtnTypeRaw = caller.attrfront.join('.')

		if (!this.validFlag) {
			rtnTypeRaw = 'void'
		}
		
		if (caller.attrs.find(`const)) {
			rtnTypeRaw += ':const'
		}
		typeConv = typeConvDict.get(rtnTypeRaw)
		if (!typeConv) {
			this.PrintError(decl,
							'proper conversion not found in table "%s"', rtnTypeRaw)
			sys.exit(1)
		}
		this.rtnInfo = ReturnInfo(typeConv.typeC, typeConv.fmtReturn, typeConv.bodyPre)
		this.args = caller.cdr.each():list {|arg|
			if (arg.isindexer()) {
				identifier = arg.car
				argTypeRaw = identifier.attrfront.join('.') + '[]'
			} else {
				identifier = arg
				argTypeRaw = identifier.attrfront.join('.')
			}
			if (identifier.attrs.find(`const)) {
				argTypeRaw += ':const'
			}
			typeConv = typeConvDict.get(argTypeRaw)
			if (!typeConv) {
				this.PrintError(decl,
								'proper conversion not found in table "%s"', argTypeRaw)
				sys.exit(1)
			}
			flags = []
			flags.append(typeConv.flags)
			if (identifier.attrs.find(`nil)) {
				flags.append('Nil')
			}
			if (flags.isempty()) {
				flags.append('None')
			}
			name = identifier.symbol
			ArgInfo(name, typeConv.declGura, typeConv.typeC, typeConv.fmtGetter, flags)
		}
	}
	PrintError(decl:expr, fmt:string, args*) = {
		sys.stderr.printf('%s:%d: %s',
				  path.filename(decl.source), decl.lineno, format(fmt, args*))
	}
	RenderImplementation() = {
		fi = this
		tmplImplementation.render()
	}
	RenderAssignment() = {
		fi = this
		tmplAssignment.render()
	}
}

funcInfos = FuncInfo(decls.children):list
if (sys.argv.len() > 1 && sys.argv[1] == 'test') {
	print(funcInfos:*RenderImplementation())
	//print(funcInfos:*RenderAsignment())
} else {
	fileNameTmpl = 'Functions.cpp.tmpl'
	fileNameOut = 'Functions.cpp'
	template(fileNameTmpl).render(fileNameOut)
	println(fileNameOut, ' was created')
}
