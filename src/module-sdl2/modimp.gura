#!/usr/bin/env gura

tmplImplementation = R'''
// sdl2.${fi.funcNameGura}
Gura_DeclareFunction(${fi.funcNameGura})
{
	${if (fi.rtnInfo.fmtReturn)}
	SetMode(RSLTMODE_Normal, FLAG_Map);
	DeclareBlock(OCCUR_ZeroOrOnce);
	${else}
	SetMode(RSLTMODE_Void, FLAG_None);
	${end}
	${for (arg in fi.args)}
	DeclareArg(env, "${arg.name}", VTYPE_${arg.valType}, OCCUR_${arg.occurPattern}, ${('FLAG_' + arg.flags).join('|')});
	${end}
	AddHelp(Gura_Symbol(en), Help::FMT_markdown,
	"");
}

Gura_ImplementFunction(${fi.funcNameGura})
{
	${if (!fi.validFlag)}
#if 0
	${end}
	${argsJoined = fi.args:*name.join(', '), -}
	${for (arg in fi.args) {|idx|}}
	${if (arg.fmtGetter)}
	${arg.typeC.sub(r'([\w>])$', r'\1 ') + arg.name} = ${
		if (!arg.typeC.endswith('*')) {
			arg.GetArg(idx)
		} elsif (arg.flags.find('Nil')) {
			format('args.IsValid(%d)? ', idx) + arg.GetArg(idx) + ' : NULL'
		} else {
			arg.GetArg(idx)
		}
	};
	${end}
	${end}
	${if (fi.body)}
${fi.body}
	${else}
	${if (fi.rtnInfo.typeC && !fi.rtnInfo.typeC.isempty())}
	${fi.rtnInfo.typeC.sub(r'(\w)$', r'\1 ')}_rtn = ${fi.funcNameC}(${argsJoined});
	${else}
	${fi.funcNameC}(${argsJoined});
	${end}
${fi.rtnInfo.bodyPre}
	${if (fi.rtnInfo.fmtReturn)}
	return ReturnValue(env, sig, args, ${fi.rtnInfo.fmtReturn});
	${else}
	return Value::Null;
	${end}
	${end}
	${if (!fi.validFlag)}
#endif
	SetError_NotImpFunction(sig, "${fi.funcNameGura}");
	return Value::Null;
	${end}
}
'''.template()

tmplAssignment = R'''
Gura_AssignFunction(${fi.funcNameGura});
'''.template()

ArgInfo = struct(name:string, valType:string:nil, occurPattern:string:nil,
				 typeC:string, fmtGetter:string:nil, flags[]:string) {
	GetArg(idx:number) = format(this.fmtGetter, idx)
}

ReturnInfo = struct(typeC:string, fmtReturn:string:nil, bodyPre:string:nil)

TypeConv = struct(
		valType:string:nil, occurPattern:string:nil, flags[]:string,
		typeC:string, fmtGetter:string:nil, fmtReturn:string:nil, bodyPre?:string)

FuncInfo = class {
	public {
		funcNameC, funcNameGura, args, rtnInfo, body
	}
	__init__(decl:expr, typeConvDict:dict, funcNameTranslator:function):map = {
		if (decl.isassign()) {
			caller = decl.left
			if (!(decl.right.isvalue() && isstring(decl.right.value))) {
				this.PrintError(decl, 'assigned value must be a string')
				sys.exit(1)
			}
			body = decl.right.value
		} else {
			caller = decl
			body = nil
		}
		funcNameRaw:string = caller.car.symbol
		this.funcNameC = funcNameRaw.replace('$', '')
		this.funcNameGura = funcNameTranslator(this.funcNameC)
		this.validFlag = !funcNameRaw.find('$')
		this.body = body
		rtnTypeRaw = caller.attrfront.join('.')
		if (rtnTypeRaw.isempty() && !this.validFlag) {
			rtnTypeRaw = 'void'
		}
		if (caller.attrs.find(`const)) {
			rtnTypeRaw += ':const'
		}
		typeConv = typeConvDict.get(rtnTypeRaw)
		if (!typeConv) {
			this.PrintError(decl,
							'proper conversion not found in table "%s"', rtnTypeRaw)
			sys.exit(1)
		}
		this.rtnInfo = ReturnInfo(typeConv.typeC, typeConv.fmtReturn, typeConv.bodyPre)
		this.args = caller.cdr.each():list {|arg|
			if (arg.isindexer()) {
				identifier = arg.car
				argTypeRaw = identifier.attrfront.join('.') + '[]'
			} else {
				identifier = arg
				argTypeRaw = identifier.attrfront.join('.')
			}
			if (identifier.attrs.find(`const)) {
				argTypeRaw += ':const'
			}
			typeConv = typeConvDict.get(argTypeRaw)
			if (!typeConv) {
				this.PrintError(decl,
								'proper conversion not found in table "%s"', argTypeRaw)
				sys.exit(1)
			}
			flags = []
			flags.append(typeConv.flags)
			if (identifier.attrs.find(`nil)) {
				flags.append('Nil')
			}
			if (flags.isempty()) {
				flags.append('None')
			}
			name = identifier.symbol
			ArgInfo(name, typeConv.valType, typeConv.occurPattern,
					typeConv.typeC, typeConv.fmtGetter, flags)
		}
	}
	PrintError(decl:expr, fmt:string, args*) = {
		sys.stderr.printf('%s:%d: %s',
				  path.filename(decl.source), decl.lineno, format(fmt, args*))
	}
	RenderImplementation() = {
		fi = this
		tmplImplementation.render()
	}
	RenderAssignment() = {
		fi = this
		tmplAssignment.render()
	}
}

typeConvDict_BuiltIn = %{
	'' => TypeConv(
			nil, nil, [],
			nil, '',
			'')
	'void' => TypeConv(
			nil, nil, [],
			nil, nil,
			nil)
	'bool' => TypeConv(
			'boolean', 'Once', [],
			'bool', 'args.GetBoolean(%d)',
			'Value(_rtn)')
	'char' => TypeConv(
			'number', 'Once', [],
			'char', 'args.GetChar(%d)',
			'Value(_rtn)')
	'short' => TypeConv(
			'number', 'Once', [],
			'short', 'args.GetShort(%d)',
			'Value(_rtn)')
	'int' => TypeConv(
			'number', 'Once', [],
			'int', 'args.GetInt(%d)',
			'Value(_rtn)')
	'long' => TypeConv(
			'number', 'Once', [],
			'long', 'args.GetLong(%d)',
			'Value(_rtn)')
	'unsigned_char' => TypeConv(
			'number', 'Once', [],
			'unsigned char', 'args.GetUChar(%d)',
			'Value(_rtn)')
	'unsigned_short' => TypeConv(
			'number', 'Once', [],
			'unsigned short', 'args.GetUShort(%d)',
			'Value(_rtn)')
	'unsigned_int' => TypeConv(
			'number', 'Once', [],
			'unsigned int', 'args.GetUInt(%d)',
			'Value(_rtn)')
	'unsigned_long' => TypeConv(
			'number', 'Once', [],
			'unsigned long', 'args.GetULong(%d)',
			'Value(_rtn)')
	'UChar' => TypeConv(
			'number', 'Once', [],
			'UChar', 'args.GetUChar(%d)',
			'Value(_rtn)')
	'UShort' => TypeConv(
			'number', 'Once', [],
			'UShort', 'args.GetUShort(%d)',
			'Value(_rtn)')
	'UInt' => TypeConv(
			'number', 'Once', [],
			'UInt', 'args.GetUInt(%d)',
			'Value(_rtn)')
	'ULong' => TypeConv(
			'number', 'Once', [],
			'ULong', 'args.GetULong(%d)',
			'Value(_rtn)')
	'Int64' => TypeConv(
			'number', 'Once', [],
			'Int64', 'static_cast<Int64>(args.GetDouble(%d))',
			'Value(_rtn)')
	'UInt64' => TypeConv(
			'number', 'Once', [],
			'UInt64', 'static_cast<UInt64>(args.GetDouble(%d))',
			'Value(_rtn)')
	'float' => TypeConv(
			'number', 'Once', [],
			'float', 'args.GetFloat(%d)',
			'Value(_rtn)')
	'double' => TypeConv(
			'number', 'Once', [],
			'double', 'args.GetDouble(%d)',
			'Value(_rtn)')
	'char[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<char>', 'args.GetList(%d)',
			nil)
	'short[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<short>', 'args.GetList(%d)',
			nil)
	'int[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<int>', 'args.GetList(%d)',
			nil)
	'long[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<long>', 'args.GetList(%d)',
			nil)
	'unsigned_char[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<unsigned char>', 'args.GetList(%d)',
			nil)
	'unsigned_short[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<unsigned short>', 'args.GetList(%d)',
			nil)
	'unsigned_int[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<unsigned int>', 'args.GetList(%d)',
			nil)
	'unsigned_long[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<unsigned long>', 'args.GetList(%d)',
			nil)
	'char@' => TypeConv(
			'string', 'Once', [],
			'char *', 'args.GetString(%d)',
			'Value(_rtn)')
	'char@:const' => TypeConv(
			'string', 'Once', [],
			'const char *', 'args.GetString(%d)',
			'Value(_rtn)')
	'symbol@' => TypeConv(
			'symbol', 'Once', [],
			'const Symbol *', 'args.GetSymbol(%d)',
			'Value(_rtn)')
	'symbol@:const' => TypeConv(
			'symbol', 'Once', [],
			'const Symbol *', 'args.GetSymbol(%d)',
			'Value(_rtn)')
	'binary' => TypeConv(
			'binary', 'Once', [],
			'const Binary &', 'Object_binary::GetObject(args, %d)->GetBinary()',
			nil)
	'stream' => TypeConv(
			'stream', 'Once', [],
			'Stream &', 'Object_stream::GetObject(args, %d)->GetStream()',
			nil)
	'image' => TypeConv(
			'image', 'Once', [],
			'Image *', 'Object_image::GetObject(args, %d)->GetImage()',
			nil)
}

Renderer = class {
	__init__(decls:iterator, typeConvDict:dict, funcNameTranslator:function) = {
		typeConvDictWork = %{}
		typeConvDictWork.store(typeConvDict_BuiltIn)
		typeConvDictWork.store(typeConvDict)
		this.funcInfos = FuncInfo(decls, typeConvDictWork, funcNameTranslator):list
	}
	RenderImplementation() = {
		this.funcInfos:*RenderImplementation() + '\n'
	}
	RenderAssignment() = {
		this.funcInfos:*RenderAssignment()
	}
}
