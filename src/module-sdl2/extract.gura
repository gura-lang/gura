#!/usr/bin/env gura
import(re)

text = R'''
//-----------------------------------------------------------------------------
// Basics - Initialization and Shutdown
Init(Uint32 flags):negerr
InitSubSystem(Uint32 flags):negerr
Quit()
QuitSubSystem(Uint32 flags)
SetMainReady()
WasInit(Uint32 flags):Uint32
//-----------------------------------------------------------------------------
// Basics - Configuration Variables
AddHintCallback
ClearHints
DelhintCallback
GetHint
SetHint
SetHintWithPriority
//-----------------------------------------------------------------------------
// Basics - Error Handling
ClearError()
GetError():const char*
SetError
//-----------------------------------------------------------------------------
// Basics - Log Handling
Log
LogCritical
LogDebug
LogError
LogGetOutputFunction
LogGetPriority
LogInfo
LogMessage
LogMessageV
LogResetPriorities
LogSetAllPriority
LogSetOutputFunction
LogSetPriority
LogVerbose
LogWarn
//-----------------------------------------------------------------------------
// Basics - Assertions
GetAssertionHandler
GetAssertionReport
GetDefaultAssertionHandler
ResetAssertionReport
SetAssertionHandler
TriggerBreakpoint
assert
assert_paranoid
assert_release
//-----------------------------------------------------------------------------
// Basics - Querying SDL Version
GetRevision():const char*
GetRevisionNumber():int
GetVersion():custom {
	SDL_version ver;
	SDL_GetVersion(&ver);
	return ReturnValue(env, sig, args, Value::CreateList(env,
					Value(ver.major), Value(ver.minor), Value(ver.patch)));
}
VERSION():custom {
	SDL_version ver;
	SDL_VERSION(&ver);
	return ReturnValue(env, sig, args, Value::CreateList(env,
					Value(ver.major), Value(ver.minor), Value(ver.patch)));
}
VERSION_ATLEAST(int X, int Y, int Z):bool
//-----------------------------------------------------------------------------
// Video - Display and Window Management
CreateWindow(const char* title, int x, int y, int w, int h, Uint32 flags):SDL_Window*
CreateWindowAndRenderer(int width, int height, Uint32 window_flags):custom {
	SDL_Window *window = NULL;
	SDL_Renderer *renderer = NULL;
	int _rtn = SDL_CreateWindowAndRenderer(width, height, window_flags, &window, &renderer);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
			Value(new Object_Window(window)), Value(new Object_Renderer(renderer))));
}
CreateWindowFrom
DestroyWindow(SDL_Window* window)
DisableScreenSaver()
EnableScreenSaver()
GL_CreateContext(SDL_Window* window):custom {
	SDL_GLContext _rtn = SDL_GL_CreateContext(window);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_GLContext(_rtn)));
}
GL_DeleteContext(SDL_GLContext context)
GL_ExtensionSupported(const char* extension):SDL_bool
GL_GetAttribute(SDL_GLattr attr):custom {
	int value = 0;
	int _rtn = SDL_GL_GetAttribute(attr, &value);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(value));
}
GL_GetCurrentContext():custom {
	SDL_GLContext _rtn = SDL_GL_GetCurrentContext();
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_GLContext(_rtn)));
}
GL_GetCurrentWindow():SDL_Window*
GL_GetDrawableSize(SDL_Window* window):custom {
	int w = 0;
	int h = 0;
	SDL_GL_GetDrawableSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
}
GL_GetProcAddress
GL_GetSwapInterval():negerr_boolean
GL_LoadLibrary(const char* path):negerr
GL_MakeCurrent(SDL_Window* window, SDL_GLContext context):negerr
GL_ResetAttributes()
GL_SetAttribute(SDL_GLattr attr, int value):negerr
GL_SetSwapInterval(int interval):negerr
GL_SwapWindow(SDL_Window* window)
GL_UnloadLibrary()
GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode* mode):custom {
	SDL_DisplayMode closest;
	SDL_DisplayMode* _rtn = SDL_GetClosestDisplayMode(displayIndex, mode, &closest);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(closest)));
}
GetCurrentDisplayMode(int displayIndex):custom {
	SDL_DisplayMode mode;
	int _rtn = SDL_GetCurrentDisplayMode(displayIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
}
GetCurrentVideoDriver():const char*
GetDesktopDisplayMode(int displayIndex):custom {
	SDL_DisplayMode mode;
	int _rtn = SDL_GetDesktopDisplayMode(displayIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
}
GetDisplayBounds(int displayIndex):custom {
	SDL_Rect rect;
	int _rtn = SDL_GetDisplayBounds(displayIndex, &rect);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
}
GetDisplayMode(int displayIndex, int modeIndex):custom {
	SDL_DisplayMode mode;
	int _rtn = SDL_GetDisplayMode(displayIndex, modeIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
}
GetDisplayName(int dipslayIndex):const char*
GetNumDisplayModes(int displayIndex):negerr_number
GetNumVideoDisplays():negerr_number
GetNumVideoDrivers():negerr_number
GetVideoDriver(int index):const char*
GetWindowBrightness(SDL_Window* window):float
#GetWindowData(SDL_Window* window, const char* name)
GetWindowDisplayIndex(SDL_Window* window):negerr_number
GetWindowDisplayMode(SDL_Window* window, SDL_DisplayMode* mode):negerr
GetWindowFlags(SDL_Window* window):Uint32
GetWindowFromID(Uint32 id):SDL_Window*
GetWindowGammaRamp(SDL_Window* window):custom {
	Uint16 red = 0;
	Uint16 green = 0;
	Uint16 blue = 0;
	int _rtn = SDL_GetWindowGammaRamp(window, &red, &green, &blue);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
								Value(red), Value(green), Value(blue)));
}
GetWindowGrab(SDL_Window* window):SDL_bool
GetWindowID(SDL_Window* window):Uint32
GetWindowMaximumSize(SDL_Window* window):custom {
	int w = 0;
	int h = 0;
	SDL_GetWindowMaximumSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
}
GetWindowMinimumSize(SDL_Window* window):custom {
	int w = 0;
	int h = 0;
	SDL_GetWindowMinimumSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
}
GetWindowPixelFormat(SDL_Window* window):custom {
	Uint32 _rtn = SDL_GetWindowPixelFormat(window);
	if (_rtn == SDL_PIXELFORMAT_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
}
GetWindowPosition(SDL_Window* window):custom {
	int x = 0;
	int y = 0;
	SDL_GetWindowPosition(window, &x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(x), Value(y)));
}
GetWindowSize(SDL_Window*window):custom {
	int w = 0;
	int h = 0;
	SDL_GetWindowSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
}
GetWindowSurface(SDL_Window* window):SDL_Surface*
GetWindowTitle(SDL_Window* window):const char*
#GetWindowWMInfo(SDL_Window* window):custom {
	SDL_SysWMinfo info;
	SDL_bool _rtn = SDL_GetWindowWMInfo(window, &info);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_SysWMinfo(info)));
}
HideWindow(SDL_Window* window)
IsScreenSaverEnabled():SDL_bool
MaximizeWindow(SDL_Window* window)
MinimizeWindow(SDL_Window* window)
RaiseWindow(SDL_Window* window)
RestoreWindow(SDL_Window* window)
SetWindowBordered(SDL_Window* window, SDL_bool bordered)
SetWindowBrightness(SDL_Window* window, float brightness):negerr
#SetWindowData(SDL_Window* window, const char* name, void* userdata#)
SetWindowDisplayMode(SDL_Window* window, const SDL_DisplayMode* mode):negerr
SetWindowFullscreen(SDL_Window* window, Uint32 flags):negerr
SetWindowGammaRamp(SDL_Window* window, [number;Once;List] red, [number;Once;List] green, [number;Once;List] blue):custom_void {
	CArray<Uint16> red(args.GetList(1));
	CArray<Uint16> green(args.GetList(2));
	CArray<Uint16> blue(args.GetList(3));
	if (red.GetSize() != 256 || green.GetSize() != 256 || blue.GetSize() != 256) {
		sig.SetError(ERR_ValueError, "red, green and blue must have 256 elements");
		return Value::Null;
	}
	int _rtn = SDL_SetWindowGammaRamp(window, red, green, blue);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
}
SetWindowGrab(SDL_Window* window, SDL_bool grabbed)
SetWindowHitTest(SDL_Window* window, SDL_HitTest callback#, void* callback_data#):negerr
SetWindowIcon(SDL_Window* window, SDL_Surface* icon)
SetWindowMaximumSize(SDL_Window* window, int max_w, int max_h)
SetWindowMinimumSize(SDL_Window* window, int min_w, int min_h)
SetWindowPosition(SDL_Window* window, int x, int y)
SetWindowSize(SDL_Window* window, int w, int h)
SetWindowTitle(SDL_Window* window, const char* title)
#ShowMessageBox(const SDL_MessageBoxData* messageboxdata#, int* buttonid#):negerr
ShowSimpleMessageBox(Uint32 flags, const char* title, const char* message, SDL_Window* window):negerr
ShowWindow(SDL_Window* window)
UpdateWindowSurface(SDL_Window* window):negerr
UpdateWindowSurfaceRects(SDL_Window* window, [Rect;Once;List] rects):custom_void {
	CArray<SDL_Rect> rects(CreateCArray<SDL_Rect, Object_Rect>(args.GetList(1)));
	int numrects = static_cast<int>(rects.GetSize());
	int _rtn = SDL_UpdateWindowSurfaceRects(window, rects, numrects);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
}
VideoInit(const char* driver_name):negerr
VideoQuit()
//-----------------------------------------------------------------------------
// Video - 2D Accelerated Rendering
CreateRenderer(SDL_Window* window, int index, Uint32 flags):SDL_Renderer*
CreateSoftwareRenderer(SDL_Surface* surface):SDL_Renderer*
CreateTexture(SDL_Renderer* renderer, Uint32 format, int access, int w, int h):SDL_Texture*
CreateTextureFromSurface(SDL_Renderer* renderer, SDL_Surface* surface):SDL_Texture*
DestroyRenderer(SDL_Renderer* renderer)
DestroyTexture(SDL_Texture* texture)
GL_BindTexture(SDL_Texture* texture):custom {
	float texw = 0;
	float texh = 0;
	SDL_GL_BindTexture(texture, &texw, &texh);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(texw), Value(texh)));
}
GL_UnbindTexture(SDL_Texture* texture):negerr
GetNumRenderDrivers():negerr_number
GetRenderDrawBlendMode(SDL_Renderer* renderer):custom {
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetRenderDrawBlendMode(renderer, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
}
GetRenderDrawColor(SDL_Renderer* renderer):custom {
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	Uint8 a = 0;
	int _rtn = SDL_GetRenderDrawColor(renderer, &r, &g, &b, &a);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
								Value(r), Value(g), Value(b), Value(a)));
}
GetRenderDriverInfo(int index):custom {
	SDL_RendererInfo info;
	int _rtn = SDL_GetRenderDriverInfo(index, &info);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_RendererInfo(info)));
}
GetRenderTarget(SDL_Renderer* renderer):custom {
	SDL_Texture *_rtn = SDL_GetRenderTarget(renderer);
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = Value(new Object_Texture(_rtn));
	}
	return ReturnValue(env, sig, args, _rtnVal);
}
GetRenderer(SDL_Window* window):SDL_Renderer*
GetRendererInfo(SDL_Renderer* renderer):custom {
	SDL_RendererInfo info;
	int _rtn = SDL_GetRendererInfo(renderer, &info);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_RendererInfo(info)));
}
GetRenderOutputSize(SDL_Renderer* renderer):custom {
	int w = 0;
	int h = 0;
	int _rtn = SDL_GetRendererOutputSize(renderer, &w, &h);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
}
GetTextureAlphaMod(SDL_Texture* texture):custom {
	Uint8 alpha = 0;
	int _rtn = SDL_GetTextureAlphaMod(texture, &alpha);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(alpha));
}
GetTextureBlendMode(SDL_Texture* texture):custom {
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetTextureBlendMode(texture, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
}
GetTextureColorMod(SDL_Texture* texture):custom {
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	int _rtn = SDL_GetTextureColorMod(texture, &r, &g, &b);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
											Value(r), Value(g), Value(b)));
}
LockTexture(SDL_Texture* texture, const SDL_Rect* rect, void** pixels#, int* pitch#):negerr
QueryTexture(SDL_Texture* texture):custom {
	Uint32 format = 0;
	int access = 0;
	int w = 0;
	int h = 0;
	int _rtn = SDL_QueryTexture(texture, &format, &access, &w, &h);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
							Value(format), Value(access), Value(w), Value(h)));
}
RenderClear(SDL_Renderer* renderer):negerr
RenderCopy(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_Rect* srcrect?, const SDL_Rect* dstrect?):negerr
RenderCopyEx(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_Rect* srcrect?, const SDL_Rect* dstrect?, double angle, const SDL_Point* center?, SDL_RendererFlip flip):negerr
RenderDrawLine(SDL_Renderer* renderer, int x1, int y1, int x2, int y2):negerr
RenderDrawLines(SDL_Renderer* renderer, [Point;Once;List] points):custom_void {
	CArray<SDL_Point> points(CreateCArray<SDL_Point, Object_Point>(args.GetList(1)));
	int count = static_cast<int>(points.GetSize());
	int _rtn = SDL_RenderDrawLines(renderer, points, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
}
RenderDrawPoint(SDL_Renderer* renderer, int x, int y):negerr
RenderDrawPoints(SDL_Renderer* renderer, [Point;Once;List] points):custom_void {
	CArray<SDL_Point> points(CreateCArray<SDL_Point, Object_Point>(args.GetList(1)));
	int count = static_cast<int>(points.GetSize());
	int _rtn = SDL_RenderDrawPoints(renderer, points, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
}
RenderDrawRect(SDL_Renderer* renderer, const SDL_Rect* rect?):negerr
RenderDrawRects(SDL_Renderer* renderer, [Rect;Once;List] rects):custom_void {
	CArray<SDL_Rect> rects(CreateCArray<SDL_Rect, Object_Rect>(args.GetList(1)));
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_RenderDrawRects(renderer, rects, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
}
RenderFillRect(SDL_Renderer* renderer, const SDL_Rect* rect?):negerr
RenderFillRects(SDL_Renderer* renderer, [Rect;Once;List] rects):custom_void {
	CArray<SDL_Rect> rects(CreateCArray<SDL_Rect, Object_Rect>(args.GetList(1)));
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_RenderFillRects(renderer, rects, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
}
RenderGetClipRect(SDL_Renderer* renderer):custom {
	SDL_Rect rect;
	SDL_RenderGetClipRect(renderer, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
}
RenderGetLogicalSize(SDL_Renderer* renderer):custom {
	int w = 0;
	int h = 0;
	SDL_RenderGetLogicalSize(renderer, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
}
RenderGetScale(SDL_Renderer* renderer):custom {
	float scaleX = 0;
	float scaleY = 0;
	SDL_RenderGetScale(renderer, &scaleX, &scaleY);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(scaleX), Value(scaleY)));
}
RenderGetViewport(SDL_Renderer* renderer):custom {
	SDL_Rect rect;
	SDL_RenderGetViewport(renderer, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
}
#RenderIsClipEnabled(SDL_Renderer* renderer):SDL_bool
RenderPresent(SDL_Renderer* renderer)
RenderReadPixels(SDL_Renderer* renderer, const SDL_Rect* rect?, [symbol;Once;None] format):custom {
	Uint32 format = SDL_PIXELFORMAT_UNKNOWN;
	Image::Format fmtImage = Image::FORMAT_None;
	const Symbol *pSymbol = args.GetSymbol(2);
	if (pSymbol->IsIdentical(Gura_Symbol(rgb))) {
		format = SDL_PIXELFORMAT_BGR888;
		fmtImage = Image::FORMAT_RGB;
	} else if (pSymbol->IsIdentical(Gura_Symbol(rgba))) {
		format = SDL_PIXELFORMAT_BGRA8888;
		fmtImage = Image::FORMAT_RGBA;
	} else {
		sig.SetError(ERR_ValueError, "format must be `rgb or `rgba");
		return Value::Null;
	}
	AutoPtr<Image> pImage(new Image(fmtImage));
	if (!pImage->AllocBuffer(sig, rect->w, rect->h, 0x00)) return Value::Null;
	void *pixels = pImage->GetBuffer();
	int pitch = pImage->GetBytesPerLine();
	int _rtn = SDL_RenderReadPixels(renderer, rect, format, pixels, pitch);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_image(env, pImage.release())));
}
RenderSetClipRect(SDL_Renderer* renderer, const SDL_Rect* rect?):negerr
RenderSetLogicalSize(SDL_Renderer* renderer, int w, int h):negerr
RenderSetScale(SDL_Renderer* renderer, float scaleX, float scaleY):negerr
RenderSetViewport(SDL_Renderer* renderer, const SDL_Rect* rect?):negerr
RenderTargetSupported(SDL_Renderer* renderer):SDL_bool
SetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode blendMode)
SetRenderDrawColor(SDL_Renderer* renderer, Uint8 r, Uint8 g, Uint8 b, Uint8 a):negerr
SetRenderTarget(SDL_Renderer* renderer, SDL_Texture *texture?):negerr
SetTextureAlphaMod(SDL_Texture* texture, Uint8 alpha):negerr
SetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode blendMode):negerr
SetTextureColorMod(SDL_Texture* texture, Uint8 r, Uint8 g, Uint8 b):negerr
UnlockTexture(SDL_Texture* texture)
UpdateTexture(SDL_Texture* texture, const SDL_Rect* rect?, const void* pixels#, int pitch):negerr
#UpdateYUVTexture(SDL_Texture* texture, const SDL_Rect* rect?, const Uint8* Yplane, int Ypitch, const Uint8* Uplane, int Upitch, const Uint8* Vplane, int Vpitch):negerr
//-----------------------------------------------------------------------------
// Video - Pixel Formats and Conversion Routines
AllocFormat(Uint32 pixel_format):SDL_PixelFormat*
AllocPalette(int ncolors):SDL_Palette*
CalculateGammaRamp(float gamma):custom {
	Uint16 ramp[256];
	SDL_CalculateGammaRamp(gamma, ramp);
	return ReturnValue(env, sig, args, Value::CreateList(env, ramp, ArraySizeOf(ramp)));
}
FreeFormat(SDL_PixelFormat* format)
FreePalette(SDL_Palette* palette)
GetPixelFormatName(Uint32 format):const char*
GetRGB(Uint32 pixel, const SDL_PixelFormat* format):custom {
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	SDL_GetRGB(pixel, format, &r, &g, &b);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(r), Value(g), Value(b)));
}
GetRGBA(Uint32 pixel, const SDL_PixelFormat* format):custom {
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	Uint8 a = 0;
	SDL_GetRGBA(pixel, format, &r, &g, &b, &a);
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(r), Value(g), Value(b), Value(a)));
}
MapRGB(const SDL_PixelFormat* format, Uint8 r, Uint8 g, Uint8 b):Uint32
MapRGBA(const SDL_PixelFormat* format, Uint8 r, Uint8 g, Uint8 b, Uint8 a):Uint32
MasksToPixelFormatEnum(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):Uint32
PixelFormatEnumToMasks(Uint32 format):custom {
	int bpp = 0;
	Uint32 Rmask = 0;
	Uint32 Gmask = 0;
	Uint32 Bmask = 0;
	Uint32 Amask = 0;
	SDL_bool _rtn = SDL_PixelFormatEnumToMasks(format, &bpp, &Rmask, &Gmask, &Bmask, &Amask);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(bpp), Value(Rmask), Value(Gmask), Value(Bmask), Value(Amask)));
}
SetPaletteColors(SDL_Palette* palette, [Color;Once;List] colors, int firstcolor, int ncolors):custom_void {
	CArray<SDL_Color> colors(CreateCArray<SDL_Color, Object_Color>(args.GetList(1)));
	int nmax = static_cast<int>(colors.GetSize());
	if (firstcolor + ncolors > nmax) {
		sig.SetError(ERR_IndexError, "out of range");
		return Value::Null;
	}
	int _rtn = SDL_SetPaletteColors(palette, colors, firstcolor, ncolors);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
}
SetPixelFormatPalette(SDL_PixelFormat* format, SDL_Palette* palette):negerr
//-----------------------------------------------------------------------------
// Video - Rectangle Functions
EnclosePoints([Point;Once;List] points, const SDL_Rect* clip):custom {
	CArray<SDL_Point> points(CreateCArray<SDL_Point, Object_Point>(args.GetList(0)));
	int count = static_cast<int>(points.GetSize());
	SDL_Rect result;
	SDL_bool _rtn = SDL_EnclosePoints(points, count, clip, &result);
	Value _rtnVal;
	if (_rtn == SDL_TRUE) {
		_rtnVal = Value(new Object_Rect(result));
	}
	return ReturnValue(env, sig, args, _rtnVal);
}
HasIntersection(const SDL_Rect* A, const SDL_Rect* B):SDL_bool
IntersectRect(const SDL_Rect* A, const SDL_Rect* B):custom {
	SDL_Rect result;
	SDL_bool _rtn = SDL_IntersectRect(A, B, &result);
	Value _rtnVal;
	if (_rtn == SDL_TRUE) {
		_rtnVal = Value(new Object_Rect(result));
	}
	return ReturnValue(env, sig, args, _rtnVal);
}
#IntersectRectAndLine(const SDL_Rect* rect, int X1, int Y1, int X2, int Y2):SDL_bool
#PointInRect(const SDL_Point* p, const SDL_Rect* r):SDL_bool
RectEmpty(const SDL_Rect* r):SDL_bool
RectEquals(const SDL_Rect* a, const SDL_Rect* b):SDL_bool
UnionRect(const SDL_Rect* A, const SDL_Rect* B):custom {
	SDL_Rect result;
	SDL_UnionRect(A, B, &result);
	Value _rtnVal = Value(new Object_Rect(result));
	return ReturnValue(env, sig, args, _rtnVal);
}
//-----------------------------------------------------------------------------
// Video - Surface Creation and Simple Drawing
BlitScaled(SDL_Surface* src, const SDL_Rect* srcrect?, SDL_Surface*dst, SDL_Rect* dstrect?):negerr
BlitSurface(SDL_Surface* src, const SDL_Rect* srcrect?, SDL_Surface*dst, SDL_Rect* dstrect?):negerr
ConvertPixels(int width, int height, Uint32 src_format, const void* src#, int src_pitch#, Uint32 dst_format, void* dst#, int dst_pitch#):negerr
ConvertSurface(SDL_Surface* src, const SDL_PixelFormat* fmt, Uint32 flags):SDL_Surface*
ConvertSurfaceFormat(SDL_Surface* src, Uint32 pixel_format, Uint32 flags):SDL_Surface*
CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):SDL_Surface*
CreateRGBSurfaceFrom([binary;Once;None] pixels, int width, int height, int depth, int pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):custom {
	Binary &binary = Object_binary::GetObject(args, 0)->GetBinary();
	if (binary.size() < static_cast<size_t>(height * pitch)) {
		sig.SetError(ERR_ValueError, "pixels doesn not contain enough data");
		return Value::Null;
	}
	void *pixels = const_cast<char *>(binary.data());
	SDL_Surface *_rtn = SDL_CreateRGBSurfaceFrom(pixels, width, height,
								depth, pitch, Rmask, Gmask, Bmask, Amask);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Surface(_rtn)));
}
CreateRGBSurfaceFromImage([image;Once;None] image):custom {
	Image *pImage = Object_image::GetObject(args, 0)->GetImage();
	Object_Surface *pObjSurface = Object_Surface::CreateSurfaceFromImage(sig, pImage);
	if (pObjSurface == NULL) return Value::Null;
	return ReturnValue(env, sig, args, Value(pObjSurface));
}
FillRect(SDL_Surface* dst, const SDL_Rect* rect?, Uint32 color):negerr
FillRects(SDL_Surface* dst, [Rect;Once;List] rects, Uint32 color):custom_void {
	CArray<SDL_Rect> rects(CreateCArray<SDL_Rect, Object_Rect>(args.GetList(1)));
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_FillRects(dst, rects, count, color);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
}
FreeSurface(SDL_Surface* surface)
GetClipRect(SDL_Surface* surface):custom {
	SDL_Rect rect;
	SDL_GetClipRect(surface, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
}
GetColorKey(SDL_Surface* surface):custom {
	Uint32 key = 0;
	int _rtn = SDL_GetColorKey(surface, &key);
	Value _rtnVal;
	if (_rtn >= 0) {
		_rtnVal = Value(key);
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, _rtnVal);
}
GetSurfaceAlphaMod(SDL_Surface* surface):custom {
	Uint8 alpha = 0;
	int _rtn = SDL_GetSurfaceAlphaMod(surface, &alpha);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(alpha));
}
GetSurfaceBlendMode(SDL_Surface* surface):custom {
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetSurfaceBlendMode(surface, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
}
GetSurfaceColorMod(SDL_Surface* surface):custom {
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	int _rtn = SDL_GetSurfaceColorMod(surface, &r, &g, &b);
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(r), Value(g), Value(b)));
}
LoadBMP([stream;Once;None] stream):custom {
	Stream &stream = Object_stream::GetObject(args, 0)->GetStream();
	std::auto_ptr<SDL_RWops> context(CreateRWopsStream(&stream, &sig));
	SDL_Surface *_rtn = SDL_LoadBMP_RW(context.get(), 0);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Surface(_rtn)));
}
#LoadBMP_RW(SDL_RWops* src, int freesrc):SDL_Surface*
LockSurface(SDL_Surface* surface):negerr
LowerBlit(SDL_Surface* src, SDL_Rect* srcrect?, SDL_Surface* dst, SDL_Rect* dstrect):negerr
LowerBlitScaled(SDL_Surface* src, SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect):negerr
MUSTLOCK(SDL_Surface* surface):bool
SaveBMP(SDL_Surface* surface, [stream;Once;None] stream):custom {
	Stream &stream = Object_stream::GetObject(args, 1)->GetStream();
	std::auto_ptr<SDL_RWops> context(CreateRWopsStream(&stream, &sig));
	int _rtn = SDL_SaveBMP_RW(surface, context.get(), 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
}
#SaveBMP_RW(SDL_Surface* surface, SDL_RWops* dst, int freedst):negerr
SetClipRect(SDL_Surface* surface, const SDL_Rect* rect?):SDL_bool
SetColorKey(SDL_Surface* surface, int flag, Uint32 key):negerr
SetSurfaceAlphaMod(SDL_Surface* surface, Uint8 alpha):negerr
SetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode blendMode):negerr
SetSurfaceColorMod(SDL_Surface* surface, Uint8 r, Uint8 g, Uint8 b):negerr
SetSurfacePalette(SDL_Surface* surface, SDL_Palette* palette):negerr
SetSurfaceRLE(SDL_Surface* surface, int flag):negerr
UnlockSurface(SDL_Surface* surface)
//-----------------------------------------------------------------------------
// Video - Platform-specific Window Management
//GetWindowWMInfo(SDL_Window* window, SDL_SysWMinfo* info#):SDL_bool // duplicated
//-----------------------------------------------------------------------------
// Video - Clipboard Handling
GetClipboardText():custom {
	char *_rtn = SDL_GetClipboardText();
	Value _rtnVal(_rtn);
	SDL_free(_rtn);
	return ReturnValue(env, sig, args, _rtnVal);
}
HasClipboardText():SDL_bool
SetClipboardText(const char* text):negerr
//-----------------------------------------------------------------------------
// Input Events - Event Handling
#AddEventWatch()
#DelEventWatch()
EventState(Uint32 type, int state):Uint8
#FilterEvents()
FlushEvent(Uint32 type)
FlushEvents(Uint32 minType, Uint32 maxType)
#GetEventFilter()
GetNumTouchDevices():int
GetNumTouchFingers(SDL_TouchID touchId):negerr_number
GetTouchDevice(int index):custom {
	SDL_TouchID _rtn = SDL_GetTouchDevice(index);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
}
GetTouchFinger(SDL_TouchID touchId, int index):SDL_Finger*
HasEvent(Uint32 type):SDL_bool
HasEvents(Uint32 minType, Uint32 maxType):SDL_bool
#LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops* src):negerr_number
PeepEvents(SDL_Event* events#, int numevents#, SDL_eventaction action, Uint32 minType, Uint32 maxType):negerr
PollEvent():custom {
	SDL_Event event;
	int _rtn = SDL_PollEvent(&event);
	if (_rtn == 0) return Value::Null;
	return ReturnValue(env, sig, args, Value(new Object_Event(event)));
}
PumpEvents()
PushEvent(SDL_Event* event):negerr_boolean
QuitRequested():bool
RecordGesture(SDL_TouchID touchId):negerr_number
RegisterEvents(int numevents):custom {
	Uint32 _rtn = SDL_RegisterEvents(numevents);
	Value _rtnVal;
	if (_rtn != (Uint32)-1) {
		_rtnVal = Value(_rtn);
	}
	return ReturnValue(env, sig, args, _rtnVal);
}
#SaveAllDollarTemplates(SDL_RWops* dst):negerr
#SaveDollarTemplate(SDL_GestureID gestureId, SDL_RWops* dst):negerr
#SetEventFilter()
WaitEvent():custom {
	SDL_Event event;
	int _rtn = SDL_WaitEvent(&event);
	if (_rtn == 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Event(event)));
}
WaitEventTimeout(int timeout):custom {
	SDL_Event event;
	int _rtn = SDL_WaitEventTimeout(&event, timeout);
	Value _rtnVal;
	if (_rtn > 0) {
		_rtnVal = Value(new Object_Event(event));
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, _rtnVal);
}
//-----------------------------------------------------------------------------
// Input Events - Keyboard Support
GetKeyFromName(const char* name):custom {
	SDL_Keycode _rtn = SDL_GetKeyFromName(name);
	if (_rtn == SDLK_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
}
GetKeyFromScancode(SDL_Scancode scancode):SDL_Keycode
GetKeyName(SDL_Keycode key):const char*
GetKeyboardFocus():SDL_Window*
GetKeyboardState():custom {
	int numkeys = 0;
	const Uint8 *_rtn = SDL_GetKeyboardState(&numkeys);
	return ReturnValue(env, sig, args, Value::CreateList(env, _rtn, numkeys));
}
GetModState():SDL_Keymod
GetScancodeFromKey(SDL_Keycode key):SDL_Scancode
GetScancodeFromName(const char* name):custom {
	SDL_Scancode _rtn = SDL_GetScancodeFromName(name);
	if (_rtn == SDL_SCANCODE_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
}
GetScancodeName(SDL_Scancode scancode):const char*
HasScreenKeyboardSupport():SDL_bool
IsScreenKeyboardShown(SDL_Window* window):SDL_bool
IsTextInputActive():SDL_bool
SetModState(SDL_Keymod modstate)
SetTextInputRect(SDL_Rect* rect?)
StartTextInput()
StopTextInput()
//-----------------------------------------------------------------------------
// Input Events - Mouse Support
#CaptureMouse(SDL_bool enalbed):negerr
CreateColorCursor(SDL_Surface* surface, int hot_x, int hot_y):SDL_Cursor*
CreateCursor(const Uint8* data#, const Uint8* mask, int w, int h, int hot_x, int hot_y):SDL_Cursor*
CreateSystemCursor(SDL_SystemCursor id):SDL_Cursor*
FreeCursor(SDL_Cursor* cursor)
GetCursor():custom {
	SDL_Cursor *_rtn = SDL_GetCursor();
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = Value(new Object_Cursor(_rtn, false));
	}
	return ReturnValue(env, sig, args, _rtnVal);
}
GetDefaultCursor():SDL_Cursor*
#GetGlobalMouseState():custom {
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetGlobalMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
}
GetMouseFocus():SDL_Window*
GetMouseState():custom {
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
}
GetRelativeMouseMode():SDL_bool
GetRelativeMouseState():custom {
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetRelativeMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
}
SetCursor(SDL_Cursor* cursor)
SetRelativeMouseMode(SDL_bool enabled):negerr
ShowCursor(int toggle):negerr
#WarpMouseGlobal(int x, int y)
WarpMouseInWindow(SDL_Window* window, int x, int y)
//-----------------------------------------------------------------------------
// Input Events - Joystick Support
JoystickClose(SDL_Joystick* joystick)
JoystickEventState(int state):negerr_boolean
JoystickGetAttached(SDL_Joystick* joystick):SDL_bool
JoystickGetAxis(SDL_Joystick* joystick, int axis):Sint16
JoystickGetBall(SDL_Joystick* joystick, int ball):custom {
	int dx = 0;
	int dy = 0;
	int _rtn = SDL_JoystickGetBall(joystick, ball, &dx, &dy);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(dx), Value(dy)));
}
JoystickGetButton(SDL_Joystick* joystick, int button):custom {
	Uint8 _rtn = SDL_JoystickGetButton(joystick, button);
	return ReturnValue(env, sig, args, Value(_rtn != 0));
}
JoystickGetDeviceGUID(int device_index):SDL_JoystickGUID
JoystickGetGUID(SDL_Joystick* joystick):SDL_JoystickGUID
JoystickGetGUIDFromString(const char* pchGUID):SDL_JoystickGUID
JoystickGetGUIDString(SDL_JoystickGUID guid):custom {
	char szGUID[64];
	int cbGUID = sizeof(szGUID);
	SDL_JoystickGetGUIDString(guid, szGUID, cbGUID);
	return ReturnValue(env, sig, args, Value(szGUID));
}
JoystickGetHat(SDL_Joystick* joystick, int hat):Uint8
JoystickInstanceID(SDL_Joystick* joystick):custom {
	SDL_JoystickID _rtn = SDL_JoystickInstanceID(joystick);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
}
JoystickName(SDL_Joystick* joystick):const char*
JoystickNameForIndex(int device_index):const char*
JoystickNumAxes(SDL_Joystick* joystick):negerr_number
JoystickNumBalls(SDL_Joystick* joystick):negerr_number
JoystickNumButtons(SDL_Joystick* joystick):negerr_number
JoystickNumHats(SDL_Joystick* joystick):negerr_number
JoystickOpen(int device_index):SDL_Joystick*
JoystickUpdate()
NumJoysticks():negerr_number
//-----------------------------------------------------------------------------
// Input Events - Game Controller Support
GameControllerAddMapping(const char* mappingString):negerr_boolean
GameControllerAddMappingsFromFile(const char* filename):negerr_number
#GameControllerAddMappingsFromRW(SDL_RWops* rw, int freerw):negerr_number
GameControllerClose(SDL_GameController* gamecontroller)
GameControllerEventState(int state):int
GameControllerGetAttached(SDL_GameController* gamecontroller):SDL_bool
GameControllerGetAxis(SDL_GameController* gamecontroller, SDL_GameControllerAxis axis):Sint16
GameControllerGetAxisFromString(const char* pchString):SDL_GameControllerAxis
GameControllerGetBindForAxis(SDL_GameController* gamecontroller, SDL_GameControllerAxis axis):SDL_GameControllerButtonBind
GameControllerGetBindForButton(SDL_GameController* gamecontroller, SDL_GameControllerButton button):SDL_GameControllerButtonBind
GameControllerGetButton(SDL_GameController* gamecontroller, SDL_GameControllerButton button):custom {
	Uint8 _rtn = SDL_GameControllerGetButton(gamecontroller, button);
	if (_rtn == 0 && *SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn != 0));
}
GameControllerGetButtonFromString(const char* pchString):SDL_GameControllerButton
GameControllerGetJoystick(SDL_GameController* gamecontroller):SDL_Joystick*
GameControllerGetStringForAxis(SDL_GameControllerAxis axis):const char*
GameControllerGetStringForButton(SDL_GameControllerButton button):const char*
GameControllerMapping(SDL_GameController* gamecontroller):const char*
GameControllerMappingForGUID(SDL_JoystickGUID guid):const char*
GameControllerName(SDL_GameController* gamecontroller):const char*
GameControllerNameForIndex(int joystick_index):const char*
GameControllerOpen(int joystick_index):SDL_GameController*
GameControllerUpdate()
IsGameController(int joystick_index):SDL_bool
//-----------------------------------------------------------------------------
// Force Feedback - Force Feedback Support
HapticClose(SDL_Haptic* haptic)
HapticDestroyEffect(SDL_Haptic* haptic, int effect)
HapticEffectSupported(SDL_Haptic* haptic, SDL_HapticEffect* effect):negerr_boolean
HapticGetEffectStatus(SDL_Haptic* haptic, int effect):negerr_boolean
HapticIndex(SDL_Haptic* haptic):negerr_number
HapticName(int device_index):const char*
HapticNewEffect(SDL_Haptic* haptic, SDL_HapticEffect* effect):negerr_number
HapticNumAxes(SDL_Haptic* haptic):negerr_number
HapticNumEffects(SDL_Haptic* haptic):negerr_number
HapticNumEffectsPlaying(SDL_Haptic* haptic):negerr_number
HapticOpen(int device_index):SDL_Haptic*
HapticOpenFromJoystick(SDL_Joystick* joystick):SDL_Haptic*
HapticOpenFromMouse():SDL_Haptic*
HapticOpened(int device_index):negerr_boolean
HapticPause(SDL_Haptic* haptic):negerr
HapticQuery(SDL_Haptic* haptic):unsigned int
HapticRumbleInit(SDL_Haptic* haptic):negerr
HapticRumblePlay(SDL_Haptic* haptic, float strength, Uint32 length):negerr
HapticRumbleStop(SDL_Haptic* haptic):negerr
HapticRumbleSupported(SDL_Haptic* haptic):negerr_boolean
HapticRunEffect(SDL_Haptic* haptic, int effect, Uint32 iterations):negerr
HapticSetAutocenter(SDL_Haptic* haptic, int autocenter):negerr
HapticSetGain(SDL_Haptic* haptic, int gain):negerr
HapticStopAll(SDL_Haptic* haptic):negerr
HapticStopEffect(SDL_Haptic* haptic, int effect):negerr
HapticUnpause(SDL_Haptic* haptic):negerr
HapticUpdateEffect(SDL_Haptic* haptic, int effect, SDL_HapticEffect* data):negerr
JoystickIsHaptic(SDL_Joystick* joystick):negerr_boolean
MouseIsHaptic():negerr_boolean
NumHaptics():negerr_number
//-----------------------------------------------------------------------------
// Audio - Audio Device Management, Playing and Recording
AudioInit(const char* driver_name):negerr
AudioQuit()
BuildAudioCVT(SDL_AudioCVT* cvt, SDL_AudioFormat src_format, Uint8 src_channels, int src_rate, SDL_AudioFormat dst_format, Uint8 dst_channels, int dst_rate):negerr_boolean
#ClearQueuedAudio(SDL_AudioDeviceID dev)
CloseAudio()
CloseAudioDevice(SDL_AudioDeviceID dev)
ConvertAudio(SDL_AudioCVT* cvt):negerr
FreeWAV([Wav;Once;None] wav):custom {
	Object_Wav *pObj = Object_Wav::GetObject(args, 0);
	Uint8 *buffer = pObj->GetBuffer();
	SDL_FreeWAV(buffer);
}
GetAudioDeviceName(int index, int iscapture):const char*
GetAudioDeviceStatus(SDL_AudioDeviceID dev):SDL_AudioStatus
GetAudioDriver(int index):const char*
GetAudioStatus():SDL_AudioStatus
GetCurrentAudioDriver():const char*
GetNumAudioDevices(int iscapture):negerr_number
GetNumAudioDrivers():int
#GetQueuedAudioSize(SDL_AudioDeviceID dev):Uint32
LoadWAV(const char* file):custom {
	SDL_AudioSpec spec;
	Uint8 *audio_buf = NULL;
	Uint32 audio_len = 0;
	SDL_AudioSpec *_rtn = SDL_LoadWAV(file, &spec, &audio_buf, &audio_len);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Wav(spec, audio_buf, audio_len)));
}
#LoadWAV_RW(SDL_RWops* src, int freesrc, SDL_AudioSpec* spec, Uint8** audio_buf#, Uint32* audio_len#):SDL_AudioSpec*
LockAudio()
LockAudioDevice(SDL_AudioDeviceID dev)
MixAudio(Uint8* dst#, const Uint8* src#, Uint32 len#, int volume)
MixAudioFormat(Uint8* dst#, const Uint8* src#, SDL_AudioFormat format, Uint32 len#, int volume)
OpenAudio(SDL_AudioSpec* desired):custom {
	SDL_AudioSpec obtained;
	int _rtn = SDL_OpenAudio(desired, &obtained);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_AudioSpec(obtained)));
}
OpenAudioDevice(const char* device, int iscapture, const SDL_AudioSpec* desired, SDL_AudioSpec* obtained#, int allowed_changes):SDL_AudioDeviceID
PauseAudio(int pause_on)
PauseAudioDevice(SDL_AudioDeviceID dev, int pause_on)
QueueAudio(SDL_AudioDeviceID dev, const void* data#, Uint32 len#):negerr
UnlockAudio()
UnlockAudioDevice(SDL_AudioDeviceID dev)
AUDIO_BITSIZE(Uint16 x):Uint16
AUDIO_ISFLOAT(Uint16 x):Uint16_boolean
AUDIO_ISBIGENDIAN(Uint16 x):Uint16_boolean
AUDIO_ISSIGNED(Uint16 x):Uint16_boolean
AUDIO_ISINT(Uint16 x):bool
AUDIO_ISLITTLEENDIAN(Uint16 x):bool
AUDIO_ISUNSIGNED(Uint16 x):bool
//-----------------------------------------------------------------------------
// Threads - Thread Management
CreateThread
DetachThread
GetThreadID
GetThreadName
GetThreadPriority
TLSCreate
TLSGet
TLSSet
ThreadID
WaitThread
//-----------------------------------------------------------------------------
// Threads - Thread Synchronization Primitives
CondBroadcast
CondSignal
CondWait
CondWaitTimeout
CreateCond
CreateMutex
CreateSemaphore
DestroyCond
DestroyMutex
DestroySemaphore
LockMutex
SemPost
SemTryWait
SemValue
SemWait
SemWaitTimeout
TryLockMutex
UnlockMutex
//-----------------------------------------------------------------------------
// Threads - Atomic Operations
AtomicAdd
AtomicCAS
AtomicCASPtr
AtomicDecRef
AtomicGet
AtomicGetPtr
AtomicIncRef
AtomicLock
AtomicSet
AtomicSetPtr
AtomicTryLock
AtomicUnlock
CompilerBarrier
//-----------------------------------------------------------------------------
// Timers - Timer Support
AddTimer(Uint32 interval, SDL_TimerCallback callback#, void* param#):SDL_TimerID
Delay(Uint32 ms)
GetPerformanceCounter():Uint64
GetPerformanceFrequency():Uint64
GetTicks():Uint32
RemoveTimer(SDL_TimerID id):SDL_bool
TICKS_PASSED(Uint32 A, Uint32 B):bool
//-----------------------------------------------------------------------------
// File Abstraction - Filesystem Paths
#GetBasePath():char*
#GetPrefPath(const char* org, const char* app):char*
//-----------------------------------------------------------------------------
// File Abstraction - File I/O Abstraction
AllocRW
FreeRW
RWFromConstMem
RWFromFP
RWFromFile
RWFromMem
RWclose
RWread
RWseek
RWtell
RWwrite
ReadBE16
ReadBE32
ReadBE64
ReadLE16
ReadLE32
ReadLE64
WriteBE16
WriteBE32
WriteBE64
WriteLE16
WriteLE32
WriteLE64
//-----------------------------------------------------------------------------
// Shared Object Support - Shared Object Loading and Function Lookup
//-----------------------------------------------------------------------------
// Platform and CPU Information - Platform Detection
GetPlatform():const char*
//-----------------------------------------------------------------------------
// Platform and CPU Information - CPU Feature Detection
GetCPUCacheLineSize():int
GetCPUCount():int
GetSystemRAM():int
Has3DNow():SDL_bool
HasAVX():SDL_bool
#HasAVX2():SDL_bool
HasAltiVec():SDL_bool
HasMMX():SDL_bool
HasRDTSC():SDL_bool
HasSSE():SDL_bool
HasSSE2():SDL_bool
HasSSE3():SDL_bool
HasSSE41():SDL_bool
HasSSE42():SDL_bool
//-----------------------------------------------------------------------------
// Platform and CPU Information - Byte Order and Byte Swapping
Swap16
Swap32
Swap64
SwapBE16
SwapBE32
SwapBE64
SwapFloat
SwapFloatBE
SwapFloatLE
SwapLE16
SwapLE32
SwapLE64
//-----------------------------------------------------------------------------
// Platform and CPU Information - Bit Manipulation
#MostSignificantBitIndex32(Uint32 x):int
//-----------------------------------------------------------------------------
// Power Management - Power Management Status
GetPowerInfo():custom {
	int secs = 0;
	int pct = 0;
	SDL_PowerState _rtn = SDL_GetPowerInfo(&secs, &pct);
	return ReturnValue(env, sig, args, Value::CreateList(env,
									Value(_rtn), Value(secs), Value(pct)));
}
//-----------------------------------------------------------------------------
// Additional - Platform-specific functionality
AndroidGetActivity
AndroidGetExternalStoragePath
AndroidGetExternalStorageState
AndroidGetInternalStoragePath
AndroidGetJNIEnv
//-----------------------------------------------------------------------------
// Additional - Other
acos(double x):double
'''

tmplImplementation = R'''
// sdl2.${fi.funcName}
Gura_DeclareFunction(${fi.funcName})
{
	${if (fi.voidFlag)}
	SetMode(RSLTMODE_Void, FLAG_None);
	${else}
	SetMode(RSLTMODE_Normal, FLAG_Map);
	DeclareBlock(OCCUR_ZeroOrOnce);
	${end}
	${for (arg in fi.argsGura)}
	DeclareArg(env, "${arg.name}", VTYPE_${arg.typeGura}, OCCUR_${arg.occurPattern}, ${('FLAG_' + arg.flags).join(' | ')});
	${end}
	AddHelp(Gura_Symbol(en), Help::FMT_markdown,
	"");
}

Gura_ImplementFunction(${fi.funcName})
{
	${if (!fi.validFlag)}
#if 0
	${end}
	${argsCJoined = fi.argsC:*name.join(', '), -}
	${for (argC in fi.argsC) {|idx|}}
	${if (argC.fmtGetter)}
	${argC.typeC.sub(r'(\w)$', r'\1 ') + argC.name} = ${
		if (!argC.typeC.endswith('*')) {
			argC.GetArg(idx)
		} elsif (argC.flags.find('Nil')) {
			format('args.IsValid(%d)? ', idx) + argC.GetArg(idx) + ' : NULL'
		} else {
			argC.GetArg(idx)
		}
	};
	${end}
	${end}
	${if (fi.linesCustom)}
	${fi.linesCustom}
	${elsif (!fi.rtnInfo)}
	SDL_${fi.funcName}(${argsCJoined});
	return Value::Null;
	${elsif (fi.rtnInfo.typeC == 'negerr')}
	int _rtn = SDL_${fi.funcName}(${argsCJoined});
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
	${elsif (fi.rtnInfo.typeC == 'boolerr')}
	int _rtn = SDL_${fi.funcName}(${argsCJoined});
	if (_rtn == 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
	${elsif (fi.rtnInfo.typeC == 'negerr_number')}
	int _rtn = SDL_${fi.funcName}(${argsCJoined});
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
	${elsif (fi.rtnInfo.typeC == 'negerr_boolean')}
	int _rtn = SDL_${fi.funcName}(${argsCJoined});
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn != 0));
	${elsif (fi.rtnInfo.typeC == 'Uint16_boolean')}
	Uint16 _rtn = SDL_${fi.funcName}(${argsCJoined});
	return ReturnValue(env, sig, args, Value(_rtn != 0));
	${else}
	${fi.rtnInfo.typeC.sub(r'(\w)$', r'\1 ')}_rtn = SDL_${fi.funcName}(${argsCJoined});
	${if (fi.rtnInfo.typeC.endswith('*'))}
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = ${fi.rtnInfo.fmtReturn};
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	${else}
	Value _rtnVal = ${fi.rtnInfo.fmtReturn};
	${end}
	return ReturnValue(env, sig, args, _rtnVal);
	${end}
	${if (!fi.validFlag)}
#endif
	SetError_NotImpFunction(sig, "${fi.funcName}");
	return Value::Null;
	${end}
}
'''.template()

tmplAssignment = R'''
	Gura_AssignFunction(${fi.funcName});
'''.template()

ArgInfo = struct(name:string, typeC:string,
				 moduleName:string:nil, typeGura:string:nil, fmtGetter:string:nil,
				 occurPattern:string, flags[]:string) {
	GetArg(idx:number) = format(this.fmtGetter, idx)
	GetFullTypeGura() = cond(this.moduleName,
							 this.moduleName + '.' + this.typeGura, this.typeGura)
}

ReturnInfo = struct(typeC:string, typeGura:string:nil, fmtReturn:string:nil) {
}

TypeConv = struct(moduleName:string:nil, typeGura:string, fmtGetter:string, fmtReturn:string)

typeConvDict = %{
	'custom' => TypeConv(nil, nil, nil, nil)
	'char' => TypeConv(nil, 'number', 'args.GetChar(%d)', 'Value(_rtn)')
	'int' => TypeConv(nil, 'number', 'args.GetInt(%d)', 'Value(_rtn)')
	'unsigned int' => TypeConv(nil, 'number', 'args.GetUInt(%d)', 'Value(_rtn)')
	'short' => TypeConv(nil, 'number', 'args.GetShort(%d)', 'Value(_rtn)')
	'float' => TypeConv(nil, 'number', 'args.GetFloat(%d)', 'Value(_rtn)')
	'double' => TypeConv(nil, 'number', 'args.GetDouble(%d)', 'Value(_rtn)')
	'Uint8' => TypeConv(nil, 'number', 'args.GetUChar(%d)', 'Value(_rtn)')
	'Uint16' => TypeConv(nil, 'number', 'args.GetUShort(%d)', 'Value(_rtn)')
	'Uint32' => TypeConv(nil, 'number', 'args.GetULong(%d)', 'Value(_rtn)')
	'Uint64' => TypeConv(nil, 'number', 'static_cast<Uint64>(args.GetDouble(%d))', 'Value(_rtn)')
	'Sint8' => TypeConv(nil, 'number', 'args.GetChar(%d)', 'Value(_rtn)')
	'Sint16' => TypeConv(nil, 'number', 'args.GetShort(%d)', 'Value(_rtn)')
	'Sint32' => TypeConv(nil, 'number', 'args.GetLong(%d)', 'Value(_rtn)')
	'char *' => TypeConv(nil, 'string', 'args.GetString(%d)', 'Value(_rtn)')
	'const char *' => TypeConv(nil, 'string', 'args.GetString(%d)', 'Value(_rtn)')
	'const Uint8 *' => TypeConv(nil, 'number', 'args.GetList(%d)', 'Value::Null')
	'bool' => TypeConv(nil, 'boolean', 'args.GetBoolean(%d)', 'Value(_rtn)')
	'SDL_bool' => TypeConv(nil, 'boolean', '(args.GetBoolean(%d)? SDL_TRUE : SDL_FALSE)', 'Value(_rtn != SDL_FALSE)')
	'SDL_eventaction' => TypeConv(
			nil, 'number',
			'static_cast<SDL_eventaction>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_GLattr' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GLattr>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_AudioDeviceID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_AudioDeviceID>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_AudioStatus' => TypeConv(
			nil, 'number',
			'static_cast<SDL_AudioStatus>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_PowerState' => TypeConv(
			nil, 'number',
			'static_cast<SDL_PowerState>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_TouchID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_TouchID>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_JoystickID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_JoystickID>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_GestureID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GestureID>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_TimerID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_TimerID>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_RendererFlip' => TypeConv(
			nil, 'number',
			'static_cast<SDL_RendererFlip>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_BlendMode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_BlendMode>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_Keycode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Keycode>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_Scancode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Scancode>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_Keymod' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Keymod>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_SystemCursor' => TypeConv(
			nil, 'number',
			'static_cast<SDL_SystemCursor>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_GameControllerAxis' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GameControllerAxis>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_GameControllerButton' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GameControllerButton>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_AudioFormat' => TypeConv(
			nil, 'number',
			'static_cast<SDL_AudioFormat>(args.GetInt(%d))',
			'Value(_rtn)')
	'SDL_JoystickGUID' => TypeConv(
			'sdl2', 'JoystickGUID',
			'*Object_JoystickGUID::GetObject(args, %d)->GetEntity()',
			'Value(new Object_JoystickGUID(_rtn))')
	'SDL_GLContext' => TypeConv(
			'sdl2', 'GLContext',
			'Object_GLContext::GetObject(args, %d)->GetEntity()',
			'Value(new Object_GLContext(_rtn))')
	'gura#Image *' => TypeConv(
			'sdl2', 'Image',
			'Object_Image::GetObject(args, %d)->GetImage()',
			'Value(new Object_Image(env, _rtn))')
	'SDL_AudioCVT *' => TypeConv(
			'sdl2', 'AudioCVT',
			'Object_AudioCVT::GetObject(args, %d)->GetEntity()',
			'Value(new Object_AudioCVT(_rtn))')
	'SDL_AudioSpec *' => TypeConv(
			'sdl2', 'AudioSpec',
			'Object_AudioSpec::GetObject(args, %d)->GetEntity()',
			'Value(new Object_AudioSpec(_rtn))')
	'const SDL_AudioSpec *' => TypeConv(
			'sdl2', 'AudioSpec',
			'Object_AudioSpec::GetObject(args, %d)->GetEntity()',
			'Value(new Object_AudioSpec(_rtn))')
	'SDL_Finger *' => TypeConv(
			'sdl2', 'Finger',
			'Object_Finger::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Finger(_rtn))')
	'SDL_Haptic *' => TypeConv(
			'sdl2', 'Haptic',
			'Object_Haptic::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Haptic(_rtn))')
	'SDL_HapticEffect *' => TypeConv(
			'sdl2', 'HapticEffect',
			'Object_HapticEffect::GetObject(args, %d)->GetEntity()',
			'Value(new Object_HapticEffect(_rtn))')
	'SDL_Event' => TypeConv(
			'sdl2', 'Event',
			'*Object_Event::GetObject(args, %d)->GetEntity()',
			nil)
	'SDL_Event *' => TypeConv(
			'sdl2', 'Event',
			'Object_Event::GetObject(args, %d)->GetEntity()',
			nil)
	'SDL_Rect *' => TypeConv(
			'sdl2', 'Rect',
			'Object_Rect::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Rect(_rtn))')
	'SDL_Point *' => TypeConv(
			'sdl2', 'Point',
			'Object_Point::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Point(_rtn))')
	'const SDL_Rect *' => TypeConv(
			'sdl2', 'Rect',
			'Object_Rect::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Rect(_rtn))')
	'const SDL_Point *' => TypeConv(
			'sdl2', 'Point',
			'Object_Point::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Point(_rtn))')
	'SDL_Window *' => TypeConv(
			'sdl2', 'Window',
			'Object_Window::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Window(_rtn))')
	'SDL_Surface *' => TypeConv(
			'sdl2', 'Surface',
			'Object_Surface::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Surface(_rtn))')
	'SDL_RWops *' => TypeConv(
			'sdl2', 'nil',
			'NULL',
			'Value::Null')
	'SDL_Renderer *' => TypeConv(
			'sdl2', 'Renderer',
			'Object_Renderer::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Renderer(_rtn))')
	'SDL_Texture *' => TypeConv(
			'sdl2', 'Texture',
			'Object_Texture::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Texture(_rtn))')
	'SDL_SysWMinfo *' => TypeConv(
			'sdl2', 'SysWMinfo',
			'Object_SysWMinfo::GetObject(args, %d)->GetEntity()',
			'Value(new Object_SysWMinfo(_rtn))')
	'SDL_PixelFormat *' => TypeConv(
			'sdl2', 'PixelFormat',
			'Object_PixelFormat::GetObject(args, %d)->GetEntity()',
			'Value(new Object_PixelFormat(_rtn))')
	'const SDL_PixelFormat *' => TypeConv(
			'sdl2', 'PixelFormat',
			'Object_PixelFormat::GetObject(args, %d)->GetEntity()',
			'Value(new Object_PixelFormat(_rtn))')
	'SDL_Palette *' => TypeConv(
			'sdl2', 'Palette',
			'Object_Palette::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Palette(_rtn))')
	'SDL_Cursor *' => TypeConv(
			'sdl2', 'Cursor',
			'Object_Cursor::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Cursor(_rtn, false))')
	'SDL_Joystick *' => TypeConv(
			'sdl2', 'Joystick',
			'Object_Joystick::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Joystick(_rtn))')
	'SDL_GameController *' => TypeConv(
			'sdl2', 'GameController',
			'Object_GameController::GetObject(args, %d)->GetEntity()',
			'Value(new Object_GameController(_rtn))')
	'SDL_GameControllerButtonBind' => TypeConv(
			'sdl2', 'GameControllerButtonBind',
			'Object_GameControllerButtonBind::GetObject(args, %d)->GetEntity()',
			'Value(new Object_GameControllerButtonBind(_rtn))')
	'SDL_DisplayMode *' => TypeConv(
			'sdl2', 'DisplayMode',
			'Object_DisplayMode::GetObject(args, %d)->GetEntity()',
			'Value(new Object_DisplayMode(_rtn))')
	'const SDL_DisplayMode *' => TypeConv(
			'sdl2', 'DisplayMode',
			'Object_DisplayMode::GetObject(args, %d)->GetEntity()',
			'Value(new Object_DisplayMode(_rtn))')
}

FuncInfo = class {
	public {
		funcName, argsC, argsGura, rtnInfo, validFlag, voidFlag, linesCustom
	}
	__init__(lineNo:number, funcName:string, argsRaw:string:nil, rtnRaw:string:nil) = {
		this.argsRaw = argsRaw
		this.validFlag = this.argsRaw?
		if (funcName.startswith('#')) {
			this.funcName = funcName.replace('#', '')
			this.validFlag = false
		} else {
			this.funcName = funcName
		}
		if (rtnRaw && rtnRaw.isempty()) { rtnRaw = nil }
		this.rtnRaw = rtnRaw
		this.argsC = []
		this.argsGura = []
		this.rtnInfo = nil
		this.voidFlag = false
		this.linesCustom = nil
		if (this.argsRaw) {
			this.argsC = this.argsRaw.split(',').each():xlist {|argRaw|
				argRaw = argRaw.strip()
				argRaw.isempty() && continue
				if (m = argRaw.match(r'^\[([\w\s;]+)\]\s+(\w+)$')) {
					typeC = nil
					name = m[2]
					fields = m[1].split(';')::strip()
					if (fields.len() != 3) {
						sys.stderr.printf('%d: invalid argument "%s"\n', lineNo, argRaw)
						sys.exit(1)
					}
					[typeGura, occurPattern, flagsRaw] = fields
					ArgInfo(name, typeC, nil, typeGura, nil,
							occurPattern, flagsRaw.split('|')::strip())
				} else {
					occurPattern = 'Once'
					flags = ['None']
					if (m = argRaw.match(r'^(\w+)\s+(\w+)([#\?]?)$')) {
						[typeC, name, attr] = m[1, 2, 3]
					} elsif (m = argRaw.match(r'^unsigned\s+(\w+)\s+(\w+)([#\?]?)$')) {
						[typeC, name, attr] = ['unsigned ' + m[1], m[2], m[3]]
					} elsif (m = argRaw.match(r'^(\w+)\s*(\*+)\s*(\w+)([#\?]?)$')) {
						[typeC, name, attr] = [m[1] + ' ' + m[2], m[3], m[4]]
					} elsif (m = argRaw.match(r'^const\s+(\w+)\s*(\*+)\s*(\w+)([#\?]?)$')) {
						[typeC, name, attr] = ['const ' + m[1] + ' ' + m[2], m[3], m[4]]
					} else {
						sys.stderr.printf('%d: invalid argument "%s"\n', lineNo, argRaw)
						sys.exit(1)
					}
					if (attr == '#') {
						this.validFlag = false
						ArgInfo(name, typeC, nil, nil, 'NULL', occurPattern, flags)
					} else {
						typeConv = typeConvDict.get(typeC)
						if (attr == '?') {
							flags = ['Nil']
						}
						if (!typeConv) {
							sys.stderr.printf(
									'%d: proper conversion not found in table "%s"\n',
									lineNo, argRaw)
							sys.exit(1)
						}
						ArgInfo(name, typeC, typeConv.moduleName,
								typeConv.typeGura, typeConv.fmtGetter,
								occurPattern, flags)
					}
				}
			}
		}
		if (!this.rtnRaw) {
			// nothing to do
		} elsif (this.rtnRaw in ['custom', 'custom_void', 'negerr',
 				'boolerr', 'negerr_number', 'negerr_boolean', 'Uint16_boolean']) {
			this.rtnInfo = ReturnInfo(this.rtnRaw, nil, nil)
		} else {
			if (m = rtnRaw.match(r'^(\w+)$')) {
				typeC = m[1]
			} elsif (m = rtnRaw.match(r'^unsigned\s+(\w+)$')) {
				typeC = 'unsigned ' + m[1]
			} elsif (m = rtnRaw.match(r'^(\w+)\s*\*\s*$')) {
				typeC = m[1] + ' *'
			} elsif (m = rtnRaw.match(r'^const\s+(\w+)\s*\*\s*$')) {
				typeC = 'const ' + m[1] + ' *'
			} else {
				sys.stderr.printf('%d: invalid return type "%s"\n', lineNo, rtnRaw)
				sys.exit(1)
			}
			typeConv = typeConvDict.get(typeC)
			if (!typeConv) {
				sys.stderr.printf('%d: invalid return type "%s"\n', lineNo, rtnRaw)
				sys.exit(1)
			}
			this.rtnInfo = ReturnInfo(typeC, typeConv.typeGura, typeConv.fmtReturn)
		}
		this.argsGura = this.argsC.filter(this.argsC:*typeGura):list
		this.voidFlag = (!this.rtnInfo || \
						 this.rtnInfo.typeC in ['custom_void', 'negerr', 'boolerr'])
	}
	SetLinesCustom(linesCustom:string) = {
		this.linesCustom = linesCustom
	}
	RenderImplementation() = {
		fi = this
		tmplImplementation.render()
	}
	RenderAssignment() = {
		fi = this
		tmplAssignment.render()
	}
}

funcInfos = []
stat = `init
linesCustom = ''
text.eachline {|line, i|
	if (stat == `init) {
		line = line.strip()
		(line.startswith('//') || line.isempty()) && continue
		lineNo = i + 1
		restPart = line
		fields = restPart.split(':')
		argsRaw = nil
		rtnRaw = nil
		if (fields.len() > 1) {
			[restPart, rtnRaw] = fields
		}
		if (m = restPart.match(r'(.*)\(([^\)]*)\)')) {
			[restPart, argsRaw] = m[1, 2]
		}
		if (m = restPart.match(r'^(#?\w+)$')) {
			funcName = m[1]
			if (funcInfos:*funcName.find(funcName)) {
				sys.stderr.printf('%d: duplicated function %s\n', lineNo, funcName)
				sys.exit(1)
			}
			if (rtnRaw && (m = rtnRaw.match(r'(\w+)\s*{$'))) {
				rtnRaw = m[1]
				linesCustom = ''
				stat = `custom
			}
			funcInfo = FuncInfo(lineNo, funcName, argsRaw, rtnRaw)
			funcInfos.add(funcInfo)
		} else {
			sys.stderr.printf('%d: invalid format\n', lineNo)
			sys.exit(1)
		}
	} elsif (stat == `custom) {
		if (line.match(r'^}\s*$')) {
			funcInfo.SetLinesCustom(linesCustom)
			stat = `init
		} else {
			line = line.sub('(^\t|    )', '')
			linesCustom += line
		}
	}
}

if (sys.argv.len() > 1 && sys.argv[1] == 'test') {
	print(funcInfos:*RenderImplementation())
	//print(funcInfos:*RenderAsignment())
} else {
	fileNameTmpl = 'Functions.cpp.tmpl'
	fileNameOut = 'Functions.cpp'
	template(fileNameTmpl).render(fileNameOut)
	println(fileNameOut, ' was created')
}
