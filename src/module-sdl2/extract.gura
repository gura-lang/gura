#!/usr/bin/env gura
import(re)

text = R'''
//-----------------------------------------------------------------------------
// Basics - Initialization and Shutdown
Init(Uint32 flags):error
InitSubSystem(Uint32 flags):error
Quit()
QuitSubSystem(Uint32 flags)
SetMainReady()
WasInit(Uint32 flags):Uint32
//-----------------------------------------------------------------------------
// Basics - Configuration Variables
AddHintCallback
ClearHints
DelhintCallback
GetHint
SetHint
SetHintWithPriority
//-----------------------------------------------------------------------------
// Basics - Error Handling
ClearError()
GetError():const char*
SetError
//-----------------------------------------------------------------------------
// Basics - Log Handling
Log
LogCritical
LogDebug
LogError
LogGetOutputFunction
LogGetPriority
LogInfo
LogMessage
LogMessageV
LogResetPriorities
LogSetAllPriority
LogSetOutputFunction
LogSetPriority
LogVerbose
LogWarn
//-----------------------------------------------------------------------------
// Basics - Assertions
GetAssertionHandler
GetAssertionReport
GetDefaultAssertionHandler
ResetAssertionReport
SetAssertionHandler
TriggerBreakpoint
assert
assert_paranoid
assert_release
//-----------------------------------------------------------------------------
// Basics - Querying SDL Version
GetRevision
GetRevisionNumber
GetVersion
//-----------------------------------------------------------------------------
// Video - Display and Window Management
CreateWindow(const char* title, int x, int y, int w, int h, Uint32 flags):SDL_Window *
'''

text2 = R'''
CreateWindowAndRenderer(int width, int height, Uint32 window_flags, SDL_Window** window, SDL_Renderer** renderer):error
CreateWindowFrom
DestroyWindow
DisableScreenSaver
EnableScreenSaver
GL_CreateContext
DeleteContext
GL_ExtensionSupported
GL_GetAttribute
GL_GetCurrentContext
GL_GetCurrentWindow
GL_GetDrawableSize
GL_GetProcAddress
GL_GetSwapInterval
GL_LoadLibrary
GL_MakeCurrent
GL_ResetAttributes
GL_SetAttribute
GL_SetSwapInterval
GL_SwapWindow
GL_UnloadLibrary
GetClosestDisplayMode
GetCurrentDisplayMode
GetCurrentVideoDriver
GetDesktopDisplayMode
GetDisplayBounds
GetDisplayMode
GetDisplayName
GetNumDisplayModes
GetNumVideoDisplays
GetNumVideoDrivers
GetVideoDriver
GetWindowBrightness
GetWindowData
GetWindowDisplayIndex
GetWindowDisplayMode
GetWindowFlags
GetWindowFromID
GetWindowGammaRamp
GetWindowGrab
GetWindowID
GetWindowMaximumSize
GetWindowMinimumSize
GetWindowPixelFormat
GetWindowPosition
GetWindowSize
GetWindowSurface
GetWindowTitle
GetWindowWMInfo
HideWindow
IsScreenSaverEnabled
MaximizeWindow
MinimizeWindow
RaiseWindow
ResotoreWindow
SetWindowBordered
SetWindowBrightness
SetWindowData
SetWindowDisplayMode
SetWindowFullscreen
SetWindowGammaRamp
SetWindowGrab
SetWindowHitTest
SetWindowIcon
SetWindowMaximumSize
SetWindowMinimumSize
SetWindowPosition
SetWindowSize
SetWindowTitle
//ShowMessageBox
ShowSimpleMessageBox
ShowWindow
UpdateWindowSurface
UpdateWindowSurfaceRects
VideoInit
VideoQuit
//-----------------------------------------------------------------------------
// Video - 2D Accelerated Rendering
CreateRenderer
CreateSoftwareRenderer
CreateTexture
CreateTextureFromSurface
//CreateWindowAndRenderer
DestroyRenderer
DestroyTexture
GL_BindTexture
GL_UnbindTexture
GetNumRenderDrivers
GetRenderDrawBlendMode
GetRenderDrawColor
GetRenderDriverInfo
GetRenderTarget
GetRenderer
GetRenderInfo
GetRenderOutputSize
GetTextureAlphaMod
GetTextureBlendMode
GetTextureColorMod
LockTexture
QueryTexture
RenderClear
RenderCopy
RenderCopyEx
DrawLine
DrawLines
DrawPoint
DrawPoints
RenderDrawRect
RenderDrawRects
RenderFillRect
RenderFillRects
RenderGetClipRect
RenderGetLogicalSize
RenderGetScale
RenderGetViewport
RenderIsClipEnabled
RenderPresent
RenderReadPixels
RenderSetClipRect
RenderSetLogicalSize
RenderSetScale
RenderSetViewport
RenderTargetSupported
SetRenderDrawBlendMode
SetRenderDrawColor
SetRenderTarget
SetTextureAlphaMod
SetTextureBlendMode
SetTextureColorMod
UnlockTexture
UpdateTexture
UpdateYUVTexture
//-----------------------------------------------------------------------------
// Video - Pixel Formats and Conversion Routines
AllocFormat
AllocPalette
CalculateGammaRamp
FreeFormat
FreePalette
GetPixelFormatName
GetRGB
GetRGBA
MapRGB
MapRGBA
MasksToPixelFormatEnum
PixelFormatEnumToMasks
SetPaletteColors
SetPixelFormatPalette
//-----------------------------------------------------------------------------
// Video - Rectangle Functions
EnclosePoints
HasIntersection
HasIntersection
IntersectRect
IntersectRect
IntersectRectAndLine
IntersectRectAndLine
PointInRect
PointInRect
RectEmpty
RectEmpty
RectEquals
RectEquals
UnionRect
UnionRect
//-----------------------------------------------------------------------------
// Video - Surface Creation and Simple Drawing
BlitScaled
BlitSurface
ConvertPixels
ConvertSurface
ConvertSurfaceFormat
CreateRGBSurface
CreateRGBSurfaceFrom
FillRect
FillRects
FreeSurface
GetClipRect
GetColorKey
GetSurfaceAlphaMod
GetSurfaceBlendMode
GetSurfaceColorMod
LoadBMP
LoadBMP_RW
LockSurface
LowerBlit
LowerBlitScaled
MUSTLOCK
SaveBMP
SaveBMP_RW
SetClipRect
SetColorKey
SetSurfaceAlphaMod
SetSurfaceBlendMode
SetSurfaceColorMod
SetSurfacePalette
SetSurfaceRLE
UnlockSurface
//-----------------------------------------------------------------------------
// Video - Platform-specific Window Management
GetWindowWMInfo
//-----------------------------------------------------------------------------
// Video - Clipboard Handling
GetClipboardText
HasClipboardText
SetClipboardText
//-----------------------------------------------------------------------------
// Input Events - Event Handling
AddEventWatch
DelEventWatch
EventState
FilterEvents
FlushEvent
FlushEvents
GetEventFilter
GetNumTouchDevices
GetNumTouchFingers
GetTouchDevice
GetTouchFinger
HasEvent
HasEvents
LoadDollarTemplates
PeepEvents
PollEvent
PumpEvents
PushEvent
QuitRequested
RecordGesture
RegisterEvents
SaveAllDollarTemplates
SaveDollarTemplate
SetEventFilter
WaitEvent
WaitEventTimeout
//-----------------------------------------------------------------------------
// Input Events - Keyboard Support
GetKeyFromName
GetKeyFromScancode
GetKeyName
GetKeyboardFocus
GetKeyboardState
GetModState
GetScancodeFromKey
GetScancodeFromName
GetScancodeName
HasScreenKeyboardSupport
IsScreenKeyboardShown
IsTextInputActive
SetModState
SetTextInputRect
StartTextInput
StopTextInput
//-----------------------------------------------------------------------------
// Input Events - Mouse Support
CaptureMouse
CreateColorCursor
CreateCursor
CreateSystemCursor
FreeCursor
GetCursor
GetDefaultCursor
GetGlobalMouseState
GetMouseFocus
GetMouseState
GetRelativeMouseMode
GetRelativeMouseState
SetCursor
SetRelativeMouseMode
ShowCursor
WarpMouseGlobal
WarpMouseInWindow
//-----------------------------------------------------------------------------
// Input Events - Joystick Support
JoystickClose
JoystickEventState
JoystickGetAttached
JoystickGetAxis
JoystickGetBall
JoystickGetButton
JoystickGetDeviceGUID
JoystickGetGUID
JoystickGetGUIDFromString
JoystickGetGUIDString
JoystickGetHat
JoystickInstanceID
JoystickName
JoystickNameForIndex
JoystickNumAxes
JoystickNumBalls
JoystickNumButtons
JoystickNumHats
JoystickOpen
JoystickUpdate
NumJoysticks
//-----------------------------------------------------------------------------
// Input Events - Game Controller Support
GameControllerAddMapping
GameControllerAddMappingsFromFile
GameControllerAddMappingsFromRW
GameControllerClose
GameControllerEventState
GameControllerGetAttached
GameControllerGetAxis
GameControllerGetAxisFromString
GameControllerGetBindForAxis
GameControllerGetBindForButton
GameControllerGetButton
GameControllerGetButtonFromString
GameControllerGetJoystick
GameControllerGetStringForAxis
GameControllerGetStringForButton
GameControllerMapping
GameControllerMappingForGUID
GameControllerName
GameControllerNameForIndex
GameControllerOpen
GameControllerUpdate
IsGameController
//-----------------------------------------------------------------------------
// Force Feedback - Force Feedback Support
HapticClose
HapticDestroyEffect
HapticEffectSupported
HapticGetEffectStatus
HapticIndex
HapticName
HapticNewEffect
HapticNumAxes
HapticNumEffects
HapticNumEffectsPlaying
HapticOpen
HapticOpenFromJoystick
HapticOpenFromMouse
HapticOpend
HapticPause
HapticQuery
HapticRumbleInit
HapticRumblePlay
HapticRumbleStop
HapticRumbleSupported
HapticRunEffect
HapticSetAutocenter
HapticSetGain
HapticStopAll
HapticStopEffect
HapticUnpause
HapticUpdateEffect
JoystickIsHaptic
MouseIsHaptic
NumHaptics
//-----------------------------------------------------------------------------
// Audio - Audio Device Management, Playing and Recording
AudioInit
AudioQuit
BuildAudioCVT
ClearQueuedAudio
CloseAudio
CloseAudioDevice
AudioCVT#ConvertAudio
FreeWAV
GetAudioDeviceName
GetAudioDeviceStatus
GetAudioDriver
GetAudioStatus
GetCurrentAudioDriver
GetNumAudioDevices
GetNumAudioDrivers
GetQueuedAudioSize
LoadWAV
LoadWAV_RW
LockAudio
LockAudioDevice
MixAudio
MixAudioFormat
OpenAudio
OpenAudioDevice
PauseAudio
PauseAudioDevice
QueueAudio
UnlockAudio
UnlockAudioDevice
//-----------------------------------------------------------------------------
// Threads - Thread Management
CreateThread
DetachThread
GetThreadID
GetThreadName
GetThreadPriority
TLSCreate
TLSGet
TLSSet
ThreadID
WaitThread
//-----------------------------------------------------------------------------
// Threads - Thread Synchronization Primitives
CondBroadcast
CondSignal
CondWait
CondWaitTimeout
CreateCond
CreateMutex
CreateSemaphore
DestroyCond
DestroyMutex
DestroySemaphore
LockMutex
SemPost
SemTryWait
SemValue
SemWait
SemWaitTimeout
TryLockMutex
UnlockMutex
//-----------------------------------------------------------------------------
// Threads - Atomic Operations
AtomicAdd
AtomicCAS
AtomicCASPtr
AtomicDecRef
AtomicGet
AtomicGetPtr
AtomicIncRef
AtomicLock
AtomicSet
AtomicSetPtr
AtomicTryLock
AtomicUnlock
CompilerBarrier
//-----------------------------------------------------------------------------
// Timers - Timer Support
AddTimer
Delay
GetPerformanceCounter
GetPerformanceFrequency
GetTicks
RemoveTimer
TICKS_PASSED
//-----------------------------------------------------------------------------
// File Abstraction - Filesystem Paths
GetBasePath
GetPrefPath
//-----------------------------------------------------------------------------
// File Abstraction - File I/O Abstraction
AllocRW
FreeRW
RWFromConstMem
RWFromFP
RWFromFile
RWFromMem
RWclose
RWread
RWseek
RWtell
RWwrite
ReadBE16
ReadBE32
ReadBE64
ReadLE16
ReadLE32
ReadLE64
WriteBE16
WriteBE32
WriteBE64
WriteLE16
WriteLE32
WriteLE64
//-----------------------------------------------------------------------------
// Shared Object Support - Shared Object Loading and Function Lookup
//-----------------------------------------------------------------------------
// Platform and CPU Information - Platform Detection
//-----------------------------------------------------------------------------
// Platform and CPU Information - CPU Feature Detection
//-----------------------------------------------------------------------------
// Platform and CPU Information - Byte Order and Byte Swapping
//-----------------------------------------------------------------------------
// Platform and CPU Information - Bit Manipulation
//-----------------------------------------------------------------------------
// Power Management - Power Management Status
//-----------------------------------------------------------------------------
// Additional - Platform-specific functionality
//-----------------------------------------------------------------------------
// Additional - Other

'''

tmplImplementation = R'''
// sdl2.${funcName}(${if (args) {(args:*name + ':' + args:*typeGura).join(', ')}})
Gura_DeclareFunction(${funcName})
{
	SetMode(RSLTMODE_Normal, FLAG_None);
	${if (args)}
	${for (arg in args)}
	DeclareArgs(env, "${arg.name}", VTYPE_${arg.typeGura});
	${end}
	${end}
	AddHelp(Gura_Symbol(en), Help::FMT_markdown,
	"");
}

Gura_ImplementFunction(${funcName})
{
	${if (args)}
	${for (arg in args) {|idx|}}
	${arg.typeC.sub(r'(\w)$', r'\1 ') + arg.name} = ${arg.GetArg(idx)};
	${end}
	${argsJoined = args:*name.join(', '), -}
	${if (!rtnInfo)}
	::SDL_${funcName}(${argsJoined});
	return Value::Null;
	${elsif (rtnInfo.typeC == 'error')}
	int rtn = ::SDL_${funcName}(${argsJoined});
	if (rtn < 0) {
		// errror handling
	}
	return Value::Null;
	${else}
	${rtnInfo.typeC.sub(r'(\w)$', r'\1 ')}rtn = ::SDL_${funcName}(${argsJoined});
	return ${rtnInfo.fmtReturn};
	${end}
	${else}
	//::SDL_${funcName}();
	SetError_NotImpFunction(sig, "${funcName}");
	return Value::Null;
	${end}
}
'''.template()

tmplAssignment = R'''
	Gura_AssignFunction(${funcName});
'''.template()

ArgInfo = struct(name:string, typeC:string, typeGura:string, fmtGetter:string) {
	GetArg(idx:number) = format(this.fmtGetter, idx)
}

ReturnInfo = struct(typeC:string, typeGura:string:nil, fmtReturn:string:nil) {
	
}

TypeConv = struct(typeGura:string, fmtGetter:string, fmtReturn:string)

typeConvDict = %{
	'int' => TypeConv('number', 'args.GetInt(%d)', 'Value(rtn)')
	'Uint32' => TypeConv('number', 'args.GetULong(%d)', 'Value(rtn)')
	'char *' => TypeConv('string', 'args.GetString(%d)', 'Value(rtn)')
	'const char *' => TypeConv('string', 'args.GetString(%d)', 'Value(rtn)')
	'SDL_Window *' => TypeConv('Window', 'Class_Window::GetObject(%d)', 'Value(new Object_Window(rtn))')
}

FuncInfo = class {
	__init__(lineNo:number, funcName:string, argsRaw:string:nil, rtnRaw:string:nil) = {
		this.funcName:public = funcName
		this.argsRaw = argsRaw
		this.rtnRaw = rtnRaw
		this.args = nil
		this.rtnInfo = nil
		if (this.argsRaw) {
			this.args = this.argsRaw.split(',').each():xlist {|argRaw|
				argRaw = argRaw.strip()
				argRaw.isempty() && continue
				if (m = argRaw.match(r'^(\w+)\s+(\w+)$')) {
					[typeC, name] = m[1, 2]
				} elsif (m = argRaw.match(r'^(\w+)\s*\*\s*(\w+)$')) {
					[typeC, name] = [m[1] + ' *', m[2]]
				} elsif (m = argRaw.match(r'^const\s+(\w+)\s*\*\s*(\w+)$')) {
					[typeC, name] = ['const ' + m[1] + ' *', m[2]]
				} else {
					sys.stderr.printf('%d: invalid argument "%s"\n', lineNo, argRaw)
					sys.exit(1)
				}
				typeConv = typeConvDict.get(typeC)
				if (!typeConv) {
					sys.stderr.printf('%d: invalid argument "%s"\n', lineNo, argRaw)
					sys.exit(1)
				}
				ArgInfo(name, typeC, typeConv.typeGura, typeConv.fmtGetter)
			}
		}
		if (!this.rtnRaw) {
			// nothing to do
		} elsif (this.rtnRaw == 'error') {
			this.rtnInfo = ReturnInfo('error', nil, nil)
		} else {
			if (m = rtnRaw.match(r'^(\w+)$')) {
				typeC = m[1]
			} elsif (m = rtnRaw.match(r'^(\w+)\s*\*\s*$')) {
				typeC = m[1] + ' *'
			} elsif (m = rtnRaw.match(r'^const\s+(\w+)\s*\*\s*$')) {
				typeC = 'const ' + m[1] + ' *'
			} else {
				sys.stderr.printf('%d: invalid return type "%s"\n', lineNo, rtnRaw)
				sys.exit(1)
			}
			typeConv = typeConvDict.get(typeC)
			if (!typeConv) {
				sys.stderr.printf('%d: invalid return type "%s"\n', lineNo, rtnRaw)
				sys.exit(1)
			}
			this.rtnInfo = ReturnInfo(typeC, typeConv.typeGura, typeConv.fmtReturn)
		}
	}
	RenderImplementation(stream:stream) = {
		funcName = this.funcName
		args = this.args
		rtnInfo = this.rtnInfo
		tmplImplementation.render(stream)
	}
	RenderAssignment(stream:stream) = {
		funcName = this.funcName
		args = this.args
		tmplAssignment.render(stream)
	}
}

funcInfos = []
text.eachline {|line, i|
	line = line.strip()
	(line.startswith('//') || line.isempty()) && continue
	lineNo = i + 1
	restPart = line
	fields = restPart.split(':')
	argsRaw = nil
	rtnRaw = nil
	if (fields.len() > 1) {
		[restPart, rtnRaw] = fields
	}
	if (m = restPart.match(r'(.*)\(([^\)]*)\)')) {
		[restPart, argsRaw] = m[1, 2]
	}
	if (m = restPart.match(r'^(\w+)$')) {
		funcName = m[1]
		if (funcInfos:*funcName.find(funcName)) {
			sys.stderr.printf('%d: duplicated function %s\n', lineNo, funcName)
			sys.exit(1)
		}
		funcInfos.add(FuncInfo(lineNo, funcName, argsRaw, rtnRaw))
	} else {
		sys.stderr.printf('%d: invalid format\n', lineNo)
		sys.exit(1)
	}
}

println('--------')
funcInfos.each {|funcInfo|
	funcInfo.RenderImplementation(sys.stdout)
	println()
}
println('--------')
funcInfos.each {|funcInfo|
	funcInfo.RenderAssignment(sys.stdout)
}
