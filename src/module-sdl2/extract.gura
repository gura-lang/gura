#!/usr/bin/env gura
import(re)

decls = `{
//-----------------------------------------------------------------------------
// Basics - Initialization and Shutdown

SDL_Init(flags:Uint32):negerr

SDL_InitSubSystem(flags:Uint32):negerr

SDL_Quit():void

SDL_QuitSubSystem(flags:Uint32):void

SDL_SetMainReady():void

SDL_WasInit(flags:Uint32):Uint32

//-----------------------------------------------------------------------------
// Basics - Configuration Variables

SDL_AddHintCallback$()

SDL_ClearHints$()

SDL_DelhintCallback$()

SDL_GetHint$()

SDL_SetHint$()

SDL_SetHintWithPriority$()

//-----------------------------------------------------------------------------
// Basics - Error Handling

SDL_ClearError():void

SDL_GetError():char@:const

SDL_SetError$()

//-----------------------------------------------------------------------------
// Basics - Log Handling

SDL_Log$()

SDL_LogCritical$()

SDL_LogDebug$()

SDL_LogError$()

SDL_LogGetOutputFunction$()

SDL_LogGetPriority$()

SDL_LogInfo$()

SDL_LogMessage$()

SDL_LogMessageV$()

SDL_LogResetPriorities$()

SDL_LogSetAllPriority$()

SDL_LogSetOutputFunction$()

SDL_LogSetPriority$()

SDL_LogVerbose$()

SDL_LogWarn$()

//-----------------------------------------------------------------------------
// Basics - Assertions

SDL_GetAssertionHandler$()

SDL_GetAssertionReport$()

SDL_GetDefaultAssertionHandler$()

SDL_ResetAssertionReport$()

SDL_SetAssertionHandler$()

SDL_TriggerBreakpoint$()

SDL_assert$()

SDL_assert_paranoid$()

SDL_assert_release$()

SDL_GetRevision():char@:const

SDL_GetRevisionNumber():int

//-----------------------------------------------------------------------------
// Basics - Querying SDL Version

SDL_GetVersion() = R'''
	SDL_version ver;
	SDL_GetVersion(&ver);
	return ReturnValue(env, sig, args, Value::CreateList(env,
					Value(ver.major), Value(ver.minor), Value(ver.patch)));
'''

SDL_VERSION() = R'''
	SDL_version ver;
	SDL_VERSION(&ver);
	return ReturnValue(env, sig, args, Value::CreateList(env,
					Value(ver.major), Value(ver.minor), Value(ver.patch)));
'''

SDL_VERSION_ATLEAST(X:int, Y:int, Z:int):bool

//-----------------------------------------------------------------------------
// Video - Display and Window Management

SDL_CreateWindow(title:char@:const, x:int, y:int, w:int, h:int, flags:Uint32):SDL_Window@

SDL_CreateWindowAndRenderer(width:int, height:int, window_flags:Uint32) = R'''
	SDL_Window *window = NULL;
	SDL_Renderer *renderer = NULL;
	int _rtn = SDL_CreateWindowAndRenderer(width, height, window_flags, &window, &renderer);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
			Value(new Object_Window(window)), Value(new Object_Renderer(renderer))));
'''

SDL_CreateWindowFrom$()

SDL_DestroyWindow(window:SDL_Window@):void

SDL_DisableScreenSaver():void

SDL_EnableScreenSaver():void

SDL_GL_CreateContext(window:SDL_Window@) = R'''
	SDL_GLContext _rtn = SDL_GL_CreateContext(window);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_GLContext(_rtn)));
'''

SDL_GL_DeleteContext(context:SDL_GLContext):void

SDL_GL_ExtensionSupported(extension:char@:const):SDL_bool

SDL_GL_GetAttribute(attr:SDL_GLattr) = R'''
	int value = 0;
	int _rtn = SDL_GL_GetAttribute(attr, &value);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(value));
'''

SDL_GL_GetCurrentContext() = R'''
	SDL_GLContext _rtn = SDL_GL_GetCurrentContext();
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_GLContext(_rtn)));
'''

SDL_GL_GetCurrentWindow():SDL_Window@

SDL_GL_GetDrawableSize(window:SDL_Window@) = R'''
	int w = 0;
	int h = 0;
	SDL_GL_GetDrawableSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GL_GetProcAddress$()

SDL_GL_GetSwapInterval():negerr_boolean

SDL_GL_LoadLibrary(path:char@:const):negerr

SDL_GL_MakeCurrent(window:SDL_Window@, context:SDL_GLContext):negerr

SDL_GL_ResetAttributes():void

SDL_GL_SetAttribute(attr:SDL_GLattr, value:int):negerr

SDL_GL_SetSwapInterval(interval:int):negerr

SDL_GL_SwapWindow(window:SDL_Window@):void

SDL_GL_UnloadLibrary():void

SDL_GetClosestDisplayMode(displayIndex:int, mode:SDL_DisplayMode@:const) = R'''
	SDL_DisplayMode closest;
	SDL_DisplayMode *_rtn = SDL_GetClosestDisplayMode(displayIndex, mode, &closest);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(closest)));
'''

SDL_GetCurrentDisplayMode(displayIndex:int) = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetCurrentDisplayMode(displayIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

SDL_GetCurrentVideoDriver():char@:const

SDL_GetDesktopDisplayMode(displayIndex:int) = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetDesktopDisplayMode(displayIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

SDL_GetDisplayBounds(displayIndex:int) = R'''
	SDL_Rect rect;
	int _rtn = SDL_GetDisplayBounds(displayIndex, &rect);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

SDL_GetDisplayMode(displayIndex:int, modeIndex:int) = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetDisplayMode(displayIndex, modeIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

SDL_GetDisplayName(dipslayIndex:int):char@:const

SDL_GetNumDisplayModes(displayIndex:int):negerr_number

SDL_GetNumVideoDisplays():negerr_number

SDL_GetNumVideoDrivers():negerr_number

SDL_GetVideoDriver(index:int):char@:const

SDL_GetWindowBrightness(window:SDL_Window@):float

SDL_GetWindowData$(window:SDL_Window@, name:char@:const)

SDL_GetWindowDisplayIndex(window:SDL_Window@):negerr_number

SDL_GetWindowDisplayMode(window:SDL_Window@, mode:SDL_DisplayMode@):negerr

SDL_GetWindowFlags(window:SDL_Window@):Uint32

SDL_GetWindowFromID(id:Uint32):SDL_Window@

SDL_GetWindowGammaRamp(window:SDL_Window@) = R'''
	Uint16 red = 0;
	Uint16 green = 0;
	Uint16 blue = 0;
	int _rtn = SDL_GetWindowGammaRamp(window, &red, &green, &blue);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
								Value(red), Value(green), Value(blue)));
'''

SDL_GetWindowGrab(window:SDL_Window@):SDL_bool

SDL_GetWindowID(window:SDL_Window@):Uint32

SDL_GetWindowMaximumSize(window:SDL_Window@) = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowMaximumSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GetWindowMinimumSize(window:SDL_Window@) = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowMinimumSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GetWindowPixelFormat(window:SDL_Window@) = R'''
	Uint32 _rtn = SDL_GetWindowPixelFormat(window);
	if (_rtn == SDL_PIXELFORMAT_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetWindowPosition(window:SDL_Window@) = R'''
	int x = 0;
	int y = 0;
	SDL_GetWindowPosition(window, &x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(x), Value(y)));
'''

SDL_GetWindowSize(window:SDL_Window@) = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GetWindowSurface(window:SDL_Window@):SDL_Surface@

SDL_GetWindowTitle(window:SDL_Window@):char@:const

SDL_GetWindowWMInfo$(window:SDL_Window@) = R'''
	SDL_SysWMinfo info;
	SDL_bool _rtn = SDL_GetWindowWMInfo(window, &info);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_SysWMinfo(info)));
'''

SDL_HideWindow(window:SDL_Window@):void

SDL_IsScreenSaverEnabled():SDL_bool

SDL_MaximizeWindow(window:SDL_Window@):void

SDL_MinimizeWindow(window:SDL_Window@):void

SDL_RaiseWindow(window:SDL_Window@):void

SDL_RestoreWindow(window:SDL_Window@):void

SDL_SetWindowBordered(window:SDL_Window@, bordered:SDL_bool):void

SDL_SetWindowBrightness(window:SDL_Window@, brightness:float):negerr

SDL_SetWindowData$(window:SDL_Window@, name:char@:const)

SDL_SetWindowDisplayMode(window:SDL_Window@, mode:SDL_DisplayMode@:const):negerr

SDL_SetWindowFullscreen(window:SDL_Window@, flags:Uint32):negerr

SDL_SetWindowGammaRamp(window:SDL_Window@, red[]:Uint16, green[]:Uint16, blue[]:Uint16) = R'''
	if (red.GetSize() != 256 || green.GetSize() != 256 || blue.GetSize() != 256) {
		sig.SetError(ERR_ValueError, "red, green and blue must have 256 elements");
		return Value::Null;
	}
	int _rtn = SDL_SetWindowGammaRamp(window, red, green, blue);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_SetWindowGrab(window:SDL_Window@, grabbed:SDL_bool):void

SDL_SetWindowHitTest$(window:SDL_Window@):negerr

SDL_SetWindowIcon(window:SDL_Window@, icon:SDL_Surface@):void

SDL_SetWindowMaximumSize(window:SDL_Window@, max_w:int, max_h:int):void

SDL_SetWindowMinimumSize(window:SDL_Window@, min_w:int, min_h:int):void

SDL_SetWindowPosition(window:SDL_Window@, x:int, y:int):void

SDL_SetWindowSize(window:SDL_Window@, w:int, h:int):void

SDL_SetWindowTitle(window:SDL_Window@, title:char@:const):void

SDL_ShowMessageBox$():negerr

SDL_ShowSimpleMessageBox(flags:Uint32, title:char@:const, message:char@:const, window:SDL_Window@):negerr

SDL_ShowWindow(window:SDL_Window@):void

SDL_UpdateWindowSurface(window:SDL_Window@):negerr

SDL_UpdateWindowSurfaceRects(window:SDL_Window@, rects[]:SDL_Rect) = R'''
	int numrects = static_cast<int>(rects.GetSize());
	int _rtn = SDL_UpdateWindowSurfaceRects(window, rects, numrects);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_VideoInit(driver_name:char@:const):negerr

SDL_VideoQuit():void

//-----------------------------------------------------------------------------
// Video - 2D Accelerated Rendering

SDL_CreateRenderer(window:SDL_Window@, index:int, flags:Uint32):SDL_Renderer@

SDL_CreateSoftwareRenderer(surface:SDL_Surface@):SDL_Renderer@

SDL_CreateTexture(renderer:SDL_Renderer@, format:Uint32, access:int, w:int, h:int):SDL_Texture@

SDL_CreateTextureFromSurface(renderer:SDL_Renderer@, surface:SDL_Surface@):SDL_Texture@

SDL_DestroyRenderer(renderer:SDL_Renderer@):void

SDL_DestroyTexture(texture:SDL_Texture@):void

SDL_GL_BindTexture(texture:SDL_Texture@) = R'''
	float texw = 0;
	float texh = 0;
	SDL_GL_BindTexture(texture, &texw, &texh);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(texw), Value(texh)));
'''

SDL_GL_UnbindTexture(texture:SDL_Texture@):negerr

SDL_GetNumRenderDrivers():negerr_number

SDL_GetRenderDrawBlendMode(renderer:SDL_Renderer@) = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetRenderDrawBlendMode(renderer, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

SDL_GetRenderDrawColor(renderer:SDL_Renderer@) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	Uint8 a = 0;
	int _rtn = SDL_GetRenderDrawColor(renderer, &r, &g, &b, &a);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
								Value(r), Value(g), Value(b), Value(a)));
'''

SDL_GetRenderDriverInfo(index:int) = R'''
	SDL_RendererInfo info;
	int _rtn = SDL_GetRenderDriverInfo(index, &info);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_RendererInfo(info)));
'''

SDL_GetRenderTarget(renderer:SDL_Renderer@) = R'''
	SDL_Texture *_rtn = SDL_GetRenderTarget(renderer);
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = Value(new Object_Texture(_rtn));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetRenderer(window:SDL_Window@):SDL_Renderer@

SDL_GetRendererInfo(renderer:SDL_Renderer@) = R'''
	SDL_RendererInfo info;
	int _rtn = SDL_GetRendererInfo(renderer, &info);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_RendererInfo(info)));
'''

SDL_GetRenderOutputSize(renderer:SDL_Renderer@) = R'''
	int w = 0;
	int h = 0;
	int _rtn = SDL_GetRendererOutputSize(renderer, &w, &h);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GetTextureAlphaMod(texture:SDL_Texture@) = R'''
	Uint8 alpha = 0;
	int _rtn = SDL_GetTextureAlphaMod(texture, &alpha);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(alpha));
'''

SDL_GetTextureBlendMode(texture:SDL_Texture@) = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetTextureBlendMode(texture, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

SDL_GetTextureColorMod(texture:SDL_Texture@) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	int _rtn = SDL_GetTextureColorMod(texture, &r, &g, &b);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
											Value(r), Value(g), Value(b)));
'''

SDL_LockTexture$(texture:SDL_Texture@, rect:SDL_Rect@:const):negerr

SDL_QueryTexture(texture:SDL_Texture@) = R'''
	Uint32 format = 0;
	int access = 0;
	int w = 0;
	int h = 0;
	int _rtn = SDL_QueryTexture(texture, &format, &access, &w, &h);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
							Value(format), Value(access), Value(w), Value(h)));
'''

SDL_RenderClear(renderer:SDL_Renderer@):negerr

SDL_RenderCopy(renderer:SDL_Renderer@, texture:SDL_Texture@, srcrect:SDL_Rect@:const:nil, dstrect:SDL_Rect@:const:nil):negerr

SDL_RenderCopyEx(renderer:SDL_Renderer@, texture:SDL_Texture@, srcrect:SDL_Rect@:const:nil, dstrect:SDL_Rect@:const:nil, angle:double, center:SDL_Point@:const:nil, flip:SDL_RendererFlip):negerr

SDL_RenderDrawLine(renderer:SDL_Renderer@, x1:int, y1:int, x2:int, y2:int):negerr

SDL_RenderDrawLines(renderer:SDL_Renderer@, points[]:SDL_Point) = R'''
	int count = static_cast<int>(points.GetSize());
	int _rtn = SDL_RenderDrawLines(renderer, points, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_RenderDrawPoint(renderer:SDL_Renderer@, x:int, y:int):negerr

SDL_RenderDrawPoints(renderer:SDL_Renderer@, points[]:SDL_Point) = R'''
	int count = static_cast<int>(points.GetSize());
	int _rtn = SDL_RenderDrawPoints(renderer, points, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_RenderDrawRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr

SDL_RenderDrawRects(renderer:SDL_Renderer@, rects[]:SDL_Rect) = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_RenderDrawRects(renderer, rects, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_RenderFillRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr

SDL_RenderFillRects(renderer:SDL_Renderer@, rects[]:SDL_Rect) = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_RenderFillRects(renderer, rects, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_RenderGetClipRect(renderer:SDL_Renderer@) = R'''
	SDL_Rect rect;
	SDL_RenderGetClipRect(renderer, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

SDL_RenderGetLogicalSize(renderer:SDL_Renderer@) = R'''
	int w = 0;
	int h = 0;
	SDL_RenderGetLogicalSize(renderer, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_RenderGetScale(renderer:SDL_Renderer@) = R'''
	float scaleX = 0;
	float scaleY = 0;
	SDL_RenderGetScale(renderer, &scaleX, &scaleY);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(scaleX), Value(scaleY)));
'''

SDL_RenderGetViewport(renderer:SDL_Renderer@) = R'''
	SDL_Rect rect;
	SDL_RenderGetViewport(renderer, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

SDL_RenderIsClipEnabled$(renderer:SDL_Renderer@):SDL_bool

SDL_RenderPresent(renderer:SDL_Renderer@):void

SDL_RenderReadPixels(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil, format:symbol@) = R'''
	Uint32 _format = SDL_PIXELFORMAT_UNKNOWN;
	Image::Format fmtImage = Image::FORMAT_None;
	if (format->IsIdentical(Gura_Symbol(rgb))) {
		_format = SDL_PIXELFORMAT_BGR888;
		fmtImage = Image::FORMAT_RGB;
	} else if (format->IsIdentical(Gura_Symbol(rgba))) {
		_format = SDL_PIXELFORMAT_BGRA8888;
		fmtImage = Image::FORMAT_RGBA;
	} else {
		sig.SetError(ERR_ValueError, "format must be `rgb or `rgba");
		return Value::Null;
	}
	AutoPtr<Image> pImage(new Image(fmtImage));
	if (!pImage->AllocBuffer(sig, rect->w, rect->h, 0x00)) return Value::Null;
	void *pixels = pImage->GetBuffer();
	int pitch = pImage->GetBytesPerLine();
	int _rtn = SDL_RenderReadPixels(renderer, rect, _format, pixels, pitch);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_image(env, pImage.release())));
'''

SDL_RenderSetClipRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr

SDL_RenderSetLogicalSize(renderer:SDL_Renderer@, w:int, h:int):negerr

SDL_RenderSetScale(renderer:SDL_Renderer@, scaleX:float, scaleY:float):negerr

SDL_RenderSetViewport(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr

SDL_RenderTargetSupported(renderer:SDL_Renderer@):SDL_bool

SDL_SetRenderDrawBlendMode(renderer:SDL_Renderer@, blendMode:SDL_BlendMode):void

SDL_SetRenderDrawColor(renderer:SDL_Renderer@, r:Uint8, g:Uint8, b:Uint8, a:Uint8):negerr

SDL_SetRenderTarget(renderer:SDL_Renderer@, texture:SDL_Texture@:nil):negerr

SDL_SetTextureAlphaMod(texture:SDL_Texture@, alpha:Uint8):negerr

SDL_SetTextureBlendMode(texture:SDL_Texture@, blendMode:SDL_BlendMode):negerr

SDL_SetTextureColorMod(texture:SDL_Texture@, r:Uint8, g:Uint8, b:Uint8):negerr

SDL_UnlockTexture(texture:SDL_Texture@):void

SDL_UpdateTexture$(texture:SDL_Texture@, rect:SDL_Rect@:const:nil, pitch:int):negerr

SDL_UpdateYUVTexture$()

//-----------------------------------------------------------------------------
// Video - Pixel Formats and Conversion Routines

SDL_AllocFormat(pixel_format:Uint32):SDL_PixelFormat@

SDL_AllocPalette(ncolors:int):SDL_Palette@

SDL_CalculateGammaRamp(gamma:float) = R'''
	Uint16 ramp[256];
	SDL_CalculateGammaRamp(gamma, ramp);
	return ReturnValue(env, sig, args, Value::CreateList(env, ramp, ArraySizeOf(ramp)));
'''

SDL_FreeFormat(format:SDL_PixelFormat@):void

SDL_FreePalette(palette:SDL_Palette@):void

SDL_GetPixelFormatName(format:Uint32):char@:const

SDL_GetRGB(pixel:Uint32, format:SDL_PixelFormat@:const) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	SDL_GetRGB(pixel, format, &r, &g, &b);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(r), Value(g), Value(b)));
'''

SDL_GetRGBA(pixel:Uint32, format:SDL_PixelFormat@:const) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	Uint8 a = 0;
	SDL_GetRGBA(pixel, format, &r, &g, &b, &a);
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(r), Value(g), Value(b), Value(a)));
'''

SDL_MapRGB(format:SDL_PixelFormat@:const, r:Uint8, g:Uint8, b:Uint8):Uint32

SDL_MapRGBA(format:SDL_PixelFormat@:const, r:Uint8, g:Uint8, b:Uint8, a:Uint8):Uint32

SDL_MasksToPixelFormatEnum(bpp:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32):Uint32

SDL_PixelFormatEnumToMasks(format:Uint32) = R'''
	int bpp = 0;
	Uint32 Rmask = 0;
	Uint32 Gmask = 0;
	Uint32 Bmask = 0;
	Uint32 Amask = 0;
	SDL_bool _rtn = SDL_PixelFormatEnumToMasks(format, &bpp, &Rmask, &Gmask, &Bmask, &Amask);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(bpp), Value(Rmask), Value(Gmask), Value(Bmask), Value(Amask)));
'''

SDL_SetPaletteColors(palette:SDL_Palette@, colors[]:SDL_Color, firstcolor:int, ncolors:int) = R'''
	int nmax = static_cast<int>(colors.GetSize());
	if (firstcolor + ncolors > nmax) {
		sig.SetError(ERR_IndexError, "out of range");
		return Value::Null;
	}
	int _rtn = SDL_SetPaletteColors(palette, colors, firstcolor, ncolors);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_SetPixelFormatPalette(format:SDL_PixelFormat@, palette:SDL_Palette@):negerr

//-----------------------------------------------------------------------------
// Video - Rectangle Functions

SDL_EnclosePoints(points[]:SDL_Point, clip:SDL_Rect@:const) = R'''
	int count = static_cast<int>(points.GetSize());
	SDL_Rect result;
	SDL_bool _rtn = SDL_EnclosePoints(points, count, clip, &result);
	Value _rtnVal;
	if (_rtn == SDL_TRUE) {
		_rtnVal = Value(new Object_Rect(result));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_HasIntersection(A:SDL_Rect@:const, B:SDL_Rect@:const):SDL_bool

SDL_IntersectRect(A:SDL_Rect@:const, B:SDL_Rect@:const) = R'''
	SDL_Rect result;
	SDL_bool _rtn = SDL_IntersectRect(A, B, &result);
	Value _rtnVal;
	if (_rtn == SDL_TRUE) {
		_rtnVal = Value(new Object_Rect(result));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_IntersectRectAndLine$(rect:SDL_Rect@:const, X1:int, Y1:int, X2:int, Y2:int):SDL_bool

SDL_PointInRect$(p:SDL_Point@:const, r:SDL_Rect@:const):SDL_bool

SDL_RectEmpty(r:SDL_Rect@:const):SDL_bool

SDL_RectEquals(a:SDL_Rect@:const, b:SDL_Rect@:const):SDL_bool

SDL_UnionRect(A:SDL_Rect@:const, B:SDL_Rect@:const) = R'''
	SDL_Rect result;
	SDL_UnionRect(A, B, &result);
	Value _rtnVal = Value(new Object_Rect(result));
	return ReturnValue(env, sig, args, _rtnVal);
'''

//-----------------------------------------------------------------------------
// Video - Surface Creation and Simple Drawing

SDL_BlitScaled(src:SDL_Surface@, srcrect:SDL_Rect@:const:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr

SDL_BlitSurface(src:SDL_Surface@, srcrect:SDL_Rect@:const:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr

SDL_ConvertPixels$(width:int, height:int, src_format:Uint32, dst_format:Uint32):negerr

SDL_ConvertSurface(src:SDL_Surface@, fmt:SDL_PixelFormat@:const, flags:Uint32):SDL_Surface@

SDL_ConvertSurfaceFormat(src:SDL_Surface@, pixel_format:Uint32, flags:Uint32):SDL_Surface@

SDL_CreateRGBSurface(flags:Uint32, width:int, height:int, depth:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32):SDL_Surface@

SDL_CreateRGBSurfaceFrom(pixels:binary, width:int, height:int, depth:int, pitch:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32) = R'''
	if (pixels.size() < static_cast<size_t>(height * pitch)) {
		sig.SetError(ERR_ValueError, "pixels doesn not contain enough data");
		return Value::Null;
	}
	void *_pixels = const_cast<char *>(pixels.data());
	SDL_Surface *_rtn = SDL_CreateRGBSurfaceFrom(_pixels, width, height,
								depth, pitch, Rmask, Gmask, Bmask, Amask);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Surface(_rtn)));
'''

SDL_CreateRGBSurfaceFromImage(image:image) = R'''
	Object_Surface *pObjSurface = Object_Surface::CreateSurfaceFromImage(sig, image);
	if (pObjSurface == NULL) return Value::Null;
	return ReturnValue(env, sig, args, Value(pObjSurface));
'''

SDL_FillRect(dst:SDL_Surface@, rect:SDL_Rect@:const:nil, color:Uint32):negerr

SDL_FillRects(dst:SDL_Surface@, rects[]:SDL_Rect, color:Uint32) = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_FillRects(dst, rects, count, color);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_FreeSurface(surface:SDL_Surface@):void

SDL_GetClipRect(surface:SDL_Surface@) = R'''
	SDL_Rect rect;
	SDL_GetClipRect(surface, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

SDL_GetColorKey(surface:SDL_Surface@) = R'''
	Uint32 key = 0;
	int _rtn = SDL_GetColorKey(surface, &key);
	Value _rtnVal;
	if (_rtn >= 0) {
		_rtnVal = Value(key);
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetSurfaceAlphaMod(surface:SDL_Surface@) = R'''
	Uint8 alpha = 0;
	int _rtn = SDL_GetSurfaceAlphaMod(surface, &alpha);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(alpha));
'''

SDL_GetSurfaceBlendMode(surface:SDL_Surface@) = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetSurfaceBlendMode(surface, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

SDL_GetSurfaceColorMod(surface:SDL_Surface@) = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	int _rtn = SDL_GetSurfaceColorMod(surface, &r, &g, &b);
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(r), Value(g), Value(b)));
'''

SDL_LoadBMP(src:stream) = R'''
	std::auto_ptr<SDL_RWops> _src(CreateRWopsStream(&src, &sig));
	SDL_Surface *_rtn = SDL_LoadBMP_RW(_src.get(), 0);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Surface(_rtn)));
'''

SDL_LoadBMP_RW$()

SDL_LockSurface(surface:SDL_Surface@):negerr

SDL_LowerBlit(src:SDL_Surface@, srcrect:SDL_Rect@:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr

SDL_LowerBlitScaled(src:SDL_Surface@, srcrect:SDL_Rect@:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr

SDL_MUSTLOCK(surface:SDL_Surface@):bool

SDL_SaveBMP(surface:SDL_Surface@, dst:stream) = R'''
	std::auto_ptr<SDL_RWops> context(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveBMP_RW(surface, context.get(), 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_SaveBMP_RW$()

SDL_SetClipRect(surface:SDL_Surface@, rect:SDL_Rect@:const):SDL_bool

SDL_SetColorKey(surface:SDL_Surface@, flag:int, key:Uint32):negerr

SDL_SetSurfaceAlphaMod(surface:SDL_Surface@, alpha:Uint8):negerr

SDL_SetSurfaceBlendMode(surface:SDL_Surface@, blendMode:SDL_BlendMode):negerr

SDL_SetSurfaceColorMod(surface:SDL_Surface@, r:Uint8, g:Uint8, b:Uint8):negerr

SDL_SetSurfacePalette(surface:SDL_Surface@, palette:SDL_Palette@):negerr

SDL_SetSurfaceRLE(surface:SDL_Surface@, flag:int):negerr

SDL_UnlockSurface(surface:SDL_Surface@):void

//-----------------------------------------------------------------------------
// Video - Clipboard Handling

SDL_GetClipboardText() = R'''
	char *_rtn = SDL_GetClipboardText();
	Value _rtnVal(_rtn);
	SDL_free(_rtn);
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_HasClipboardText():SDL_bool

//-----------------------------------------------------------------------------
// Input Events - Event Handling

SDL_SetClipboardText(text:char@:const):negerr

SDL_AddEventWatch$()

SDL_DelEventWatch$()

SDL_EventState(type:Uint32, state:int):Uint8

SDL_FilterEvents$()

SDL_FlushEvent(type:Uint32):void

SDL_FlushEvents(minType:Uint32, maxType:Uint32):void

SDL_GetEventFilter$()

SDL_GetNumTouchDevices():int

SDL_GetNumTouchFingers(touchId:SDL_TouchID):negerr_number

SDL_GetTouchDevice(index:int) = R'''
	SDL_TouchID _rtn = SDL_GetTouchDevice(index);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetTouchFinger(touchId:SDL_TouchID, index:int):SDL_Finger@

SDL_HasEvent(type:Uint32):SDL_bool

SDL_HasEvents(minType:Uint32, maxType:Uint32):SDL_bool

SDL_LoadDollarTemplates(touchId:SDL_TouchID, src:stream) = R'''
	std::auto_ptr<SDL_RWops> _src(CreateRWopsStream(&src, &sig));
	int _rtn = SDL_LoadDollarTemplates(touchId, _src.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_AddEvents(events[]:SDL_Event) = R'''
	int numevents = static_cast<int>(events.GetSize());
	int _rtn = SDL_PeepEvents(events, numevents, SDL_ADDEVENT, 0, 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_PeekEvents(numevents:int, minType:Uint32, maxType:Uint32) = R'''
	CArray<SDL_Event> events(numevents);
	int _rtn = SDL_PeepEvents(events, numevents, SDL_PEEKEVENT, minType, maxType);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, _rtn);
	for (int i = 0; i < _rtn; i++) {
		_valList.push_back(Value(new Object_Event(events[i])));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetEvents(numevents:int, minType:Uint32, maxType:Uint32) = R'''
	CArray<SDL_Event> events(numevents);
	int _rtn = SDL_PeepEvents(events, numevents, SDL_GETEVENT, minType, maxType);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, _rtn);
	for (int i = 0; i < _rtn; i++) {
		_valList.push_back(Value(new Object_Event(events[i])));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_PollEvent() = R'''
	SDL_Event event;
	int _rtn = SDL_PollEvent(&event);
	if (_rtn == 0) return Value::Null;
	return ReturnValue(env, sig, args, Value(new Object_Event(event)));
'''

SDL_PumpEvents():void

SDL_PushEvent(event:SDL_Event@):negerr_boolean

SDL_QuitRequested():bool

SDL_RecordGesture(touchId:SDL_TouchID):negerr_number

SDL_RegisterEvents(numevents:int) = R'''
	Uint32 _rtn = SDL_RegisterEvents(numevents);
	Value _rtnVal;
	if (_rtn != (Uint32)-1) {
		_rtnVal = Value(_rtn);
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_SaveAllDollarTemplates(dst:stream) = R'''
	std::auto_ptr<SDL_RWops> _dst(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveAllDollarTemplates(_dst.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_SaveDollarTemplate(gestureId:SDL_GestureID, dst:stream) = R'''
	std::auto_ptr<SDL_RWops> _dst(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveDollarTemplate(gestureId, _dst.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_SetEventFilter$()

SDL_WaitEvent() = R'''
	SDL_Event event;
	int _rtn = SDL_WaitEvent(&event);
	if (_rtn == 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Event(event)));
'''

SDL_WaitEventTimeout(timeout:int) = R'''
	SDL_Event event;
	int _rtn = SDL_WaitEventTimeout(&event, timeout);
	Value _rtnVal;
	if (_rtn > 0) {
		_rtnVal = Value(new Object_Event(event));
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

//-----------------------------------------------------------------------------
// Input Events - Keyboard Support

SDL_CheckKeyboardState(scancode:SDL_Scancode) = R'''
	int numkeys = 0;
	const Uint8 *_keystate = SDL_GetKeyboardState(&numkeys);
	bool _rtn = (0 <= scancode && scancode < numkeys && _keystate[scancode] != 0);
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetKeyFromName(name:char@:const) = R'''
	SDL_Keycode _rtn = SDL_GetKeyFromName(name);
	if (_rtn == SDLK_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetKeyFromScancode(scancode:SDL_Scancode):SDL_Keycode

SDL_GetKeyName(key:SDL_Keycode):char@:const

SDL_GetKeyboardFocus():SDL_Window@

SDL_GetKeyboardState() = R'''
	int numkeys = 0;
	const Uint8 *_keystate = SDL_GetKeyboardState(&numkeys);
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, numkeys);
	for (int i = 0; i < numkeys; i++) {
		_valList.push_back(Value(_keystate[i] != 0));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetModState():SDL_Keymod

SDL_GetScancodeFromKey(key:SDL_Keycode):SDL_Scancode

SDL_GetScancodeFromName(name:char@:const) = R'''
	SDL_Scancode _rtn = SDL_GetScancodeFromName(name);
	if (_rtn == SDL_SCANCODE_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetScancodeName(scancode:SDL_Scancode):char@:const

SDL_HasScreenKeyboardSupport():SDL_bool

SDL_IsScreenKeyboardShown(window:SDL_Window@):SDL_bool

SDL_IsTextInputActive():SDL_bool

SDL_SetModState(modstate:SDL_Keymod):void

SDL_SetTextInputRect(rect:SDL_Rect@):void

SDL_StartTextInput():void

SDL_StopTextInput():void

//-----------------------------------------------------------------------------
// Input Events - Mouse Support

SDL_CaptureMouse$(enalbed:SDL_bool):negerr

SDL_CreateColorCursor(surface:SDL_Surface@, hot_x:int, hot_y:int):SDL_Cursor@

SDL_CreateCursor(data:binary, mask:binary, w:int, h:int, hot_x:int, hot_y:int) = R'''
	size_t bytesLeast = int((w + 7) / 8) * h;
	if (data.size() < bytesLeast) {
		sig.SetError(ERR_ValueError, "data has insufficient content");
		return Value::Null;
	}
	if (mask.size() < bytesLeast) {
		sig.SetError(ERR_ValueError, "mask has insufficient content");
		return Value::Null;
	}
	const Uint8 *_data = reinterpret_cast<const Uint8 *>(data.data());
	const Uint8 *_mask = reinterpret_cast<const Uint8 *>(mask.data());
	SDL_Cursor *_rtn = SDL_CreateCursor(_data, _mask, w, h, hot_x, hot_y);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Cursor(_rtn, true)));
'''

SDL_CreateSystemCursor(id:SDL_SystemCursor):SDL_Cursor@

SDL_FreeCursor(cursor:SDL_Cursor@):void

SDL_GetCursor() = R'''
	SDL_Cursor *_rtn = SDL_GetCursor();
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = Value(new Object_Cursor(_rtn, false));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetDefaultCursor():SDL_Cursor@

SDL_GetGlobalMouseState$() = R'''
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetGlobalMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
'''

SDL_GetMouseFocus():SDL_Window@

SDL_GetMouseState() = R'''
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
'''

SDL_GetRelativeMouseMode():SDL_bool

SDL_GetRelativeMouseState() = R'''
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetRelativeMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
'''

SDL_SetCursor(cursor:SDL_Cursor@):void

SDL_SetRelativeMouseMode(enabled:SDL_bool):negerr

SDL_ShowCursor(toggle:int):negerr

SDL_WarpMouseGlobal$(x:int, y:int)

SDL_WarpMouseInWindow(window:SDL_Window@, x:int, y:int):void

//-----------------------------------------------------------------------------
// Input Events - Joystick Support

SDL_JoystickClose(joystick:SDL_Joystick@):void

SDL_JoystickEventState(state:int):negerr_boolean

SDL_JoystickGetAttached(joystick:SDL_Joystick@):SDL_bool

SDL_JoystickGetAxis(joystick:SDL_Joystick@, axis:int):Sint16

SDL_JoystickGetBall(joystick:SDL_Joystick@, ball:int) = R'''
	int dx = 0;
	int dy = 0;
	int _rtn = SDL_JoystickGetBall(joystick, ball, &dx, &dy);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(dx), Value(dy)));
'''

SDL_JoystickGetButton(joystick:SDL_Joystick@, button:int) = R'''
	Uint8 _rtn = SDL_JoystickGetButton(joystick, button);
	return ReturnValue(env, sig, args, Value(_rtn != 0));
'''

SDL_JoystickGetDeviceGUID(device_index:int):SDL_JoystickGUID

SDL_JoystickGetGUID(joystick:SDL_Joystick@):SDL_JoystickGUID

SDL_JoystickGetGUIDFromString(pchGUID:char@:const):SDL_JoystickGUID

SDL_JoystickGetGUIDString(guid:SDL_JoystickGUID) = R'''
	char szGUID[64];
	int cbGUID = sizeof(szGUID);
	SDL_JoystickGetGUIDString(guid, szGUID, cbGUID);
	return ReturnValue(env, sig, args, Value(szGUID));
'''

SDL_JoystickGetHat(joystick:SDL_Joystick@, hat:int):Uint8

SDL_JoystickInstanceID(joystick:SDL_Joystick@) = R'''
	SDL_JoystickID _rtn = SDL_JoystickInstanceID(joystick);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_JoystickName(joystick:SDL_Joystick@):char@:const

SDL_JoystickNameForIndex(device_index:int):char@:const

SDL_JoystickNumAxes(joystick:SDL_Joystick@):negerr_number

SDL_JoystickNumBalls(joystick:SDL_Joystick@):negerr_number

SDL_JoystickNumButtons(joystick:SDL_Joystick@):negerr_number

SDL_JoystickNumHats(joystick:SDL_Joystick@):negerr_number

SDL_JoystickOpen(device_index:int):SDL_Joystick@

SDL_JoystickUpdate():void

SDL_NumJoysticks():negerr_number

//-----------------------------------------------------------------------------
// Input Events - Game Controller Support

SDL_GameControllerAddMapping(mappingString:char@:const):negerr_boolean

SDL_GameControllerAddMappingsFromFile(file:stream) = R'''
	std::auto_ptr<SDL_RWops> _file(CreateRWopsStream(&file, &sig));
	int _rtn = SDL_GameControllerAddMappingsFromRW(_file.get(), 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GameControllerAddMappingsFromRW$()

SDL_GameControllerClose(gamecontroller:SDL_GameController@):void

SDL_GameControllerEventState(state:int):int

SDL_GameControllerGetAttached(gamecontroller:SDL_GameController@):SDL_bool

SDL_GameControllerGetAxis(gamecontroller:SDL_GameController@, axis:SDL_GameControllerAxis):Sint16

SDL_GameControllerGetAxisFromString(pchString:char@:const):SDL_GameControllerAxis

SDL_GameControllerGetBindForAxis(gamecontroller:SDL_GameController@, axis:SDL_GameControllerAxis):SDL_GameControllerButtonBind

SDL_GameControllerGetBindForButton(gamecontroller:SDL_GameController@, button:SDL_GameControllerButton):SDL_GameControllerButtonBind

SDL_GameControllerGetButton(gamecontroller:SDL_GameController@, button:SDL_GameControllerButton) = R'''
	Uint8 _rtn = SDL_GameControllerGetButton(gamecontroller, button);
	if (_rtn == 0 && *SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn != 0));
'''

SDL_GameControllerGetButtonFromString(pchString:char@:const):SDL_GameControllerButton

SDL_GameControllerGetJoystick(gamecontroller:SDL_GameController@):SDL_Joystick@

SDL_GameControllerGetStringForAxis(axis:SDL_GameControllerAxis):char@:const

SDL_GameControllerGetStringForButton(button:SDL_GameControllerButton):char@:const

SDL_GameControllerMapping(gamecontroller:SDL_GameController@):char@:const

SDL_GameControllerMappingForGUID(guid:SDL_JoystickGUID):char@:const

SDL_GameControllerName(gamecontroller:SDL_GameController@):char@:const

SDL_GameControllerNameForIndex(joystick_index:int):char@:const

SDL_GameControllerOpen(joystick_index:int):SDL_GameController@

SDL_GameControllerUpdate():void

SDL_IsGameController(joystick_index:int):SDL_bool

//-----------------------------------------------------------------------------
// Force Feedback - Force Feedback Support

SDL_HapticClose(haptic:SDL_Haptic@):void

SDL_HapticDestroyEffect(haptic:SDL_Haptic@, effect:int):void

SDL_HapticEffectSupported(haptic:SDL_Haptic@, effect:SDL_HapticEffect@):negerr_boolean

SDL_HapticGetEffectStatus(haptic:SDL_Haptic@, effect:int):negerr_boolean

SDL_HapticIndex(haptic:SDL_Haptic@):negerr_number

SDL_HapticName(device_index:int):char@:const

SDL_HapticNewEffect(haptic:SDL_Haptic@, effect:SDL_HapticEffect@):negerr_number

SDL_HapticNumAxes(haptic:SDL_Haptic@):negerr_number

SDL_HapticNumEffects(haptic:SDL_Haptic@):negerr_number

SDL_HapticNumEffectsPlaying(haptic:SDL_Haptic@):negerr_number

SDL_HapticOpen(device_index:int):SDL_Haptic@

SDL_HapticOpenFromJoystick(joystick:SDL_Joystick@):SDL_Haptic@

SDL_HapticOpenFromMouse():SDL_Haptic@

SDL_HapticOpened(device_index:int):negerr_boolean

SDL_HapticPause(haptic:SDL_Haptic@):negerr

SDL_HapticQuery(haptic:SDL_Haptic@):unsigned_int

SDL_HapticRumbleInit(haptic:SDL_Haptic@):negerr

SDL_HapticRumblePlay(haptic:SDL_Haptic@, strength:float, length:Uint32):negerr

SDL_HapticRumbleStop(haptic:SDL_Haptic@):negerr

SDL_HapticRumbleSupported(haptic:SDL_Haptic@):negerr_boolean

SDL_HapticRunEffect(haptic:SDL_Haptic@, effect:int, iterations:Uint32):negerr

SDL_HapticSetAutocenter(haptic:SDL_Haptic@, autocenter:int):negerr

SDL_HapticSetGain(haptic:SDL_Haptic@, gain:int):negerr

SDL_HapticStopAll(haptic:SDL_Haptic@):negerr

SDL_HapticStopEffect(haptic:SDL_Haptic@, effect:int):negerr

SDL_HapticUnpause(haptic:SDL_Haptic@):negerr

SDL_HapticUpdateEffect(haptic:SDL_Haptic@, effect:int, data:SDL_HapticEffect@):negerr

SDL_JoystickIsHaptic(joystick:SDL_Joystick@):negerr_boolean

SDL_MouseIsHaptic():negerr_boolean

SDL_NumHaptics():negerr_number

//-----------------------------------------------------------------------------
// Audio - Audio Device Management, Playing and Recording

SDL_AudioInit(driver_name:char@:const):negerr

SDL_AudioQuit():void

SDL_BuildAudioCVT(cvt:SDL_AudioCVT@, src_format:SDL_AudioFormat, src_channels:Uint8, src_rate:int, dst_format:SDL_AudioFormat, dst_channels:Uint8, dst_rate:int):negerr_boolean

SDL_ClearQueuedAudio$(dev:SDL_AudioDeviceID)

SDL_CloseAudio():void

SDL_CloseAudioDevice(dev:SDL_AudioDeviceID):void

SDL_ConvertAudio(cvt:SDL_AudioCVT@):negerr

SDL_FreeWAV(wav:Wav@) = R'''
	Object_Wav *pObj = Object_Wav::GetObject(args, 0);
	Uint8 *buffer = pObj->GetBuffer();
	SDL_FreeWAV(buffer);
	return Value::Null;
'''

SDL_GetAudioDeviceName(index:int, iscapture:int):char@:const

SDL_GetAudioDeviceStatus(dev:SDL_AudioDeviceID):SDL_AudioStatus

SDL_GetAudioDriver(index:int):char@:const

SDL_GetAudioStatus():SDL_AudioStatus

SDL_GetCurrentAudioDriver():char@:const

SDL_GetNumAudioDevices(iscapture:int):negerr_number

SDL_GetNumAudioDrivers():int

SDL_GetQueuedAudioSize$(dev:SDL_AudioDeviceID):Uint32

SDL_LoadWAV(file:stream) = R'''
	std::auto_ptr<SDL_RWops> _file(CreateRWopsStream(&file, &sig));
	SDL_AudioSpec spec;
	Uint8 *audio_buf = NULL;
	Uint32 audio_len = 0;
	SDL_AudioSpec *_rtn = SDL_LoadWAV_RW(_file.get(), 0, &spec, &audio_buf, &audio_len);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Wav(spec, audio_buf, audio_len)));
'''

SDL_LoadWAV_RW$()

SDL_LockAudio():void

SDL_LockAudioDevice(dev:SDL_AudioDeviceID):void

SDL_MixAudio$(volume:int)

SDL_MixAudioFormat$(format:SDL_AudioFormat, volume:int)

SDL_OpenAudio(desired:SDL_AudioSpec@) = R'''
	SDL_AudioSpec obtained;
	int _rtn = SDL_OpenAudio(desired, &obtained);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_AudioSpec(obtained)));
'''

SDL_OpenAudioDevice$(device:char@:const, iscapture:int, desired:SDL_AudioSpec@:const, allowed_changes:int):SDL_AudioDeviceID

SDL_PauseAudio(pause_on:int):void

SDL_PauseAudioDevice(dev:SDL_AudioDeviceID, pause_on:int):void

SDL_QueueAudio$(dev:SDL_AudioDeviceID):negerr

SDL_UnlockAudio():void

SDL_UnlockAudioDevice(dev:SDL_AudioDeviceID):void

SDL_AUDIO_BITSIZE(x:Uint16):Uint16

SDL_AUDIO_ISFLOAT(x:Uint16):Uint16_boolean

SDL_AUDIO_ISBIGENDIAN(x:Uint16):Uint16_boolean

SDL_AUDIO_ISSIGNED(x:Uint16):Uint16_boolean

SDL_AUDIO_ISINT(x:Uint16):bool

SDL_AUDIO_ISLITTLEENDIAN(x:Uint16):bool

SDL_AUDIO_ISUNSIGNED(x:Uint16):bool

//-----------------------------------------------------------------------------
// Threads - Thread Management

SDL_CreateThread$()

SDL_DetachThread$()

SDL_GetThreadID$()

SDL_GetThreadName$()

SDL_GetThreadPriority$()

SDL_TLSCreate$()

SDL_TLSGet$()

SDL_TLSSet$()

SDL_ThreadID$()

SDL_WaitThread$()

//-----------------------------------------------------------------------------
// Threads - Thread Synchronization Primitives

SDL_CondBroadcast$()

SDL_CondSignal$()

SDL_CondWait$()

SDL_CondWaitTimeout$()

SDL_CreateCond$()

SDL_CreateMutex$()

SDL_CreateSemaphore$()

SDL_DestroyCond$()

SDL_DestroyMutex$()

SDL_DestroySemaphore$()

SDL_LockMutex$()

SDL_SemPost$()

SDL_SemTryWait$()

SDL_SemValue$()

SDL_SemWait$()

SDL_SemWaitTimeout$()

SDL_TryLockMutex$()

SDL_UnlockMutex$()

//-----------------------------------------------------------------------------
// Threads - Atomic Operations

SDL_AtomicAdd$()

SDL_AtomicCAS$()

SDL_AtomicCASPtr$()

SDL_AtomicDecRef$()

SDL_AtomicGet$()

SDL_AtomicGetPtr$()

SDL_AtomicIncRef$()

SDL_AtomicLock$()

SDL_AtomicSet$()

SDL_AtomicSetPtr$()

SDL_AtomicTryLock$()

SDL_AtomicUnlock$()

SDL_CompilerBarrier$()

//-----------------------------------------------------------------------------
// Timers - Timer Support

SDL_AddTimer$(interval:Uint32):SDL_TimerID

SDL_Delay(ms:Uint32):void

SDL_GetPerformanceCounter():Uint64

SDL_GetPerformanceFrequency():Uint64

SDL_GetTicks():Uint32

SDL_RemoveTimer(id:SDL_TimerID):SDL_bool

SDL_TICKS_PASSED(A:Uint32, B:Uint32):bool

//-----------------------------------------------------------------------------
// File Abstraction - Filesystem Paths

SDL_GetBasePath$():char@

SDL_GetPrefPath$(org:char@:const, app:char@:const):char@

//-----------------------------------------------------------------------------
// File Abstraction - File I/O Abstraction

SDL_AllocRW$()

SDL_FreeRW$()

SDL_RWFromConstMem$()

SDL_RWFromFP$()

SDL_RWFromFile$()

SDL_RWFromMem$()

SDL_RWclose$()

SDL_RWread$()

SDL_RWseek$()

SDL_RWtell$()

SDL_RWwrite$()

SDL_ReadBE16$()

SDL_ReadBE32$()

SDL_ReadBE64$()

SDL_ReadLE16$()

SDL_ReadLE32$()

SDL_ReadLE64$()

SDL_WriteBE16$()

SDL_WriteBE32$()

SDL_WriteBE64$()

SDL_WriteLE16$()

SDL_WriteLE32$()

SDL_WriteLE64$()

//-----------------------------------------------------------------------------
// Shared Object Support - Shared Object Loading and Function Lookup

//-----------------------------------------------------------------------------
// Platform and CPU Information - Platform Detection

SDL_GetPlatform():char@:const

//-----------------------------------------------------------------------------
// Platform and CPU Information - CPU Feature Detection

SDL_GetCPUCacheLineSize():int

SDL_GetCPUCount():int

SDL_GetSystemRAM():int

SDL_Has3DNow():SDL_bool

SDL_HasAVX():SDL_bool

SDL_HasAVX2$():SDL_bool

SDL_HasAltiVec():SDL_bool

SDL_HasMMX():SDL_bool

SDL_HasRDTSC():SDL_bool

SDL_HasSSE():SDL_bool

SDL_HasSSE2():SDL_bool

SDL_HasSSE3():SDL_bool

SDL_HasSSE41():SDL_bool

SDL_HasSSE42():SDL_bool

//-----------------------------------------------------------------------------
// Platform and CPU Information - Byte Order and Byte Swapping

SDL_Swap16$()

SDL_Swap32$()

SDL_Swap64$()

SDL_SwapBE16$()

SDL_SwapBE32$()

SDL_SwapBE64$()

SDL_SwapFloat$()

SDL_SwapFloatBE$()

SDL_SwapFloatLE$()

SDL_SwapLE16$()

SDL_SwapLE32$()

SDL_SwapLE64$()

//-----------------------------------------------------------------------------
// Platform and CPU Information - Bit Manipulation

SDL_MostSignificantBitIndex32$(x:Uint32):int

//-----------------------------------------------------------------------------
// Power Management - Power Management Status

SDL_GetPowerInfo() = R'''
	int secs = 0;
	int pct = 0;
	SDL_PowerState _rtn = SDL_GetPowerInfo(&secs, &pct);
	return ReturnValue(env, sig, args, Value::CreateList(env,
									Value(_rtn), Value(secs), Value(pct)));
'''

//-----------------------------------------------------------------------------
// Additional - Platform-specific functionality

SDL_AndroidGetActivity$()

SDL_AndroidGetExternalStoragePath$()

SDL_AndroidGetExternalStorageState$()

SDL_AndroidGetInternalStoragePath$()

SDL_AndroidGetJNIEnv$()

//-----------------------------------------------------------------------------
// Additional - Other

SDL_acos(x:double):double
}

import(modimp) {TypeConv, Renderer}

TypeConv_Enum(typeName:string) = {
	typeName => TypeConv(
			'number', 'Once', [],
			typeName,
			'static_cast<' + typeName + '>(args.GetInt(%d))',
			'Value(_rtn)')
}

TypeConv_Class(typeName:string) = {
	fields = typeName.split(':'):list
	if (fields.len() > 1) {
		[typeNameTmp, attr] = fields
		constFlag = (attr == 'const')
	} else {
		typeNameTmp = fields[0]
		constFlag = false
	}
	pointerFlag = typeNameTmp.find('@')
	typeNameTmp = typeNameTmp.replace('@', '')
	typeNameBase = typeNameTmp.replace('SDL_', '')
	typeName => TypeConv(
			typeNameBase, 'Once', [],
			cond(constFlag, 'const ', '') + typeNameTmp + cond(pointerFlag, ' *', ''),
			'Object_' + typeNameBase + '::GetObject(args, %d)->GetEntity()',
			'Value(new Object_' + typeNameBase + '(_rtn))',
			cond(pointerFlag, bodyPrePointer))
}

bodyPrePointer = R'''
	if (_rtn == NULL) {
		if (*SDL_GetError() != '\0') {
			SetError_SDL(sig);
			return Value::Null;
		}
		return ReturnValue(env, sig, args, Value::Null);
	}
'''

typeConvDict = %{
	// overwrite built-in converter
	'char@' => TypeConv(
			'string', 'Once', [],
			'char *', 'args.GetString(%d)',
			'Value(_rtn)', bodyPrePointer)
	'char@:const' => TypeConv(
			'string', 'Once', [],
			'const char *', 'args.GetString(%d)',
			'Value(_rtn)', bodyPrePointer)
	// type converter specific to SDL library
	'Uint16[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<Uint16>', 'args.GetList(%d)',
			nil)
	'Sint8' => TypeConv(
			'number', 'Once', [],
			'Sint8', 'args.GetChar(%d)',
			'Value(_rtn)')
	'Sint16' => TypeConv(
			'number', 'Once', [],
			'Sint16', 'args.GetShort(%d)',
			'Value(_rtn)')
	'Sint32' => TypeConv(
			'number', 'Once', [],
			'Sint32', 'args.GetLong(%d)',
			'Value(_rtn)')
	'Sint64' => TypeConv(
			'number', 'Once', [],
			'Sint64', 'static_cast<Sint64>(args.GetDouble(%d))',
			'Value(_rtn)')
	'Uint8' => TypeConv(
			'number', 'Once', [],
			'Uint8', 'args.GetUChar(%d)',
			'Value(_rtn)')
	'Uint16' => TypeConv(
			'number', 'Once', [],
			'Uint16', 'args.GetUShort(%d)',
			'Value(_rtn)')
	'Uint32' => TypeConv(
			'number', 'Once', [],
			'Uint32', 'args.GetULong(%d)',
			'Value(_rtn)')
	'Uint64' => TypeConv(
			'number', 'Once', [],
			'Uint64', 'static_cast<Uint64>(args.GetDouble(%d))',
			'Value(_rtn)')
	'Wav@' => TypeConv(
			'Wav', 'Once', [],
			'Object_Wav *', 'Object_Wav::GetObject(args, %d)',
			nil, bodyPrePointer)
	'SDL_bool' => TypeConv(
			'boolean', 'Once', [],
			'SDL_bool', '(args.GetBoolean(%d)? SDL_TRUE : SDL_FALSE)',
			'Value(_rtn != SDL_FALSE)')
	'SDL_Color[]' => TypeConv(
			'Color', 'Once', ['List'],
			'CArray<SDL_Color>',
			'CreateCArray<SDL_Color, Object_Color>(args.GetList(%d))',
			nil)
	'SDL_Event[]' => TypeConv(
			'Event', 'Once', ['List'],
			'CArray<SDL_Event>',
			'CreateCArray<SDL_Event, Object_Event>(args.GetList(%d))',
			nil)
	'SDL_Point[]' => TypeConv(
			'Point', 'Once', ['List'],
			'CArray<SDL_Point>',
			'CreateCArray<SDL_Point, Object_Point>(args.GetList(%d))',
			nil)
	'SDL_Rect[]' => TypeConv(
			'Rect', 'Once', ['List'],
			'CArray<SDL_Rect>',
			'CreateCArray<SDL_Rect, Object_Rect>(args.GetList(%d))',
			nil)
	'negerr' => TypeConv(
			nil, nil, [],
			'int', nil,
			nil, R'''
				if (_rtn < 0) {
					SetError_SDL(sig);
					return Value::Null;
				}
			''')
	'negerr_boolean' => TypeConv(
			nil, nil, [],
			'int', nil,
			'Value(_rtn != 0)', R'''
				if (_rtn < 0) {
					SetError_SDL(sig);
					return Value::Null;
				}
			''')
	'negerr_number' => TypeConv(
			nil, nil, [],
			'int', nil,
			'Value(_rtn)', R'''
				if (_rtn < 0) {
					SetError_SDL(sig);
					return Value::Null;
				}
			''')
	'Uint16_boolean' => TypeConv(
			nil, nil, [],
			'Uint16', nil,
			'Value(_rtn != 0)')
	TypeConv_Enum('SDL_AudioFormat')
	TypeConv_Enum('SDL_AudioDeviceID')
	TypeConv_Enum('SDL_AudioStatus')
	TypeConv_Enum('SDL_BlendMode')
	TypeConv_Enum('SDL_GameControllerAxis')
	TypeConv_Enum('SDL_GameControllerButton')
	TypeConv_Enum('SDL_GestureID')
	TypeConv_Enum('SDL_GLattr')
	TypeConv_Enum('SDL_Keycode')
	TypeConv_Enum('SDL_Keymod')
	TypeConv_Enum('SDL_RendererFlip')
	TypeConv_Enum('SDL_Scancode')
	TypeConv_Enum('SDL_SystemCursor')
	TypeConv_Enum('SDL_TimerID')
	TypeConv_Enum('SDL_TouchID')
	TypeConv_Class('SDL_AudioCVT@')
	TypeConv_Class('SDL_AudioSpec@')
	TypeConv_Class('SDL_AudioSpec@:const')
	'SDL_Cursor@' => TypeConv(
			'Cursor', 'Once', [],
			'SDL_Cursor *', 'Object_Cursor::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Cursor(_rtn, true))', bodyPrePointer)
	TypeConv_Class('SDL_DisplayMode@')
	TypeConv_Class('SDL_DisplayMode@:const')
	TypeConv_Class('SDL_Event@')
	TypeConv_Class('SDL_Event@:const')
	TypeConv_Class('SDL_Finger@')
	TypeConv_Class('SDL_GameController@')
	TypeConv_Class('SDL_GameControllerButtonBind')
	TypeConv_Class('SDL_GLContext')
	TypeConv_Class('SDL_Haptic@')
	TypeConv_Class('SDL_HapticEffect@')
	TypeConv_Class('SDL_Joystick@')
	TypeConv_Class('SDL_JoystickGUID')
	TypeConv_Class('SDL_Palette@')
	TypeConv_Class('SDL_PixelFormat@')
	TypeConv_Class('SDL_PixelFormat@:const')
	TypeConv_Class('SDL_Point@:const')
	TypeConv_Class('SDL_Rect@')
	TypeConv_Class('SDL_Rect@:const')
	TypeConv_Class('SDL_Renderer@')
	TypeConv_Class('SDL_Surface@')
	TypeConv_Class('SDL_Texture@')
	TypeConv_Class('SDL_Window@')
}

Renderer('sdl2', decls.children, typeConvDict, &{$funcNameC.sub('^SDL_', '')}) {|renderer|
	if (sys.argv.len() > 1 && sys.argv[1] == 'test') {
		print(renderer.RenderImplementation())
		print(renderer.RenderAssignment())
	} else {
		fileNameTmpl = 'Functions.cpp.tmpl'
		fileNameOut = 'Functions.cpp'
		template(fileNameTmpl).render(fileNameOut)
		println(fileNameOut, ' was created')
	}
}
