#!/usr/bin/env gura
import(re)

text = R'''
//-----------------------------------------------------------------------------
// Basics - Initialization and Shutdown
Init(Uint32 flags):negerr
InitSubSystem(Uint32 flags):negerr
Quit()
QuitSubSystem(Uint32 flags)
SetMainReady()
WasInit(Uint32 flags):Uint32
//-----------------------------------------------------------------------------
// Basics - Configuration Variables
AddHintCallback
ClearHints
DelhintCallback
GetHint
SetHint
SetHintWithPriority
//-----------------------------------------------------------------------------
// Basics - Error Handling
ClearError()
GetError():const char*
SetError
//-----------------------------------------------------------------------------
// Basics - Log Handling
Log
LogCritical
LogDebug
LogError
LogGetOutputFunction
LogGetPriority
LogInfo
LogMessage
LogMessageV
LogResetPriorities
LogSetAllPriority
LogSetOutputFunction
LogSetPriority
LogVerbose
LogWarn
//-----------------------------------------------------------------------------
// Basics - Assertions
GetAssertionHandler
GetAssertionReport
GetDefaultAssertionHandler
ResetAssertionReport
SetAssertionHandler
TriggerBreakpoint
assert
assert_paranoid
assert_release
//-----------------------------------------------------------------------------
// Basics - Querying SDL Version
GetRevision():const char*
GetRevisionNumber():int
GetVersion
//-----------------------------------------------------------------------------
// Video - Display and Window Management
CreateWindow(const char* title, int x, int y, int w, int h, Uint32 flags):SDL_Window*
CreateWindowAndRenderer(int width, int height, Uint32 window_flags, SDL_Window** #window, SDL_Renderer** #renderer):negerr
CreateWindowFrom
DestroyWindow(SDL_Window* window)
DisableScreenSaver()
EnableScreenSaver()
GL_CreateContext(SDL_Window* window):SDL_GLContext
GL_DeleteContext(SDL_GLContext context)
GL_ExtensionSupported(const char* extension):SDL_bool
GL_GetAttribute(SDL_GLattr attr, int* #value):negerr
GL_GetCurrentContext():SDL_GLContext
GL_GetCurrentWindow():SDL_Window*
GL_GetDrawableSize(SDL_Window* window, int* #w, int* #h)
GL_GetProcAddress
GL_GetSwapInterval():int
GL_LoadLibrary(const char* path):negerr
GL_MakeCurrent(SDL_Window* window, SDL_GLContext context):negerr
GL_ResetAttributes()
GL_SetAttribute(SDL_GLattr attr, int value):negerr
GL_SetSwapInterval(int interval):negerr
GL_SwapWindow(SDL_Window* window)
GL_UnloadLibrary()
GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode* mode, SDL_DisplayMode* #closest)
GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode* #mode):negerr
GetCurrentVideoDriver():const char*
GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode* #mode):negerr
GetDisplayBounds(int displayIndex, SDL_Rect* #rect):negerr
GetDisplayMode(int displayIndex, int modeIndex, SDL_DisplayMode* #mode):negerr
GetDisplayName(int dipslayIndex):const char*
GetNumDisplayModes(int displayIndex):int
GetNumVideoDisplays():int
GetNumVideoDrivers():int
GetVideoDriver(int index):const char*
GetWindowBrightness(SDL_Window* window):float
#GetWindowData(SDL_Window* window, const char* name)
GetWindowDisplayIndex(SDL_Window* window):negerr_number
GetWindowDisplayMode(SDL_Window* window, SDL_DisplayMode* mode):negerr
GetWindowFlags(SDL_Window* window):Uint32
GetWindowFromID(Uint32 id):SDL_Window*
GetWindowGammaRamp(SDL_Window* window, Uint16* #red, Uint16* #green, Uint16* #blue):negerr
GetWindowGrab(SDL_Window* window):SDL_bool
GetWindowID(SDL_Window* window):Uint32
GetWindowMaximumSize(SDL_Window* window, int* #w, int* #h)
GetWindowMinimumSize(SDL_Window* window, int* #w, int* #h)
GetWindowPixelFormat(SDL_Window* window):Uint32
GetWindowPosition(SDL_Window* window, int* #x, int* #y)
GetWindowSize(SDL_Window*window, int* #w, int* #h)
GetWindowSurface(SDL_Window* window):SDL_Surface*
GetWindowTitle(SDL_Window* window):const char*
GetWindowWMInfo(SDL_Window* window, SDL_SysWMinfo* #info):SDL_bool
HideWindow(SDL_Window* window)
IsScreenSaverEnabled():SDL_bool
MaximizeWindow(SDL_Window* window)
MinimizeWindow(SDL_Window* window)
RaiseWindow(SDL_Window* window)
RestoreWindow(SDL_Window* window)
SetWindowBordered(SDL_Window* window, SDL_bool bordered)
SetWindowBrightness(SDL_Window* window, float brightness):negerr
#SetWindowData(SDL_Window* window, const char* name, void* #userdata)
SetWindowDisplayMode(SDL_Window* window, const SDL_DisplayMode* mode):negerr
SetWindowFullscreen(SDL_Window* window, Uint32 flags):negerr
SetWindowGammaRamp(SDL_Window* window, const Uint16* #red, const Uint16* #green, const Uint16* #blue):negerr
SetWindowGrab(SDL_Window* window, SDL_bool grabbed)
SetWindowHitTest(SDL_Window* window, SDL_HitTest #callback, void* #callback_data):negerr
SetWindowIcon(SDL_Window* window, SDL_Surface* icon)
SetWindowMaximumSize(SDL_Window* window, int max_w, int max_h)
SetWindowMinimumSize(SDL_Window* window, int min_w, int min_h)
SetWindowPosition(SDL_Window* window, int x, int y)
SetWindowSize(SDL_Window* window, int w, int h)
SetWindowTitle(SDL_Window* window, const char* title)
#ShowMessageBox(const SDL_MessageBoxData* #messageboxdata, int* #buttonid):negerr
ShowSimpleMessageBox(Uint32 flags, const char* title, const char* message, SDL_Window* window):negerr
ShowWindow(SDL_Window* window)
UpdateWindowSurface(SDL_Window* window):negerr
UpdateWindowSurfaceRects(SDL_Window* window, const SDL_Rect* rects, int #numrects):negerr
VideoInit(const char* driver_name):negerr
VideoQuit()
//-----------------------------------------------------------------------------
// Video - 2D Accelerated Rendering
CreateRenderer(SDL_Window* window, int index, Uint32 flags):SDL_Renderer*
CreateSoftwareRenderer(SDL_Surface* surface):SDL_Renderer*
CreateTexture(SDL_Renderer* renderer, Uint32 format, int access, int w, int h):SDL_Texture*
CreateTextureFromSurface(SDL_Renderer* renderer, SDL_Surface* surface):SDL_Texture*
//CreateWindowAndRenderer(int width, int height, Uint32 window_flags, SDL_Window** #window, SDL_Renderer** #renderer):negerr
DestroyRenderer(SDL_Renderer* renderer)
DestroyTexture(SDL_Texture* texture)
GL_BindTexture(SDL_Texture* texture, float* #texw, float* #texh):negerr
GL_UnbindTexture(SDL_Texture* texture):negerr
GetNumRenderDrivers():int
GetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode* #blendMode):negerr
GetRenderDrawColor(SDL_Renderer* renderer, Uint8* #r, Uint8* #g, Uint8* #b, Uint8* #a)
GetRenderDriverInfo(int index, SDL_RendererInfo* #info):negerr
GetRenderTarget(SDL_Renderer* renderer) SDL_Texture*
GetRenderer(SDL_Window* window):SDL_Renderer*
GetRenderInfo(SDL_Renderer* renderer, SDL_RendererInfo* #info):negerr
GetRenderOutputSize(SDL_Renderer* renderer, int* #w, int* #h):negerr
GetTextureAlphaMod(SDL_Texture* texture, Uint8* #alpha):negerr
GetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode* #blendMode):negerr
GetTextureColorMod(SDL_Texture* texture, Uint8* #r, Uint8* #g, Uint8* #b):negerr
LockTexture(SDL_Texture* texture, const SDL_Rect* rect, void** #pixels, int* #pitch):negerr
QueryTexture(SDL_Texture* texture, Uint32* #format, int* #access, int* #w, int* #h):negerr
RenderClear(SDL_Renderer* renderer):negerr
RenderCopy(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_Rect* srcrect, const SDL_Rect* dstrect):negerr
RenderCopyEx(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_Rect* srcrect, const SDL_Rect* dstrect, double angle, const SDL_Point* center, SDL_RendererFlip flip):negerr
RenderDrawLine(SDL_Renderer* renderer, int x1, int y1, int x2, int y2):negerr
RenderDrawLines(SDL_Renderer* renderer, const SDL_Point* #points, int #count):negerr
RenderDrawPoint(SDL_Renderer* renderer, int x, int y):negerr
RenderDrawPoints(SDL_Renderer* renderer, const SDL_Point* #points, int #count):negerr
RenderDrawRect(SDL_Renderer* renderer, const SDL_Rect* rect):negerr
RenderDrawRects(SDL_Renderer* renderer, const SDL_Rect* #rects, int #count):negerr
RenderFillRect(SDL_Renderer* renderer, const SDL_Rect* rect):negerr
RenderFillRects(SDL_Renderer* renderer, const SDL_Rect* #rects, int #count):negerr
RenderGetClipRect(SDL_Renderer* renderer, SDL_Rect* #rect)
RenderGetLogicalSize(SDL_Renderer* renderer, int* #w, int* #h)
RenderGetScale(SDL_Renderer* renderer, float* #scaleX, float* #scaleY)
RenderGetViewport(SDL_Renderer* renderer, SDL_Rect* #rect)
#RenderIsClipEnabled(SDL_Renderer* renderer):SDL_bool
RenderPresent(SDL_Renderer* renderer)
RenderReadPixels(SDL_Renderer* renderer, const SDL_Rect* rect, Uint32 format, void* #pixels, int pitch):negerr
RenderSetClipRect(SDL_Renderer* renderer, const SDL_Rect* rect):negerr
RenderSetLogicalSize(SDL_Renderer* renderer, int w, int h):negerr
RenderSetScale(SDL_Renderer* renderer, float scaleX, float scaleY):negerr
RenderSetViewport(SDL_Renderer* renderer, const SDL_Rect* rect):negerr
RenderTargetSupported(SDL_Renderer* renderer):SDL_bool
SetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode blendMode)
SetRenderDrawColor(SDL_Renderer* renderer, Uint8 r, Uint8 g, Uint8 b, Uint8 a):negerr
SetRenderTarget(SDL_Renderer* renderer, SDL_Texture *texture):negerr
SetTextureAlphaMod(SDL_Texture* texture, Uint8 alpha):negerr
SetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode blendMode):negerr
SetTextureColorMod(SDL_Texture* texture, Uint8 r, Uint8 g, Uint8 b):negerr
UnlockTexture(SDL_Texture* texture)
UpdateTexture(SDL_Texture* texture, const SDL_Rect* rect, const void* #pixels, int pitch):negerr
UpdateYUVTexture(SDL_Texture* texture, const SDL_Rect* rect, const Uint8* #Yplane, int #Ypitch, const Uint8* #Uplane, int #Upitch, const Uint8* #Vplane, int #Vpitch):negerr
//-----------------------------------------------------------------------------
// Video - Pixel Formats and Conversion Routines
AllocFormat(Uint32 pixel_format):SDL_PixelFormat*
AllocPalette(int ncolors):SDL_Palette*
CalculateGammaRamp(float gamma, Uint16* #ramp)
FreeFormat(SDL_PixelFormat* format)
FreePalette(SDL_Palette* palette)
GetPixelFormatName(Uint32 format):const char*
GetRGB(Uint32 pixel, const SDL_PixelFormat* format, Uint8* #r, Uint8* #g, Uint8* #b)
GetRGBA(Uint32 pixel, const SDL_PixelFormat* format, Uint8* #r, Uint8* #g, Uint8* #b, Uint8* #a)
MapRGB(const SDL_PixelFormat* format, Uint8 r, Uint8 g, Uint8 b):Uint32
MapRGBA(const SDL_PixelFormat* format, Uint8 r, Uint8 g, Uint8 b, Uint8 a):Uint32
MasksToPixelFormatEnum(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):Uint32
PixelFormatEnumToMasks(Uint32 format, int* #bpp, Uint32* #Rmask, Uint32* #Gmask, Uint32* #Bmask, Uint32* #Amask):SDL_bool
SetPaletteColors(SDL_Palette* palette, const SDL_Color* #colors, int firstcolor, int #ncolors):negerr
SetPixelFormatPalette(SDL_PixelFormat* format, SDL_Palette* palette):negerr
//-----------------------------------------------------------------------------
// Video - Rectangle Functions
EnclosePoints(const SDL_Point* #points, int #count, const SDL_Rect* clip, SDL_Rect* #result):SDL_bool
HasIntersection(const SDL_Rect* A, const SDL_Rect* B):SDL_bool
IntersectRect(const SDL_Rect* A, const SDL_Rect* B, SDL_Rect* #result):SDL_bool
#IntersectRectAndLine(const SDL_Rect* rect, int X1, int Y1, int X2, int Y2):SDL_bool
#PointInRect(const SDL_Point* p, const SDL_Rect* r):SDL_bool
RectEmpty(const SDL_Rect* r):SDL_bool
RectEquals(const SDL_Rect* a, const SDL_Rect* b):SDL_bool
UnionRect(const SDL_Rect* A, const SDL_Rect* B, SDL_Rect* #result)
//-----------------------------------------------------------------------------
// Video - Surface Creation and Simple Drawing
BlitScaled(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface*dst, SDL_Rect* dstrect):negerr
BlitSurface(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface*dst, SDL_Rect* dstrect):negerr
ConvertPixels(int width, int height, Uint32 src_format, const void* #src, int #src_pitch, Uint32 dst_format, void* #dst, int #dst_pitch):negerr
ConvertSurface(SDL_Surface* src, const SDL_PixelFormat* fmt, Uint32 flags):SDL_Surface*
ConvertSurfaceFormat(SDL_Surface* src, Uint32 pixel_format, Uint32 flags):SDL_Surface*
CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):SDL_Surface*
CreateRGBSurfaceFrom(void* #pixels, int width, int height, int depth, int pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):SDL_Surface*
FillRect(SDL_Surface* dst, const SDL_Rect* rect, Uint32 color):negerr
FillRects(SDL_Surface* dst, const SDL_Rect* #rects, int #count, Uint32 color):negerr
FreeSurface(SDL_Surface* surface)
GetClipRect(SDL_Surface* surface, SDL_Rect* rect)
GetColorKey(SDL_Surface* surface, Uint32* #key):negerr
GetSurfaceAlphaMod(SDL_Surface* surface, Uint8* #alpha):negerr
GetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode* #blendMode):negerr
GetSurfaceColorMod(SDL_Surface* surface, Uint8* #r, Uint8* #g, Uint8* #b):negerr
LoadBMP(const char* file):SDL_Surface*
#LoadBMP_RW(SDL_RWops* src, int freesrc):SDL_Surface*
LockSurface(SDL_Surface* surface):negerr
LowerBlit(SDL_Surface* src, SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect):negerr
LowerBlitScaled(SDL_Surface* src, SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect):negerr
MUSTLOCK(SDL_Surface* surface):bool
SaveBMP(SDL_Surface* surface, const char* file):negerr
#SaveBMP_RW(SDL_Surface* surface, SDL_RWops* dst, int freedst):negerr
SetClipRect(SDL_Surface* surface, const SDL_Rect* rect):SDL_bool
SetColorKey(SDL_Surface* surface, int flag, Uint32 key):negerr
SetSurfaceAlphaMod(SDL_Surface* surface, Uint8 alpha):negerr
SetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode blendMode):negerr
SetSurfaceColorMod(SDL_Surface* surface, Uint8 r, Uint8 g, Uint8 b):negerr
SetSurfacePalette(SDL_Surface* surface, SDL_Palette* palette):negerr
SetSurfaceRLE(SDL_Surface* surface, int flag):negerr
UnlockSurface(SDL_Surface* surface)
//-----------------------------------------------------------------------------
// Video - Platform-specific Window Management
//GetWindowWMInfo(SDL_Window* window, SDL_SysWMinfo* #info):SDL_bool // duplicated
//-----------------------------------------------------------------------------
// Video - Clipboard Handling
#GetClipboardText():char*
HasClipboardText():SDL_bool
SetClipboardText(const char* text):negerr
//-----------------------------------------------------------------------------
// Input Events - Event Handling
#AddEventWatch()
#DelEventWatch()
EventState(Uint32 type, int state):Uint8
#FilterEvents()
FlushEvent(Uint32 type)
FlushEvents(Uint32 minType, Uint32 maxType)
#GetEventFilter()
GetNumTouchDevices():int
GetNumTouchFingers(SDL_TouchID touchId):int
GetTouchDevice(int index):SDL_TouchID
GetTouchFinger(SDL_TouchID touchId, int index):SDL_Finger*
HasEvent(Uint32 type):SDL_bool
HasEvents(Uint32 minType, Uint32 maxType):SDL_bool
#LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops* src):negerr_number
PeepEvents(SDL_Event* #events, int #numevents, SDL_eventaction action, Uint32 minType, Uint32 maxType):negerr
PollEvent():SDL_Event {
	AutoPtr<Object_Event> pObj(new Object_Event());
	int rtn = SDL_PollEvent(pObj->GetEntity());
	if (rtn == 0) return Value::Null;
	return Value(pObj.release());
}
PumpEvents()
PushEvent(SDL_Event* event):negerr_number
QuitRequested():bool
RecordGesture(SDL_TouchID touchId):negerr
RegisterEvents(int numevents):Uint32
#SaveAllDollarTemplates(SDL_RWops* dst):negerr
#SaveDollarTemplate(SDL_GestureID gestureId, SDL_RWops* dst):negerr
#SetEventFilter()
WaitEvent(SDL_Event* #event):negerr
WaitEventTimeout(SDL_Event* #event, int timeout):negerr
//-----------------------------------------------------------------------------
// Input Events - Keyboard Support
GetKeyFromName(const char* name):SDL_Keycode
GetKeyFromScancode(SDL_Scancode scancode):SDL_Keycode
GetKeyName(SDL_Keycode key):const char*
GetKeyboardFocus():SDL_Window*
#GetKeyboardState(int* #numkeys):const Uint8*
GetModState():SDL_Keymod
GetScancodeFromKey(SDL_Keycode key):SDL_Scancode
GetScancodeFromName(const char* name):SDL_Scancode
GetScancodeName(SDL_Scancode scancode):const char*
HasScreenKeyboardSupport():SDL_bool
IsScreenKeyboardShown(SDL_Window* window):SDL_bool
IsTextInputActive():SDL_bool
SetModState(SDL_Keymod modstate)
SetTextInputRect(SDL_Rect* rect)
StartTextInput()
StopTextInput()
//-----------------------------------------------------------------------------
// Input Events - Mouse Support
#CaptureMouse(SDL_bool enalbed):negerr
CreateColorCursor(SDL_Surface* surface, int hot_x, int hot_y):SDL_Cursor*
CreateCursor(const Uint8* #data, const Uint8* mask, int w, int h, int hot_x, int hot_y):SDL_Cursor*
CreateSystemCursor(SDL_SystemCursor id):SDL_Cursor*
FreeCursor(SDL_Cursor* cursor)
GetCursor():SDL_Cursor*
GetDefaultCursor():SDL_Cursor*
GetGlobalMouseState(int* #x, int* #y):Uint32
GetMouseFocus():SDL_Window*
GetMouseState(int* #x, int* #y):Uint32
GetRelativeMouseMode():SDL_bool
GetRelativeMouseState(int* #x, int* #y):Uint32
SetCursor(SDL_Cursor* cursor)
SetRelativeMouseMode(SDL_bool enabled):negerr
ShowCursor(int toggle):negerr
#WarpMouseGlobal(int x, int y)
WarpMouseInWindow(SDL_Window* window, int x, int y)
//-----------------------------------------------------------------------------
// Input Events - Joystick Support
JoystickClose(SDL_Joystick* joystick)
JoystickEventState(int state):negerr_number
JoystickGetAttached(SDL_Joystick* joystick):SDL_bool
JoystickGetAxis(SDL_Joystick* joystick, int axis):Sint16
JoystickGetBall(SDL_Joystick* joystick, int ball, int* #dx, int* #dy):negerr
JoystickGetButton(SDL_Joystick* joystick, int button):Uint8
#JoystickGetDeviceGUID(int device_index):int
#JoystickGetGUID(SDL_Joystick* joystick):int
#JoystickGetGUIDFromString(const char* pchGUID):int
#JoystickGetGUIDString()
JoystickGetHat(SDL_Joystick* joystick, int hat):Uint8
JoystickInstanceID(SDL_Joystick* joystick):SDL_JoystickID
JoystickName(SDL_Joystick* joystick):const char*
JoystickNameForIndex(int device_index):const char*
JoystickNumAxes(SDL_Joystick* joystick):negerr_number
JoystickNumBalls(SDL_Joystick* joystick):negerr_number
JoystickNumButtons(SDL_Joystick* joystick):negerr_number
JoystickNumHats(SDL_Joystick* joystick):negerr_number
JoystickOpen(int device_index):SDL_Joystick*
JoystickUpdate()
NumJoysticks():negerr_number
//-----------------------------------------------------------------------------
// Input Events - Game Controller Support
GameControllerAddMapping(const char* mappingString):negerr_number
GameControllerAddMappingsFromFile(const char* filename):negerr_number
#GameControllerAddMappingsFromRW(SDL_RWops* rw, int freerw):negerr_number
GameControllerClose(SDL_GameController* gamecontroller)
GameControllerEventState(int state):int
GameControllerGetAttached(SDL_GameController* gamecontroller):SDL_bool
GameControllerGetAxis(SDL_GameController* gamecontroller, SDL_GameControllerAxis axis):Sint16
GameControllerGetAxisFromString(const char* pchString):SDL_GameControllerAxis
GameControllerGetBindForAxis(SDL_GameController* gamecontroller, SDL_GameControllerAxis axis):SDL_GameControllerButtonBind
GameControllerGetBindForButton(SDL_GameController* gamecontroller, SDL_GameControllerButton button):SDL_GameControllerButtonBind
GameControllerGetButton(SDL_GameController* gamecontroller, SDL_GameControllerButton button):Uint8
GameControllerGetButtonFromString(const char* pchString):SDL_GameControllerButton
GameControllerGetJoystick(SDL_GameController* gamecontroller):SDL_Joystick*
GameControllerGetStringForAxis(SDL_GameControllerAxis axis):const char*
GameControllerGetStringForButton(SDL_GameControllerButton button):const char*
GameControllerMapping(SDL_GameController* gamecontroller):const char*
#GameControllerMappingForGUID(int guid):const char*
GameControllerName(SDL_GameController* gamecontroller):const char*
GameControllerNameForIndex(int joystick_index):const char*
GameControllerOpen(int joystick_index):SDL_GameController*
GameControllerUpdate()
IsGameController(int joystick_index):SDL_bool
//-----------------------------------------------------------------------------
// Force Feedback - Force Feedback Support
HapticClose(SDL_Haptic* haptic)
HapticDestroyEffect(SDL_Haptic* haptic, int effect)
HapticEffectSupported(SDL_Haptic* haptic, SDL_HapticEffect* effect):negerr_boolean
HapticGetEffectStatus(SDL_Haptic* haptic, int effect):negerr_boolean
HapticIndex(SDL_Haptic* haptic):negerr_number
HapticName(int device_index):const char*
HapticNewEffect(SDL_Haptic* haptic, SDL_HapticEffect* effect):negerr_number
HapticNumAxes(SDL_Haptic* haptic):negerr_number
HapticNumEffects(SDL_Haptic* haptic):negerr_number
HapticNumEffectsPlaying(SDL_Haptic* haptic):negerr_number
HapticOpen(int device_index):SDL_Haptic*
HapticOpenFromJoystick(SDL_Joystick* joystick):SDL_Haptic*
HapticOpenFromMouse():SDL_Haptic*
HapticOpened(int device_index):negerr_boolean
HapticPause(SDL_Haptic* haptic):negerr
HapticQuery(SDL_Haptic* haptic):unsigned int
HapticRumbleInit(SDL_Haptic* haptic):negerr
HapticRumblePlay(SDL_Haptic* haptic, float strength, Uint32 length):negerr
HapticRumbleStop(SDL_Haptic* haptic):negerr
HapticRumbleSupported(SDL_Haptic* haptic):negerr_boolean
HapticRunEffect(SDL_Haptic* haptic, int effect, Uint32 iterations):negerr
HapticSetAutocenter(SDL_Haptic* haptic, int autocenter):negerr
HapticSetGain(SDL_Haptic* haptic, int gain):negerr
HapticStopAll(SDL_Haptic* haptic):negerr
HapticStopEffect(SDL_Haptic* haptic, int effect):negerr
HapticUnpause(SDL_Haptic* haptic):negerr
HapticUpdateEffect(SDL_Haptic* haptic, int effect, SDL_HapticEffect* data):negerr
JoystickIsHaptic(SDL_Joystick* joystick):negerr_boolean
MouseIsHaptic():negerr_boolean
NumHaptics():negerr_number
//-----------------------------------------------------------------------------
// Audio - Audio Device Management, Playing and Recording
AudioInit(const char* driver_name):negerr
AudioQuit()
BuildAudioCVT(SDL_AudioCVT* cvt, SDL_AudioFormat src_format, Uint8 src_channels, int src_rate, SDL_AudioFormat dst_format, Uint8 dst_channels, int dst_rate):negerr_boolean
#ClearQueuedAudio(SDL_AudioDeviceID dev)
CloseAudio()
CloseAudioDevice(SDL_AudioDeviceID dev)
ConvertAudio(SDL_AudioCVT* cvt):negerr
FreeWAV(Uint8* #audio_buf)
GetAudioDeviceName(int index, int iscapture):const char*
GetAudioDeviceStatus(SDL_AudioDeviceID dev):SDL_AudioStatus
GetAudioDriver(int index):const char*
GetAudioStatus():SDL_AudioStatus
GetCurrentAudioDriver():const char*
GetNumAudioDevices(int iscapture):negerr_number
GetNumAudioDrivers():int
#GetQueuedAudioSize(SDL_AudioDeviceID dev):Uint32
LoadWAV(const char* file, SDL_AudioSpec* spec, Uint8** #audio_buf, Uint32* #audio_len):SDL_AudioSpec*
#LoadWAV_RW(SDL_RWops* src, int freesrc, SDL_AudioSpec* spec, Uint8** #audio_buf, Uint32* #audio_len):SDL_AudioSpec*
LockAudio()
LockAudioDevice(SDL_AudioDeviceID dev)
MixAudio(Uint8* #dst, const Uint8* #src, Uint32 #len, int volume)
MixAudioFormat(Uint8* #dst, const Uint8* #src, SDL_AudioFormat format, Uint32 #len, int volume)
OpenAudio(SDL_AudioSpec* desired, SDL_AudioSpec* #obtained):negerr
OpenAudioDevice(const char* device, int iscapture, const SDL_AudioSpec* desired, SDL_AudioSpec* #obtained, int allowed_changes):SDL_AudioDeviceID
PauseAudio(int pause_on)
PauseAudioDevice(SDL_AudioDeviceID dev, int pause_on)
QueueAudio(SDL_AudioDeviceID dev, const void* #data, Uint32 #len):negerr
UnlockAudio()
UnlockAudioDevice(SDL_AudioDeviceID dev)
//-----------------------------------------------------------------------------
// Threads - Thread Management
CreateThread
DetachThread
GetThreadID
GetThreadName
GetThreadPriority
TLSCreate
TLSGet
TLSSet
ThreadID
WaitThread
//-----------------------------------------------------------------------------
// Threads - Thread Synchronization Primitives
CondBroadcast
CondSignal
CondWait
CondWaitTimeout
CreateCond
CreateMutex
CreateSemaphore
DestroyCond
DestroyMutex
DestroySemaphore
LockMutex
SemPost
SemTryWait
SemValue
SemWait
SemWaitTimeout
TryLockMutex
UnlockMutex
//-----------------------------------------------------------------------------
// Threads - Atomic Operations
AtomicAdd
AtomicCAS
AtomicCASPtr
AtomicDecRef
AtomicGet
AtomicGetPtr
AtomicIncRef
AtomicLock
AtomicSet
AtomicSetPtr
AtomicTryLock
AtomicUnlock
CompilerBarrier
//-----------------------------------------------------------------------------
// Timers - Timer Support
AddTimer(Uint32 interval, SDL_TimerCallback #callback, void* #param):SDL_TimerID
Delay(Uint32 ms)
GetPerformanceCounter():Uint64
GetPerformanceFrequency():Uint64
GetTicks():Uint32
RemoveTimer(SDL_TimerID id):SDL_bool
TICKS_PASSED(Uint32 A, Uint32 B):bool
//-----------------------------------------------------------------------------
// File Abstraction - Filesystem Paths
#GetBasePath():char*
#GetPrefPath(const char* org, const char* app):char*
//-----------------------------------------------------------------------------
// File Abstraction - File I/O Abstraction
AllocRW
FreeRW
RWFromConstMem
RWFromFP
RWFromFile
RWFromMem
RWclose
RWread
RWseek
RWtell
RWwrite
ReadBE16
ReadBE32
ReadBE64
ReadLE16
ReadLE32
ReadLE64
WriteBE16
WriteBE32
WriteBE64
WriteLE16
WriteLE32
WriteLE64
//-----------------------------------------------------------------------------
// Shared Object Support - Shared Object Loading and Function Lookup
//-----------------------------------------------------------------------------
// Platform and CPU Information - Platform Detection
GetPlatform():const char*
//-----------------------------------------------------------------------------
// Platform and CPU Information - CPU Feature Detection
GetCPUCacheLineSize():int
GetCPUCount():int
GetSystemRAM():int
Has3DNow():SDL_bool
HasAVX():SDL_bool
#HasAVX2():SDL_bool
HasAltiVec():SDL_bool
HasMMX():SDL_bool
HasRDTSC():SDL_bool
HasSSE():SDL_bool
HasSSE2():SDL_bool
HasSSE3():SDL_bool
HasSSE41():SDL_bool
HasSSE42():SDL_bool
//-----------------------------------------------------------------------------
// Platform and CPU Information - Byte Order and Byte Swapping
Swap16
Swap32
Swap64
SwapBE16
SwapBE32
SwapBE64
SwapFloat
SwapFloatBE
SwapFloatLE
SwapLE16
SwapLE32
SwapLE64
//-----------------------------------------------------------------------------
// Platform and CPU Information - Bit Manipulation
#MostSignificantBitIndex32(Uint32 x):int
//-----------------------------------------------------------------------------
// Power Management - Power Management Status
SDL_GetPowerInfo(int* #secs, int* #pct):SDL_PowerState
//-----------------------------------------------------------------------------
// Additional - Platform-specific functionality
AndroidGetActivity
AndroidGetExternalStoragePath
AndroidGetExternalStorageState
AndroidGetInternalStoragePath
AndroidGetJNIEnv
//-----------------------------------------------------------------------------
// Additional - Other
acos(double x):double
'''

tmplImplementation = R'''
// sdl2.${fi.funcName}(${
	(fi.argsGura:*name + ':' + fi.argsGura:*GetFullTypeGura()).join(', ')
})${
	cond(fi.voidFlag, ':void', '')
}
Gura_DeclareFunction(${fi.funcName})
{
	${if (fi.voidFlag)}
	SetMode(RSLTMODE_Void, FLAG_None);
	${else}
	SetMode(RSLTMODE_Normal, FLAG_None);
	${end}
	${for (arg in fi.argsGura)}
	DeclareArg(env, "${arg.name}", VTYPE_${arg.typeGura}, OCCUR_Once, FLAG_None);
	${end}
	AddHelp(Gura_Symbol(en), Help::FMT_markdown,
	"");
}

Gura_ImplementFunction(${fi.funcName})
{
	${if (!fi.validFlag)}
#if 0
	${end}
	${argsCJoined = fi.argsC:*name.join(', '), -}
	${for (argC in fi.argsC) {|idx|}}
	${argC.typeC.sub(r'(\w)$', r'\1 ') + argC.name} = ${
		if (argC.typeC.endswith('*')) {
			format('args.IsValid(%d)? ', idx) + argC.GetArg(idx) + ' : NULL'
		} else {
			argC.GetArg(idx)
		}
	};
	${end}
	${if (fi.linesCustom)}
	${fi.linesCustom}
	${elsif (!fi.rtnInfo)}
	SDL_${fi.funcName}(${argsCJoined});
	return Value::Null;
	${elsif (fi.rtnInfo.typeC == 'negerr')}
	int rtn = SDL_${fi.funcName}(${argsCJoined});
	if (rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
	${elsif (fi.rtnInfo.typeC == 'boolerr')}
	int rtn = SDL_${fi.funcName}(${argsCJoined});
	if (rtn == 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
	${elsif (fi.rtnInfo.typeC == 'negerr_number')}
	int rtn = SDL_${fi.funcName}(${argsCJoined});
	if (rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value(rtn);
	${elsif (fi.rtnInfo.typeC == 'negerr_boolean')}
	int rtn = SDL_${fi.funcName}(${argsCJoined});
	if (rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value(rtn != 0);
	${else}
	${fi.rtnInfo.typeC.sub(r'(\w)$', r'\1 ')}rtn = SDL_${fi.funcName}(${argsCJoined});
	${if (fi.rtnInfo.typeC.endswith('*'))}
	if (rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	${end}
	return ${fi.rtnInfo.fmtReturn};
	${end}
	${if (!fi.validFlag)}
#endif
	SetError_NotImpFunction(sig, "${fi.funcName}");
	return Value::Null;
	${end}
}
'''.template()

tmplAssignment = R'''
	Gura_AssignFunction(${fi.funcName});
'''.template()

ArgInfo = struct(name:string, typeC:string,
				 moduleName:string:nil, typeGura:string:nil, fmtGetter:string:nil) {
	GetArg(idx:number) = format(this.fmtGetter, idx)
	GetFullTypeGura() = cond(this.moduleName,
							 this.moduleName + '.' + this.typeGura, this.typeGura)
}

ReturnInfo = struct(typeC:string, typeGura:string:nil, fmtReturn:string:nil) {
}

TypeConv = struct(moduleName:string:nil, typeGura:string, fmtGetter:string, fmtReturn:string)

typeConvDict = %{
	'char' => TypeConv(nil, 'number', 'args.GetChar(%d)', 'Value(rtn)')
	'int' => TypeConv(nil, 'number', 'args.GetInt(%d)', 'Value(rtn)')
	'unsigned int' => TypeConv(nil, 'number', 'args.GetUInt(%d)', 'Value(rtn)')
	'short' => TypeConv(nil, 'number', 'args.GetShort(%d)', 'Value(rtn)')
	'float' => TypeConv(nil, 'number', 'args.GetFloat(%d)', 'Value(rtn)')
	'double' => TypeConv(nil, 'number', 'args.GetDouble(%d)', 'Value(rtn)')
	'Uint8' => TypeConv(nil, 'number', 'args.GetUChar(%d)', 'Value(rtn)')
	'Uint16' => TypeConv(nil, 'number', 'args.GetUShort(%d)', 'Value(rtn)')
	'Uint32' => TypeConv(nil, 'number', 'args.GetULong(%d)', 'Value(rtn)')
	'Uint64' => TypeConv(nil, 'number', 'static_cast<Uint64>(args.GetDouble(%d))', 'Value(rtn)')
	'Sint8' => TypeConv(nil, 'number', 'args.GetChar(%d)', 'Value(rtn)')
	'Sint16' => TypeConv(nil, 'number', 'args.GetShort(%d)', 'Value(rtn)')
	'Sint32' => TypeConv(nil, 'number', 'args.GetLong(%d)', 'Value(rtn)')
	'char *' => TypeConv(nil, 'string', 'args.GetString(%d)', 'Value(rtn)')
	'const char *' => TypeConv(nil, 'string', 'args.GetString(%d)', 'Value(rtn)')
	'const Uint8 *' => TypeConv(nil, 'number', 'args.GetList(%d)', 'Value::Null')
	'bool' => TypeConv(nil, 'boolean', 'args.GetBoolean(%d)', 'Value(rtn)')
	'SDL_bool' => TypeConv(nil, 'boolean', '(args.GetBoolean(%d)? SDL_TRUE : SDL_FALSE)', 'Value(rtn != SDL_FALSE)')
	'SDL_eventaction' => TypeConv(
			nil, 'number',
			'static_cast<SDL_eventaction>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GLattr' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GLattr>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_AudioDeviceID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_AudioDeviceID>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_AudioStatus' => TypeConv(
			nil, 'number',
			'static_cast<SDL_AudioStatus>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_PowerState' => TypeConv(
			nil, 'number',
			'static_cast<SDL_PowerState>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_TouchID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_TouchID>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_JoystickID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_JoystickID>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GestureID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GestureID>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_TimerID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_TimerID>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_RendererFlip' => TypeConv(
			nil, 'number',
			'static_cast<SDL_RendererFlip>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_BlendMode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_BlendMode>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_Keycode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Keycode>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_Scancode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Scancode>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_Keymod' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Keymod>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_SystemCursor' => TypeConv(
			nil, 'number',
			'static_cast<SDL_SystemCursor>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GameControllerAxis' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GameControllerAxis>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GameControllerButton' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GameControllerButton>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_AudioFormat' => TypeConv(
			nil, 'number',
			'static_cast<SDL_AudioFormat>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GLContext' => TypeConv(
			'sdl2', 'GLContext',
			'Object_GLContext::GetObject(args, %d)->GetEntity()',
			'Value(new Object_GLContext(rtn))')
	'SDL_AudioCVT *' => TypeConv(
			'sdl2', 'AudioCVT',
			'Object_AudioCVT::GetObject(args, %d)->GetEntity()',
			'Value(new Object_AudioCVT(rtn))')
	'SDL_AudioSpec *' => TypeConv(
			'sdl2', 'AudioSpec',
			'Object_AudioSpec::GetObject(args, %d)->GetEntity()',
			'Value(new Object_AudioSpec(rtn))')
	'const SDL_AudioSpec *' => TypeConv(
			'sdl2', 'AudioSpec',
			'Object_AudioSpec::GetObject(args, %d)->GetEntity()',
			'Value(new Object_AudioSpec(rtn))')
	'SDL_Finger *' => TypeConv(
			'sdl2', 'Finger',
			'Object_Finger::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Finger(rtn))')
	'SDL_Haptic *' => TypeConv(
			'sdl2', 'Haptic',
			'Object_Haptic::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Haptic(rtn))')
	'SDL_HapticEffect *' => TypeConv(
			'sdl2', 'HapticEffect',
			'Object_HapticEffect::GetObject(args, %d)->GetEntity()',
			'Value(new Object_HapticEffect(rtn))')
	'SDL_Event' => TypeConv(
			'sdl2', 'Event',
			'*Object_Event::GetObject(args, %d)->GetEntity()',
			nil)
	'SDL_Event *' => TypeConv(
			'sdl2', 'Event',
			'Object_Event::GetObject(args, %d)->GetEntity()',
			nil)
	'SDL_Rect *' => TypeConv(
			'sdl2', 'Rect',
			'Object_Rect::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Rect(rtn))')
	'SDL_Point *' => TypeConv(
			'sdl2', 'Point',
			'Object_Point::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Point(rtn))')
	'const SDL_Rect *' => TypeConv(
			'sdl2', 'Rect',
			'Object_Rect::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Rect(rtn))')
	'const SDL_Point *' => TypeConv(
			'sdl2', 'Point',
			'Object_Point::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Point(rtn))')
	'SDL_Window *' => TypeConv(
			'sdl2', 'Window',
			'Object_Window::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Window(rtn))')
	'SDL_Surface *' => TypeConv(
			'sdl2', 'Surface',
			'Object_Surface::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Surface(rtn))')
	'SDL_RWops *' => TypeConv(
			'sdl2', 'nil',
			'NULL',
			'Value::Null')
	'SDL_Renderer *' => TypeConv(
			'sdl2', 'Renderer',
			'Object_Renderer::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Renderer(rtn))')
	'SDL_Texture *' => TypeConv(
			'sdl2', 'Texture',
			'Object_Texture::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Texture(rtn))')
	'SDL_SysWMinfo *' => TypeConv(
			'sdl2', 'SysWMinfo',
			'Object_SysWMinfo::GetObject(args, %d)->GetEntity()',
			'Value(new Object_SysWMinfo(rtn))')
	'SDL_PixelFormat *' => TypeConv(
			'sdl2', 'PixelFormat',
			'Object_PixelFormat::GetObject(args, %d)->GetEntity()',
			'Value(new Object_PixelFormat(rtn))')
	'const SDL_PixelFormat *' => TypeConv(
			'sdl2', 'PixelFormat',
			'Object_PixelFormat::GetObject(args, %d)->GetEntity()',
			'Value(new Object_PixelFormat(rtn))')
	'SDL_Palette *' => TypeConv(
			'sdl2', 'Palette',
			'Object_Palette::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Palette(rtn))')
	'SDL_Cursor *' => TypeConv(
			'sdl2', 'Cursor',
			'Object_Cursor::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Cursor(rtn, false))')
	'SDL_Joystick *' => TypeConv(
			'sdl2', 'Joystick',
			'Object_Joystick::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Joystick(rtn))')
	'SDL_GameController *' => TypeConv(
			'sdl2', 'GameController',
			'Object_GameController::GetObject(args, %d)->GetEntity()',
			'Value(new Object_GameController(rtn))')
	'SDL_GameControllerButtonBind' => TypeConv(
			'sdl2', 'GameControllerButtonBind',
			'Object_GameControllerButtonBind::GetObject(args, %d)->GetEntity()',
			'Value(new Object_GameControllerButtonBind(rtn))')
	'SDL_DisplayMode *' => TypeConv(
			'sdl2', 'DisplayMode',
			'Object_DisplayMode::GetObject(args, %d)->GetEntity()',
			'Value(new Object_DisplayMode(rtn))')
	'const SDL_DisplayMode *' => TypeConv(
			'sdl2', 'DisplayMode',
			'Object_DisplayMode::GetObject(args, %d)->GetEntity()',
			'Value(new Object_DisplayMode(rtn))')
}

FuncInfo = class {
	public {
		funcName, argsC, argsGura, rtnInfo, validFlag, voidFlag, linesCustom
	}
	__init__(lineNo:number, funcName:string, argsRaw:string:nil, rtnRaw:string:nil) = {
		this.argsRaw = argsRaw
		this.validFlag = this.argsRaw?
		if (funcName.startswith('#')) {
			this.funcName = funcName.replace('#', '')
			this.validFlag = false
		} else {
			this.funcName = funcName
		}
		if (rtnRaw && rtnRaw.isempty()) { rtnRaw = nil }
		this.rtnRaw = rtnRaw
		this.argsC = []
		this.argsGura = []
		this.rtnInfo = nil
		this.voidFlag = false
		this.linesCustom = nil
		if (this.argsRaw) {
			this.argsC = this.argsRaw.split(',').each():xlist {|argRaw|
				argRaw = argRaw.strip()
				argRaw.isempty() && continue
				if (m = argRaw.match(r'^(\w+)\s+(#?\w+)$')) {
					[typeC, name] = m[1, 2]
				} elsif (m = argRaw.match(r'^unsigned\s+(\w+)\s+(#?\w+)$')) {
					[typeC, name] = ['unsigned ' + m[1], m[2]]
				} elsif (m = argRaw.match(r'^(\w+)\s*(\*+)\s*(#?\w+)$')) {
					[typeC, name] = [m[1] + ' ' + m[2], m[3]]
				} elsif (m = argRaw.match(r'^const\s+(\w+)\s*(\*+)\s*(#?\w+)$')) {
					[typeC, name] = ['const ' + m[1] + ' ' + m[2], m[3]]
				} else {
					sys.stderr.printf('%d: invalid argument "%s"\n', lineNo, argRaw)
					sys.exit(1)
				}
				if (name.startswith('#')) {
					this.validFlag = false
					ArgInfo(name.replace('#', ''), typeC, nil, nil, 'NULL')
				} else {
					typeConv = typeConvDict.get(typeC)
					if (!typeConv) {
						sys.stderr.printf(
								'%d: proper conversion not found in table "%s"\n',
								lineNo, argRaw)
						sys.exit(1)
					}
					ArgInfo(name, typeC, typeConv.moduleName,
							typeConv.typeGura, typeConv.fmtGetter)
				}
			}
		}
		if (!this.rtnRaw) {
			// nothing to do
		} elsif (this.rtnRaw == 'negerr') {
			this.rtnInfo = ReturnInfo('negerr', nil, nil)
		} elsif (this.rtnRaw == 'boolerr') {
			this.rtnInfo = ReturnInfo('boolerr', nil, nil)
		} elsif (this.rtnRaw == 'negerr_number') {
			this.rtnInfo = ReturnInfo('negerr_number', nil, nil)
		} elsif (this.rtnRaw == 'negerr_boolean') {
			this.rtnInfo = ReturnInfo('negerr_boolean', nil, nil)
		} else {
			if (m = rtnRaw.match(r'^(\w+)$')) {
				typeC = m[1]
			} elsif (m = rtnRaw.match(r'^unsigned\s+(\w+)$')) {
				typeC = 'unsigned ' + m[1]
			} elsif (m = rtnRaw.match(r'^(\w+)\s*\*\s*$')) {
				typeC = m[1] + ' *'
			} elsif (m = rtnRaw.match(r'^const\s+(\w+)\s*\*\s*$')) {
				typeC = 'const ' + m[1] + ' *'
			} else {
				sys.stderr.printf('%d: invalid return type "%s"\n', lineNo, rtnRaw)
				sys.exit(1)
			}
			typeConv = typeConvDict.get(typeC)
			if (!typeConv) {
				sys.stderr.printf('%d: invalid return type "%s"\n', lineNo, rtnRaw)
				sys.exit(1)
			}
			this.rtnInfo = ReturnInfo(typeC, typeConv.typeGura, typeConv.fmtReturn)
		}
		this.argsGura = this.argsC.filter(this.argsC:*typeGura):list
		this.voidFlag = (!this.rtnInfo || this.rtnInfo.typeC in ['negerr', 'boolerr'])
	}
	SetLinesCustom(linesCustom:string) = {
		this.linesCustom = linesCustom
	}
	RenderImplementation() = {
		fi = this
		tmplImplementation.render()
	}
	RenderAssignment() = {
		fi = this
		tmplAssignment.render()
	}
}

funcInfos = []
stat = `init
linesCustom = ''
text.eachline {|line, i|
	if (stat == `init) {
		line = line.strip()
		(line.startswith('//') || line.isempty()) && continue
		lineNo = i + 1
		restPart = line
		fields = restPart.split(':')
		argsRaw = nil
		rtnRaw = nil
		if (fields.len() > 1) {
			[restPart, rtnRaw] = fields
		}
		if (m = restPart.match(r'(.*)\(([^\)]*)\)')) {
			[restPart, argsRaw] = m[1, 2]
		}
		if (m = restPart.match(r'^(#?\w+)$')) {
			funcName = m[1]
			if (funcInfos:*funcName.find(funcName)) {
				sys.stderr.printf('%d: duplicated function %s\n', lineNo, funcName)
				sys.exit(1)
			}
			if (rtnRaw && (m = rtnRaw.match(r'(\w+)\s*{$'))) {
				rtnRaw = m[1]
				linesCustom = ''
				stat = `custom
			}
			funcInfo = FuncInfo(lineNo, funcName, argsRaw, rtnRaw)
			funcInfos.add(funcInfo)
		} else {
			sys.stderr.printf('%d: invalid format\n', lineNo)
			sys.exit(1)
		}
	} elsif (stat == `custom) {
		if (line.match(r'^}$')) {
			funcInfo.SetLinesCustom(linesCustom)
			stat = `init
		} else {
			line = line.sub('(^\t|    )', '')
			linesCustom += line
		}
	}
}

scope {
	fileNameTmpl = 'module-sdl2.cpp.tmpl'
	fileNameOut = 'module-sdl2.cpp'
	template(fileNameTmpl).render(fileNameOut)
	println(fileNameOut, ' was created')
}
