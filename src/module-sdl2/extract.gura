#!/usr/bin/env gura
import(re)

text = R'''
//-----------------------------------------------------------------------------
// Basics - Initialization and Shutdown
Init(Uint32 flags):error
InitSubSystem(Uint32 flags):error
Quit()
QuitSubSystem(Uint32 flags)
SetMainReady()
WasInit(Uint32 flags):Uint32
//-----------------------------------------------------------------------------
// Basics - Configuration Variables
AddHintCallback
ClearHints
DelhintCallback
GetHint
SetHint
SetHintWithPriority
//-----------------------------------------------------------------------------
// Basics - Error Handling
ClearError()
GetError():const char*
SetError
//-----------------------------------------------------------------------------
// Basics - Log Handling
Log
LogCritical
LogDebug
LogError
LogGetOutputFunction
LogGetPriority
LogInfo
LogMessage
LogMessageV
LogResetPriorities
LogSetAllPriority
LogSetOutputFunction
LogSetPriority
LogVerbose
LogWarn
//-----------------------------------------------------------------------------
// Basics - Assertions
GetAssertionHandler
GetAssertionReport
GetDefaultAssertionHandler
ResetAssertionReport
SetAssertionHandler
TriggerBreakpoint
assert
assert_paranoid
assert_release
//-----------------------------------------------------------------------------
// Basics - Querying SDL Version
GetRevision():const char*
GetRevisionNumber():int
GetVersion
//-----------------------------------------------------------------------------
// Video - Display and Window Management
CreateWindow(const char* title, int x, int y, int w, int h, Uint32 flags):SDL_Window*
CreateWindowAndRenderer(int width, int height, Uint32 window_flags, SDL_Window** #window, SDL_Renderer** #renderer):error
CreateWindowFrom
DestroyWindow(SDL_Window* window)
DisableScreenSaver()
EnableScreenSaver()
GL_CreateContext(SDL_Window* window):SDL_GLContext
DeleteContext(SDL_GLContext context)
GL_ExtensionSupported(const char* extension):SDL_bool
GL_GetAttribute(SDL_GLattr attr, int* #value):error
GL_GetCurrentContext():SDL_GLContext
GL_GetCurrentWindow():SDL_Window*
GL_GetDrawableSize(SDL_Window* window, int* #w, int* #h)
GL_GetProcAddress
GL_GetSwapInterval():int
GL_LoadLibrary(const char* path):error
GL_MakeCurrent(SDL_Window* window, SDL_GLContext context):error
GL_ResetAttributes()
GL_SetAttribute(SDL_GLattr attr, int value):error
GL_SetSwapInterval(int interval):error
GL_SwapWindow(SDL_Window* window)
GL_UnloadLibrary()
GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode* mode, SDL_DisplayMode* #closest)
GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode* #mode):error
GetCurrentVideoDriver():const char*
GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode* #mode):error
GetDisplayBounds(int displayIndex, SDL_Rect* #rect):error
GetDisplayMode(int displayIndex, int modeIndex, SDL_DisplayMode* #mode):error
GetDisplayName(int dipslayIndex):const char*
GetNumDisplayModes(int displayIndex):int
GetNumVideoDisplays():int
GetNumVideoDrivers():int
GetVideoDriver(int index):const char*
GetWindowBrightness(SDL_Window* window):float
#GetWindowData(SDL_Window* window, const char* name)
GetWindowDisplayIndex(SDL_Window* window):error_number
GetWindowDisplayMode(SDL_Window* window, SDL_DisplayMode* mode):error
GetWindowFlags(SDL_Window* window):Uint32
GetWindowFromID(Uint32 id):SDL_Window*
GetWindowGammaRamp(SDL_Window* window, Uint16* #red, Uint16* #green, Uint16* #blue):error
GetWindowGrab(SDL_Window* window):SDL_bool
GetWindowID(SDL_Window* window):Uint32
GetWindowMaximumSize(SDL_Window* window, int* #w, int* #h)
GetWindowMinimumSize(SDL_Window* window, int* #w, int* #h)
GetWindowPixelFormat(SDL_Window* window):Uint32
GetWindowPosition(SDL_Window* window, int* #x, int* #y)
GetWindowSize(SDL_Window*window, int* #w, int* #h)
GetWindowSurface(SDL_Window* window):SDL_Surface*
GetWindowTitle(SDL_Window* window):const char*
GetWindowWMInfo(SDL_Window* window, SDL_SysWMinfo* #info):SDL_bool
HideWindow(SDL_Window* window)
IsScreenSaverEnabled():SDL_bool
MaximizeWindow(SDL_Window* window)
MinimizeWindow(SDL_Window* window)
RaiseWindow(SDL_Window* window)
ResotoreWindow(SDL_Window* window)
SetWindowBordered(SDL_Window* window, SDL_bool bordered)
SetWindowBrightness(SDL_Window* window, float brightness):error
#SetWindowData(SDL_Window* window, const char* name, void* #userdata)
SetWindowDisplayMode(SDL_Window* window, const SDL_DisplayMode* mode):error
SetWindowFullscreen(SDL_Window* window, Uint32 flags):error
SetWindowGammaRamp(SDL_Window* window, const Uint16* #red, const Uint16* #green, const Uint16* #blue):error
SetWindowGrab(SDL_Window* window, SDL_bool grabbed)
SetWindowHitTest(SDL_Window* window, SDL_HitTest #callback, void* #callback_data):error
SetWindowIcon(SDL_Window* window, SDL_Surface* icon)
SetWindowMaximumSize(SDL_Window* window, int max_w, int max_h)
SetWindowMinimumSize(SDL_Window* window, int min_w, int min_h)
SetWindowPosition(SDL_Window* window, int x, int y)
SetWindowSize(SDL_Window* window, int w, int h)
SetWindowTitle(SDL_Window* window, const char* title)
#ShowMessageBox(const SDL_MessageBoxData* #messageboxdata, int* #buttonid):error
ShowSimpleMessageBox(Uint32 flags, const char* title, const char* message, SDL_Window* window):error
ShowWindow(SDL_Window* window)
UpdateWindowSurface(SDL_Window* window):error
UpdateWindowSurfaceRects(SDL_Window* window, const SDL_Rect* rects, int #numrects):error
VideoInit(const char* driver_name):error
VideoQuit()
//-----------------------------------------------------------------------------
// Video - 2D Accelerated Rendering
CreateRenderer(SDL_Window* window, int index, Uint32 flags):SDL_Renderer*
CreateSoftwareRenderer(SDL_Surface* surface):SDL_Renderer*
CreateTexture(SDL_Renderer* renderer, Uint32 format, int access, int w, int h):SDL_Texture*
CreateTextureFromSurface(SDL_Renderer* renderer, SDL_Surface* surface):SDL_Texture*
CreateWindowAndRenderer(int width, int height, Uint32 window_flags, SDL_Window** #window, SDL_Renderer** #renderer):error
DestroyRenderer(SDL_Renderer* renderer)
DestroyTexture(SDL_Texture* texture)
GL_BindTexture(SDL_Texture* texture, float* #texw, float* #texh):error
GL_UnbindTexture(SDL_Texture* texture):error
GetNumRenderDrivers():int
GetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode* #blendMode):error
GetRenderDrawColor(SDL_Renderer* renderer, Uint8* #r, Uint8* #g, Uint8* #b, Uint8* #a)
GetRenderDriverInfo(int index, SDL_RendererInfo* #info):error
GetRenderTarget(SDL_Renderer* renderer) SDL_Texture*
GetRenderer(SDL_Window* window):SDL_Renderer*
GetRenderInfo(SDL_Renderer* renderer, SDL_RendererInfo* #info):error
GetRenderOutputSize(SDL_Renderer* renderer, int* #w, int* #h):error
GetTextureAlphaMod(SDL_Texture* texture, Uint8* #alpha):error
GetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode* #blendMode):error
GetTextureColorMod(SDL_Texture* texture, Uint8* #r, Uint8* #g, Uint8* #b):error
LockTexture(SDL_Texture* texture, const SDL_Rect* rect, void** #pixels, int* #pitch):error
QueryTexture(SDL_Texture* texture, Uint32* #format, int* #access, int* #w, int* #h):error
RenderClear(SDL_Renderer* renderer):error
RenderCopy(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_Rect* srcrect, const SDL_Rect* dstrect):error
RenderCopyEx(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_Rect* srcrect, const SDL_Rect* dstrect, double angle, const SDL_Point* center, SDL_RendererFlip flip):error
DrawLine(SDL_Renderer* renderer, int x1, int y1, int x2, int y2):error
DrawLines(SDL_Renderer* renderer, const SDL_Point* #points, int #count):error
DrawPoint(SDL_Renderer* renderer, int x, int y):error
DrawPoints(SDL_Renderer* renderer, const SDL_Point* #points, int #count):error
RenderDrawRect(SDL_Renderer* renderer, const SDL_Rect* rect):error
RenderDrawRects(SDL_Renderer* renderer, const SDL_Rect* #rects, int #count):error
RenderFillRect(SDL_Renderer* renderer, const SDL_Rect* rect):error
RenderFillRects(SDL_Renderer* renderer, const SDL_Rect* #rects, int #count):error
RenderGetClipRect(SDL_Renderer* renderer, SDL_Rect* #rect)
RenderGetLogicalSize(SDL_Renderer* renderer, int* #w, int* #h)
RenderGetScale(SDL_Renderer* renderer, float* #scaleX, float* #scaleY)
RenderGetViewport(SDL_Renderer* renderer, SDL_Rect* #rect)
RenderIsClipEnabled(SDL_Renderer* renderer):SDL_bool
RenderPresent(SDL_Renderer* renderer)
RenderReadPixels(SDL_Renderer* renderer, const SDL_Rect* rect, Uint32 format, void* #pixels, int pitch):error
RenderSetClipRect(SDL_Renderer* renderer, const SDL_Rect* rect):error
RenderSetLogicalSize(SDL_Renderer* renderer, int w, int h):error
RenderSetScale(SDL_Renderer* renderer, float scaleX, float scaleY):error
RenderSetViewport(SDL_Renderer* renderer, const SDL_Rect* rect):error
RenderTargetSupported(SDL_Renderer* renderer):SDL_bool
SetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode blendMode)
SetRenderDrawColor(SDL_Renderer* renderer, Uint8 r, Uint8 g, Uint8 b, Uint8 a):error
SetRenderTarget(SDL_Renderer* renderer, SDL_Texture *texture):error
SetTextureAlphaMod(SDL_Texture* texture, Uint8 alpha):error
SetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode blendMode):error
SetTextureColorMod(SDL_Texture* texture, Uint8 r, Uint8 g, Uint8 b):error
UnlockTexture(SDL_Texture* texture)
UpdateTexture(SDL_Texture* texture, const SDL_Rect* rect, const void* #pixels, int pitch):error
UpdateYUVTexture(SDL_Texture* texture, const SDL_Rect* rect, const Uint8* #Yplane, int #Ypitch, const Uint8* #Uplane, int #Upitch, const Uint8* #Vplane, int #Vpitch):error
//-----------------------------------------------------------------------------
// Video - Pixel Formats and Conversion Routines
AllocFormat(Uint32 pixel_format):SDL_PixelFormat*
AllocPalette(int ncolors):SDL_Palette*
CalculateGammaRamp(float gamma, Uint16* #ramp)
FreeFormat(SDL_PixelFormat* format)
FreePalette(SDL_Palette* palette)
GetPixelFormatName(Uint32 format):const char*
GetRGB(Uint32 pixel, const SDL_PixelFormat* format, Uint8* #r, Uint8* #g, Uint8* #b)
GetRGBA(Uint32 pixel, const SDL_PixelFormat* format, Uint8* #r, Uint8* #g, Uint8* #b, Uint8* #a)
MapRGB(const SDL_PixelFormat* format, Uint8 r, Uint8 g, Uint8 b):Uint32
MapRGBA(const SDL_PixelFormat* format, Uint8 r, Uint8 g, Uint8 b, Uint8 a):Uint32
MasksToPixelFormatEnum(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):Uint32
PixelFormatEnumToMasks(Uint32 format, int* #bpp, Uint32* #Rmask, Uint32* #Gmask, Uint32* #Bmask, Uint32* #Amask):SDL_bool
SetPaletteColors(SDL_Palette* palette, const SDL_Color* #colors, int firstcolor, int #ncolors):error
SetPixelFormatPalette(SDL_PixelFormat* format, SDL_Palette* palette):error
//-----------------------------------------------------------------------------
// Video - Rectangle Functions
EnclosePoints(const SDL_Point* #points, int #count, const SDL_Rect* clip, SDL_Rect* #result):SDL_bool
HasIntersection(const SDL_Rect* A, const SDL_Rect* B):SDL_bool
IntersectRect(const SDL_Rect* A, const SDL_Rect* B, SDL_Rect* #result):SDL_bool
#IntersectRectAndLine(const SDL_Rect* rect, int X1, int Y1, int X2, int Y2):SDL_bool
PointInRect(const SDL_Point* p, const SDL_Rect* r):SDL_bool
RectEmpty(const SDL_Rect* r):SDL_bool
RectEquals(const SDL_Rect* a, const SDL_Rect* b):SDL_bool
UnionRect(const SDL_Rect* A, const SDL_Rect* B, SDL_Rect* #result)
//-----------------------------------------------------------------------------
// Video - Surface Creation and Simple Drawing
BlitScaled(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface*dst, SDL_Rect* dstrect):error
BlitSurface(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface*dst, SDL_Rect* dstrect):error
ConvertPixels(int width, int height, Uint32 src_format, const void* #src, int #src_pitch, Uint32 dst_format, void* #dst, int #dst_pitch):error
ConvertSurface(SDL_Surface* src, const SDL_PixelFormat* fmt, Uint32 flags):SDL_Surface*
ConvertSurfaceFormat(SDL_Surface* src, Uint32 pixel_format, Uint32 flags):SDL_Surface*
CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):SDL_Surface*
CreateRGBSurfaceFrom(void* #pixels, int width, int height, int depth, int pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask):SDL_Surface*
FillRect(SDL_Surface* dst, const SDL_Rect* rect, Uint32 color):error
FillRects(SDL_Surface* dst, const SDL_Rect* #rects, int #count, Uint32 color):error
FreeSurface(SDL_Surface* surface)
GetClipRect(SDL_Surface* surface, SDL_Rect* rect)
GetColorKey(SDL_Surface* surface, Uint32* #key):error
GetSurfaceAlphaMod(SDL_Surface* surface, Uint8* #alpha):error
GetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode* #blendMode):error
GetSurfaceColorMod(SDL_Surface* surface, Uint8* #r, Uint8* #g, Uint8* #b):error
LoadBMP(const char* file):SDL_Surface*
LoadBMP_RW(SDL_RWops* src, int freesrc):SDL_Surface*
LockSurface(SDL_Surface* surface):error
LowerBlit(SDL_Surface* src, SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect):error
LowerBlitScaled(SDL_Surface* src, SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect):error
MUSTLOCK(SDL_Surface* surface):SDL_bool
SaveBMP(SDL_Surface* surface, const char* file):error
SaveBMP_RW(SDL_Surface* surface, SDL_RWops* dst, int freedst):error
SetClipRect(SDL_Surface* surface, const SDL_Rect* rect):SDL_bool
SetColorKey(SDL_Surface* surface, int flag, Uint32 key):error
SetSurfaceAlphaMod(SDL_Surface* surface, Uint8 alpha):error
SetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode blendMode):error
SetSurfaceColorMod(SDL_Surface* surface, Uint8 r, Uint8 g, Uint8 b):error
SetSurfacePalette(SDL_Surface* surface, SDL_Palette* palette):error
SetSurfaceRLE(SDL_Surface* surface, int flag):error
UnlockSurface(SDL_Surface* surface)
//-----------------------------------------------------------------------------
// Video - Platform-specific Window Management
GetWindowWMInfo(SDL_Window* window, SDL_SysWMinfo* #info):SDL_bool
//-----------------------------------------------------------------------------
// Video - Clipboard Handling
#GetClipboardText():char*
HasClipboardText():SDL_bool
SetClipboardText(const char* text):error
//-----------------------------------------------------------------------------
// Input Events - Event Handling
#AddEventWatch()
#DelEventWatch()
EventState(Uint32 type, int state):Uint8
#FilterEvents()
FlushEvent(Uint32 type)
FlushEvents(Uint32 minType, Uint32 maxType)
#GetEventFilter()
GetNumTouchDevices():int
GetNumTouchFingers(SDL_TouchID touchId):int
GetTouchDevice(int index):SDL_TouchID
GetTouchFinger(SDL_TouchID touchId, int index):SDL_Finger*
HasEvent(Uint32 type):SDL_bool
HasEvents(Uint32 minType, Uint32 maxType):SDL_bool
LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops* src):error_number
PeepEvents(SDL_Event* #events, int #numevents, SDL_eventaction action, Uint32 minType, Uint32 maxType):error
PollEvent(SDL_Event* #event):int
PumpEvents()
PushEvent(SDL_Event* event):error_number
QuitRequested():SDL_bool
RecordGesture(SDL_TouchID touchId):error
RegisterEvents(int numevents):Uint32
SaveAllDollarTemplates(SDL_RWops* dst):error
SaveDollarTemplate(SDL_GestureID gestureId, SDL_RWops* dst):error
#SetEventFilter()
WaitEvent(SDL_Event* #event):error
WaitEventTimeout(SDL_Event* #event, int timeout):error
//-----------------------------------------------------------------------------
// Input Events - Keyboard Support
GetKeyFromName(const char* name):SDL_Keycode
GetKeyFromScancode(SDL_Scancode scancode):SDL_Keycode
GetKeyName(SDL_Keycode key):const char*
GetKeyboardFocus():SDL_Window*
#GetKeyboardState(int* #numkeys):const Uint8*
GetModState():SDL_Keymod
GetScancodeFromKey(SDL_Keycode key):SDL_Scancode
GetScancodeFromName(const char* name):SDL_Scancode
GetScancodeName(SDL_Scancode scancode):const char*
HasScreenKeyboardSupport():SDL_bool
IsScreenKeyboardShown(SDL_Window* window):SDL_bool
IsTextInputActive():SDL_bool
SetModState(SDL_Keymod modstate)
SetTextInputRect(SDL_Rect* rect)
StartTextInput()
StopTextInput()
//-----------------------------------------------------------------------------
// Input Events - Mouse Support
CaptureMouse(SDL_bool enalbed):error
CreateColorCursor(SDL_Surface* surface, int hot_x, int hot_y):SDL_Cursor*
CreateCursor(const Uint8* #data, const Uint8* mask, int w, int h, int hot_x, int hot_y):SDL_Cursor*
CreateSystemCursor(SDL_SystemCursor id):SDL_Cursor*
FreeCursor(SDL_Cursor* cursor)
GetCursor():SDL_Cursor*
GetDefaultCursor():SDL_Cursor*
GetGlobalMouseState(int* #x, int* #y):Uint32
GetMouseFocus():SDL_Window*
GetMouseState(int* #x, int* #y):Uint32
GetRelativeMouseMode():SDL_bool
GetRelativeMouseState(int* #x, int* #y):Uint32
SetCursor(SDL_Cursor* cursor)
SetRelativeMouseMode(SDL_bool enabled):error
ShowCursor(int toggle):error
WarpMouseGlobal(int x, int y)
WarpMouseInWindow(SDL_Window* window, int x, int y)
//-----------------------------------------------------------------------------
// Input Events - Joystick Support
JoystickClose(SDL_Joystick* joystick)
JoystickEventState(int state):error_number
JoystickGetAttached(SDL_Joystick* joystick):SDL_bool
JoystickGetAxis(SDL_Joystick* joystick, int axis):Sint16
JoystickGetBall(SDL_Joystick* joystick, int ball, int* #dx, int* #dy):error
JoystickGetButton(SDL_Joystick* joystick, int button):Uint8
#JoystickGetDeviceGUID(int device_index):int
#JoystickGetGUID(SDL_Joystick* joystick):int
#JoystickGetGUIDFromString(const char* pchGUID):int
#JoystickGetGUIDString()
JoystickGetHat(SDL_Joystick* joystick, int hat):Uint8
JoystickInstanceID(SDL_Joystick* joystick):SDL_JoystickID
JoystickName(SDL_Joystick* joystick):const char*
JoystickNameForIndex(int device_index):const char*
JoystickNumAxes(SDL_Joystick* joystick):error_number
JoystickNumBalls(SDL_Joystick* joystick):error_number
JoystickNumButtons(SDL_Joystick* joystick):error_number
JoystickNumHats(SDL_Joystick* joystick):error_number
JoystickOpen(int device_index):SDL_Joystick*
JoystickUpdate()
NumJoysticks():error_number
//-----------------------------------------------------------------------------
// Input Events - Game Controller Support
GameControllerAddMapping(const char* mappingString):error_number
GameControllerAddMappingsFromFile(const char* filename):error_number
GameControllerAddMappingsFromRW(SDL_RWops* rw, int freerw):error_number
GameControllerClose(SDL_GameController* gamecontroller)
GameControllerEventState(int state):int
GameControllerGetAttached(SDL_GameController* gamecontroller):SDL_bool
GameControllerGetAxis(SDL_GameController* gamecontroller, SDL_GameControllerAxis axis):Sint16
GameControllerGetAxisFromString(const char* pchString):SDL_GameControllerAxis
GameControllerGetBindForAxis(SDL_GameController* gamecontroller, SDL_GameControllerAxis axis):SDL_GameControllerButtonBind
GameControllerGetBindForButton(SDL_GameController* gamecontroller, SDL_GameControllerButton button):SDL_GameControllerButtonBind
GameControllerGetButton(SDL_GameController* gamecontroller, SDL_GameControllerButton button):Uint8
GameControllerGetButtonFromString(const char* pchString):SDL_GameControllerButton
GameControllerGetJoystick(SDL_GameController* gamecontroller):SDL_Joystick*
GameControllerGetStringForAxis(SDL_GameControllerAxis axis):const char*
GameControllerGetStringForButton(SDL_GameControllerButton button):const char*
GameControllerMapping(SDL_GameController* gamecontroller):const char*
#GameControllerMappingForGUID(int guid):const char*
GameControllerName(SDL_GameController* gamecontroller):const char*
GameControllerNameForIndex(int joystick_index):const char*
GameControllerOpen(int joystick_index):SDL_GameController*
GameControllerUpdate()
IsGameController(int joystick_index):SDL_bool
//-----------------------------------------------------------------------------
// Force Feedback - Force Feedback Support
''', text = R'''
HapticClose(SDL_Haptic* haptic)
HapticDestroyEffect(SDL_Haptic* haptic, int effect)
//HapticEffectSupported(SDL_Haptic* haptic, SDL_HapticEffect* effect)
HapticGetEffectStatus
HapticIndex
HapticName
HapticNewEffect
HapticNumAxes
HapticNumEffects
HapticNumEffectsPlaying
HapticOpen
HapticOpenFromJoystick
HapticOpenFromMouse
HapticOpend
HapticPause
HapticQuery
HapticRumbleInit
HapticRumblePlay
HapticRumbleStop
HapticRumbleSupported
HapticRunEffect
HapticSetAutocenter
HapticSetGain
HapticStopAll
HapticStopEffect
HapticUnpause
HapticUpdateEffect
JoystickIsHaptic
MouseIsHaptic
NumHaptics
''', R'''
//-----------------------------------------------------------------------------
// Audio - Audio Device Management, Playing and Recording
AudioInit
AudioQuit
BuildAudioCVT
ClearQueuedAudio
CloseAudio
CloseAudioDevice
AudioCVT#ConvertAudio
FreeWAV
GetAudioDeviceName
GetAudioDeviceStatus
GetAudioDriver
GetAudioStatus
GetCurrentAudioDriver
GetNumAudioDevices
GetNumAudioDrivers
GetQueuedAudioSize
LoadWAV
LoadWAV_RW
LockAudio
LockAudioDevice
MixAudio
MixAudioFormat
OpenAudio
OpenAudioDevice
PauseAudio
PauseAudioDevice
QueueAudio
UnlockAudio
UnlockAudioDevice
//-----------------------------------------------------------------------------
// Threads - Thread Management
CreateThread
DetachThread
GetThreadID
GetThreadName
GetThreadPriority
TLSCreate
TLSGet
TLSSet
ThreadID
WaitThread
//-----------------------------------------------------------------------------
// Threads - Thread Synchronization Primitives
CondBroadcast
CondSignal
CondWait
CondWaitTimeout
CreateCond
CreateMutex
CreateSemaphore
DestroyCond
DestroyMutex
DestroySemaphore
LockMutex
SemPost
SemTryWait
SemValue
SemWait
SemWaitTimeout
TryLockMutex
UnlockMutex
//-----------------------------------------------------------------------------
// Threads - Atomic Operations
AtomicAdd
AtomicCAS
AtomicCASPtr
AtomicDecRef
AtomicGet
AtomicGetPtr
AtomicIncRef
AtomicLock
AtomicSet
AtomicSetPtr
AtomicTryLock
AtomicUnlock
CompilerBarrier
//-----------------------------------------------------------------------------
// Timers - Timer Support
AddTimer
Delay
GetPerformanceCounter
GetPerformanceFrequency
GetTicks
RemoveTimer
TICKS_PASSED
//-----------------------------------------------------------------------------
// File Abstraction - Filesystem Paths
GetBasePath
GetPrefPath
//-----------------------------------------------------------------------------
// File Abstraction - File I/O Abstraction
AllocRW
FreeRW
RWFromConstMem
RWFromFP
RWFromFile
RWFromMem
RWclose
RWread
RWseek
RWtell
RWwrite
ReadBE16
ReadBE32
ReadBE64
ReadLE16
ReadLE32
ReadLE64
WriteBE16
WriteBE32
WriteBE64
WriteLE16
WriteLE32
WriteLE64
//-----------------------------------------------------------------------------
// Shared Object Support - Shared Object Loading and Function Lookup
//-----------------------------------------------------------------------------
// Platform and CPU Information - Platform Detection
//-----------------------------------------------------------------------------
// Platform and CPU Information - CPU Feature Detection
//-----------------------------------------------------------------------------
// Platform and CPU Information - Byte Order and Byte Swapping
//-----------------------------------------------------------------------------
// Platform and CPU Information - Bit Manipulation
//-----------------------------------------------------------------------------
// Power Management - Power Management Status
//-----------------------------------------------------------------------------
// Additional - Platform-specific functionality
//-----------------------------------------------------------------------------
// Additional - Other

'''

tmplImplementation = R'''
// sdl2.${fi.funcName}(${
	(fi.argsGura:*name + ':' + fi.argsGura:*GetFullTypeGura()).join(', ')
})${
	cond(fi.voidFlag, ':void', '')
}
Gura_DeclareFunction(${fi.funcName})
{
	${if (fi.voidFlag)}
	SetMode(RSLTMODE_Void, FLAG_None);
	${else}
	SetMode(RSLTMODE_Normal, FLAG_None);
	${end}
	${for (arg in fi.argsGura)}
	DeclareArg(env, "${arg.name}", VTYPE_${arg.typeGura}, OCCUR_Once, FLAG_None);
	${end}
	AddHelp(Gura_Symbol(en), Help::FMT_markdown,
	"");
}

Gura_ImplementFunction(${fi.funcName})
{
	${if (!fi.validFlag)}
#if 0
	${end}
	${argsCJoined = fi.argsC:*name.join(', '), -}
	${for (argC in fi.argsC) {|idx|}}
	${argC.typeC.sub(r'(\w)$', r'\1 ') + argC.name} = ${
		if (argC.typeC.endswith('*')) {
			format('args.IsValid(%d)? ', idx) + argC.GetArg(idx) + ' : NULL'
		} else {
			argC.GetArg(idx)
		}
	};
	${end}
	${if (!fi.rtnInfo)}
	::SDL_${fi.funcName}(${argsCJoined});
	return Value::Null;
	${elsif (fi.rtnInfo.typeC == 'error')}
	int rtn = ::SDL_${fi.funcName}(${argsCJoined});
	if (rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
	${elsif (fi.rtnInfo.typeC == 'error_number')}
	int rtn = ::SDL_${fi.funcName}(${argsCJoined});
	if (rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value(rtn);
	${else}
	${fi.rtnInfo.typeC.sub(r'(\w)$', r'\1 ')}rtn = ::SDL_${fi.funcName}(${argsCJoined});
	${if (fi.rtnInfo.typeC.endswith('*'))}
	if (rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	${end}
	return ${fi.rtnInfo.fmtReturn};
	${end}
	${if (!fi.validFlag)}
#endif
	SetError_NotImpFunction(sig, "${fi.funcName}");
	return Value::Null;
	${end}
}
'''.template()

tmplAssignment = R'''
	Gura_AssignFunction(${fi.funcName});
'''.template()

ArgInfo = struct(name:string, typeC:string,
				 moduleName:string:nil, typeGura:string:nil, fmtGetter:string:nil) {
	GetArg(idx:number) = format(this.fmtGetter, idx)
	GetFullTypeGura() = cond(this.moduleName,
							 this.moduleName + '.' + this.typeGura, this.typeGura)
}

ReturnInfo = struct(typeC:string, typeGura:string:nil, fmtReturn:string:nil) {
	
}

TypeConv = struct(moduleName:string:nil, typeGura:string, fmtGetter:string, fmtReturn:string)
typeConvDict = %{
	'char' => TypeConv(nil, 'number', 'args.GetChar(%d)', 'Value(rtn)')
	'int' => TypeConv(nil, 'number', 'args.GetInt(%d)', 'Value(rtn)')
	'short' => TypeConv(nil, 'number', 'args.GetShort(%d)', 'Value(rtn)')
	'float' => TypeConv(nil, 'number', 'args.GetFloat(%d)', 'Value(rtn)')
	'double' => TypeConv(nil, 'number', 'args.GetDouble(%d)', 'Value(rtn)')
	'Uint8' => TypeConv(nil, 'number', 'args.GetUChar(%d)', 'Value(rtn)')
	'Uint16' => TypeConv(nil, 'number', 'args.GetUShort(%d)', 'Value(rtn)')
	'Uint32' => TypeConv(nil, 'number', 'args.GetULong(%d)', 'Value(rtn)')
	'Sint8' => TypeConv(nil, 'number', 'args.GetChar(%d)', 'Value(rtn)')
	'Sint16' => TypeConv(nil, 'number', 'args.GetShort(%d)', 'Value(rtn)')
	'Sint32' => TypeConv(nil, 'number', 'args.GetLong(%d)', 'Value(rtn)')
	'char *' => TypeConv(nil, 'string', 'args.GetString(%d)', 'Value(rtn)')
	'const char *' => TypeConv(nil, 'string', 'args.GetString(%d)', 'Value(rtn)')
	'const Uint8 *' => TypeConv(nil, 'number', 'args.GetList(%d)', 'Value::Null')
	'SDL_GLContext' => TypeConv(nil, 'number', 'args.GetSizeT(%d)', 'Value(rtn)')
	'SDL_bool' => TypeConv(nil, 'boolean', 'args.GetBoolean(%d)', 'Value(rtn != 0)')
	'SDL_eventaction' => TypeConv(
			nil, 'number',
			'static_cast<SDL_eventaction>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GLattr' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GLattr>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_TouchID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_TouchID>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_JoystickID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_JoystickID>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GestureID' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GestureID>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_RendererFlip' => TypeConv(
			nil, 'number',
			'static_cast<SDL_RendererFlip>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_BlendMode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_BlendMode>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_Keycode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Keycode>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_Scancode' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Scancode>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_Keymod' => TypeConv(
			nil, 'number',
			'static_cast<SDL_Keymod>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_SystemCursor' => TypeConv(
			nil, 'number',
			'static_cast<SDL_SystemCursor>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GameControllerAxis' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GameControllerAxis>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GameControllerButton' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GameControllerButton>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_GameControllerButtonBind' => TypeConv(
			nil, 'number',
			'static_cast<SDL_GameControllerButtonBind>(args.GetInt(%d))',
			'Value(rtn)')
	'SDL_Finger *' => TypeConv(
			'sdl2', 'Finger',
			'Object_Finger::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Finger(rtn))')
	'SDL_Event *' => TypeConv(
			'sdl2', 'Event',
			'Object_Event::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Event(rtn))')
	'SDL_Rect *' => TypeConv(
			'sdl2', 'Rect',
			'Object_Rect::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Rect(rtn))')
	'SDL_Point *' => TypeConv(
			'sdl2', 'Point',
			'Object_Point::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Point(rtn))')
	'const SDL_Rect *' => TypeConv(
			'sdl2', 'Rect',
			'Object_Rect::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Rect(rtn))')
	'const SDL_Point *' => TypeConv(
			'sdl2', 'Point',
			'Object_Point::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Point(rtn))')
	'SDL_Window *' => TypeConv(
			'sdl2', 'Window',
			'Object_Window::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Window(rtn))')
	'SDL_Surface *' => TypeConv(
			'sdl2', 'Surface',
			'Object_Surface::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Surface(rtn))')
	'SDL_RWops *' => TypeConv(
			'sdl2', 'RWops',
			'Object_RWops::GetObject(args, %d)->GetEntity()',
			'Value(new Object_RWops(rtn))')
	'SDL_Renderer *' => TypeConv(
			'sdl2', 'Renderer',
			'Object_Renderer::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Renderer(rtn))')
	'SDL_Texture *' => TypeConv(
			'sdl2', 'Texture',
			'Object_Texture::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Texture(rtn))')
	'SDL_SysWMinfo *' => TypeConv(
			'sdl2', 'SysWMinfo',
			'Object_SysWMinfo::GetObject(args, %d)->GetEntity()',
			'Value(new Object_SysWMinfo(rtn))')
	'SDL_PixelFormat *' => TypeConv(
			'sdl2', 'PixelFormat',
			'Object_PixelFormat::GetObject(args, %d)->GetEntity()',
			'Value(new Object_PixelFormat(rtn))')
	'const SDL_PixelFormat *' => TypeConv(
			'sdl2', 'PixelFormat',
			'Object_PixelFormat::GetObject(args, %d)->GetEntity()',
			'Value(new Object_PixelFormat(rtn))')
	'SDL_Palette *' => TypeConv(
			'sdl2', 'Palette',
			'Object_Palette::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Palette(rtn))')
	'SDL_Cursor *' => TypeConv(
			'sdl2', 'Cursor',
			'Object_Cursor::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Cursor(rtn))')
	'SDL_Joystick *' => TypeConv(
			'sdl2', 'Joystick',
			'Object_Joystick::GetObject(args, %d)->GetEntity()',
			'Value(new Object_Joystick(rtn))')
	'SDL_GameController *' => TypeConv(
			'sdl2', 'GameController',
			'Object_GameController::GetObject(args, %d)->GetEntity()',
			'Value(new Object_GameController(rtn))')
	'SDL_DisplayMode *' => TypeConv(
			'sdl2', 'DisplayMode',
			'Object_DisplayMode::GetObject(args, %d)->GetEntity()',
			'Value(new Object_DisplayMode(rtn))')
	'const SDL_DisplayMode *' => TypeConv(
			'sdl2', 'DisplayMode',
			'Object_DisplayMode::GetObject(args, %d)->GetEntity()',
			'Value(new Object_DisplayMode(rtn))')
}

FuncInfo = class {
	public {
		funcName, argsC, argsGura, rtnInfo, validFlag, voidFlag
	}
	__init__(lineNo:number, funcName:string, argsRaw:string:nil, rtnRaw:string:nil) = {
		this.argsRaw = argsRaw
		this.validFlag = this.argsRaw?
		if (funcName.startswith('#')) {
			this.funcName = funcName.replace('#', '')
			this.validFlag = false
		} else {
			this.funcName = funcName
		}
		this.rtnRaw = rtnRaw
		this.argsC = []
		this.argsGura = []
		this.rtnInfo = nil
		this.voidFlag = false
		if (this.argsRaw) {
			this.argsC = this.argsRaw.split(',').each():xlist {|argRaw|
				argRaw = argRaw.strip()
				argRaw.isempty() && continue
				if (m = argRaw.match(r'^(\w+)\s+(#?\w+)$')) {
					[typeC, name] = m[1, 2]
				} elsif (m = argRaw.match(r'^(\w+)\s*(\*+)\s*(#?\w+)$')) {
					[typeC, name] = [m[1] + ' ' + m[2], m[3]]
				} elsif (m = argRaw.match(r'^const\s+(\w+)\s*(\*+)\s*(#?\w+)$')) {
					[typeC, name] = ['const ' + m[1] + ' ' + m[2], m[3]]
				} else {
					sys.stderr.printf('%d: invalid argument "%s"\n', lineNo, argRaw)
					sys.exit(1)
				}
				if (name.startswith('#')) {
					this.validFlag = false
					ArgInfo(name.replace('#', ''), typeC, nil, nil, 'NULL')
				} else {
					typeConv = typeConvDict.get(typeC)
					if (!typeConv) {
						sys.stderr.printf(
								'%d: proper conversion not found in table "%s"\n',
								lineNo, argRaw)
						sys.exit(1)
					}
					ArgInfo(name, typeC, typeConv.moduleName,
							typeConv.typeGura, typeConv.fmtGetter)
				}
			}
		}
		if (!this.rtnRaw) {
			// nothing to do
		} elsif (this.rtnRaw == 'error') {
			this.rtnInfo = ReturnInfo('error', nil, nil)
		} elsif (this.rtnRaw == 'error_number') {
			this.rtnInfo = ReturnInfo('error_number', nil, nil)
		} else {
			if (m = rtnRaw.match(r'^(\w+)$')) {
				typeC = m[1]
			} elsif (m = rtnRaw.match(r'^(\w+)\s*\*\s*$')) {
				typeC = m[1] + ' *'
			} elsif (m = rtnRaw.match(r'^const\s+(\w+)\s*\*\s*$')) {
				typeC = 'const ' + m[1] + ' *'
			} else {
				sys.stderr.printf('%d: invalid return type "%s"\n', lineNo, rtnRaw)
				sys.exit(1)
			}
			typeConv = typeConvDict.get(typeC)
			if (!typeConv) {
				sys.stderr.printf('%d: invalid return type "%s"\n', lineNo, rtnRaw)
				sys.exit(1)
			}
			this.rtnInfo = ReturnInfo(typeC, typeConv.typeGura, typeConv.fmtReturn)
		}
		this.argsGura = this.argsC.filter(this.argsC:*typeGura):list
		this.voidFlag = (!this.rtnInfo || this.rtnInfo.typeC == 'error')
	}
	RenderImplementation(stream:stream) = {
		fi = this
		tmplImplementation.render(stream)
	}
	RenderAssignment(stream:stream) = {
		fi = this
		tmplAssignment.render(stream)
	}
}

funcInfos = []
text.eachline {|line, i|
	line = line.strip()
	(line.startswith('//') || line.isempty()) && continue
	lineNo = i + 1
	restPart = line
	fields = restPart.split(':')
	argsRaw = nil
	rtnRaw = nil
	if (fields.len() > 1) {
		[restPart, rtnRaw] = fields
	}
	if (m = restPart.match(r'(.*)\(([^\)]*)\)')) {
		[restPart, argsRaw] = m[1, 2]
	}
	if (m = restPart.match(r'^(#?\w+)$')) {
		funcName = m[1]
		if (funcInfos:*funcName.find(funcName)) {
			sys.stderr.printf('%d: duplicated function %s\n', lineNo, funcName)
			sys.exit(1)
		}
		funcInfos.add(FuncInfo(lineNo, funcName, argsRaw, rtnRaw))
	} else {
		sys.stderr.printf('%d: invalid format\n', lineNo)
		sys.exit(1)
	}
}

println('--------')
funcInfos.each {|funcInfo|
	funcInfo.RenderImplementation(sys.stdout)
	println()
}
println('--------')
funcInfos.each {|funcInfo|
	funcInfo.RenderAssignment(sys.stdout)
}
