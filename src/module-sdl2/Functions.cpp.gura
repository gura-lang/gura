#!/usr/bin/env gura
import(re)

decls = `{
//-----------------------------------------------------------------------------
// Basics - Initialization and Shutdown

SDL_Init(flags:Uint32):negerr = `auto

SDL_InitSubSystem(flags:Uint32):negerr = `auto

SDL_Quit():void = `auto

SDL_QuitSubSystem(flags:Uint32):void = `auto

SDL_SetMainReady():void = `auto

SDL_WasInit(flags:Uint32):Uint32 {block?} = `auto

//-----------------------------------------------------------------------------
// Basics - Configuration Variables

SDL_AddHintCallback() = `unsupport

SDL_ClearHints() = `unsupport

SDL_DelhintCallback() = `unsupport

SDL_GetHint() = `unsupport

SDL_SetHint() = `unsupport

SDL_SetHintWithPriority() = `unsupport

//-----------------------------------------------------------------------------
// Basics - Error Handling

SDL_ClearError():void = `auto

SDL_GetError():char@:const {block?} = `auto

SDL_SetError() = `unsupport

//-----------------------------------------------------------------------------
// Basics - Log Handling

SDL_Log() = `unsupport

SDL_LogCritical() = `unsupport

SDL_LogDebug() = `unsupport

SDL_LogError() = `unsupport

SDL_LogGetOutputFunction() = `unsupport

SDL_LogGetPriority() = `unsupport

SDL_LogInfo() = `unsupport

SDL_LogMessage() = `unsupport

SDL_LogMessageV() = `unsupport

SDL_LogResetPriorities() = `unsupport

SDL_LogSetAllPriority() = `unsupport

SDL_LogSetOutputFunction() = `unsupport

SDL_LogSetPriority() = `unsupport

SDL_LogVerbose() = `unsupport

SDL_LogWarn() = `unsupport

//-----------------------------------------------------------------------------
// Basics - Assertions

SDL_GetAssertionHandler() = `unsupport

SDL_GetAssertionReport() = `unsupport

SDL_GetDefaultAssertionHandler() = `unsupport

SDL_ResetAssertionReport() = `unsupport

SDL_SetAssertionHandler() = `unsupport

SDL_TriggerBreakpoint() = `unsupport

SDL_assert() = `unsupport

SDL_assert_paranoid() = `unsupport

SDL_assert_release() = `unsupport

SDL_GetRevision():char@:const {block?} = `auto

SDL_GetRevisionNumber():int {block?} = `auto

//-----------------------------------------------------------------------------
// Basics - Querying SDL Version

SDL_GetVersion() {block?} = R'''
	SDL_version ver;
	SDL_GetVersion(&ver);
	return ReturnValue(env, sig, args, Value::CreateList(env,
					Value(ver.major), Value(ver.minor), Value(ver.patch)));
'''

SDL_VERSION() {block?} = R'''
	SDL_version ver;
	SDL_VERSION(&ver);
	return ReturnValue(env, sig, args, Value::CreateList(env,
					Value(ver.major), Value(ver.minor), Value(ver.patch)));
'''

SDL_VERSION_ATLEAST(X:int, Y:int, Z:int):bool {block?} = `auto

//-----------------------------------------------------------------------------
// Video - Display and Window Management

SDL_CreateWindow(title:char@:const, x:int, y:int, w:int, h:int, flags:Uint32):SDL_Window@ {block?} = `auto

SDL_CreateWindowAndRenderer(width:int, height:int, window_flags:Uint32) {block?} = R'''
	SDL_Window *window = NULL;
	SDL_Renderer *renderer = NULL;
	int _rtn = SDL_CreateWindowAndRenderer(width, height, window_flags, &window, &renderer);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
			Value(new Object_Window(window)), Value(new Object_Renderer(renderer))));
'''

SDL_CreateWindowFrom() = `unsupport

SDL_DestroyWindow(window:SDL_Window@):void = `auto

SDL_DisableScreenSaver():void = `auto

SDL_EnableScreenSaver():void = `auto

SDL_GL_CreateContext(window:SDL_Window@) {block?} = R'''
	SDL_GLContext _rtn = SDL_GL_CreateContext(window);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_GLContext(_rtn)));
'''

SDL_GL_DeleteContext(context:SDL_GLContext):void = `auto

SDL_GL_ExtensionSupported(extension:char@:const):SDL_bool {block?} = `auto

SDL_GL_GetAttribute(attr:SDL_GLattr) {block?} = R'''
	int value = 0;
	int _rtn = SDL_GL_GetAttribute(attr, &value);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(value));
'''

SDL_GL_GetCurrentContext() {block?} = R'''
	SDL_GLContext _rtn = SDL_GL_GetCurrentContext();
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_GLContext(_rtn)));
'''

SDL_GL_GetCurrentWindow():SDL_Window@ {block?} = `auto

SDL_GL_GetDrawableSize(window:SDL_Window@) {block?} = R'''
	int w = 0;
	int h = 0;
	SDL_GL_GetDrawableSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GL_GetProcAddress() = `unsupport

SDL_GL_GetSwapInterval():negerr_boolean {block?} = `auto

SDL_GL_LoadLibrary(path:char@:const):negerr = `auto

SDL_GL_MakeCurrent(window:SDL_Window@, context:SDL_GLContext):negerr = `auto

SDL_GL_ResetAttributes():void = `auto

SDL_GL_SetAttribute(attr:SDL_GLattr, value:int):negerr = `auto

SDL_GL_SetSwapInterval(interval:int):negerr = `auto

SDL_GL_SwapWindow(window:SDL_Window@):void = `auto

SDL_GL_UnloadLibrary():void = `auto

SDL_GetClosestDisplayMode(displayIndex:int, mode:SDL_DisplayMode@:const) {block?} = R'''
	SDL_DisplayMode closest;
	SDL_DisplayMode *_rtn = SDL_GetClosestDisplayMode(displayIndex, mode, &closest);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(closest)));
'''

SDL_GetCurrentDisplayMode(displayIndex:int) {block?} = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetCurrentDisplayMode(displayIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

SDL_GetCurrentVideoDriver():char@:const {block?} = `auto

SDL_GetDesktopDisplayMode(displayIndex:int) {block?} = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetDesktopDisplayMode(displayIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

SDL_GetDisplayBounds(displayIndex:int) {block?} = R'''
	SDL_Rect rect;
	int _rtn = SDL_GetDisplayBounds(displayIndex, &rect);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

SDL_GetDisplayMode(displayIndex:int, modeIndex:int) {block?} = R'''
	SDL_DisplayMode mode;
	int _rtn = SDL_GetDisplayMode(displayIndex, modeIndex, &mode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_DisplayMode(mode)));
'''

SDL_GetDisplayName(dipslayIndex:int):char@:const {block?} = `auto

SDL_GetNumDisplayModes(displayIndex:int):negerr_number {block?} = `auto

SDL_GetNumVideoDisplays():negerr_number {block?} = `auto

SDL_GetNumVideoDrivers():negerr_number {block?} = `auto

SDL_GetVideoDriver(index:int):char@:const {block?} = `auto

SDL_GetWindowBrightness(window:SDL_Window@):float {block?} = `auto

SDL_GetWindowData(window:SDL_Window@, name:char@:const) = `unsupport

SDL_GetWindowDisplayIndex(window:SDL_Window@):negerr_number {block?} = `auto

SDL_GetWindowDisplayMode(window:SDL_Window@, mode:SDL_DisplayMode@):negerr = `auto

SDL_GetWindowFlags(window:SDL_Window@):Uint32 {block?} = `auto

SDL_GetWindowFromID(id:Uint32):SDL_Window@ {block?} = `auto

SDL_GetWindowGammaRamp(window:SDL_Window@) {block?} = R'''
	Uint16 red = 0;
	Uint16 green = 0;
	Uint16 blue = 0;
	int _rtn = SDL_GetWindowGammaRamp(window, &red, &green, &blue);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
								Value(red), Value(green), Value(blue)));
'''

SDL_GetWindowGrab(window:SDL_Window@):SDL_bool {block?} = `auto

SDL_GetWindowID(window:SDL_Window@):Uint32 {block?} = `auto

SDL_GetWindowMaximumSize(window:SDL_Window@) {block?} = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowMaximumSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GetWindowMinimumSize(window:SDL_Window@) {block?} = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowMinimumSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GetWindowPixelFormat(window:SDL_Window@) {block?} = R'''
	Uint32 _rtn = SDL_GetWindowPixelFormat(window);
	if (_rtn == SDL_PIXELFORMAT_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetWindowPosition(window:SDL_Window@) {block?} = R'''
	int x = 0;
	int y = 0;
	SDL_GetWindowPosition(window, &x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(x), Value(y)));
'''

SDL_GetWindowSize(window:SDL_Window@) {block?} = R'''
	int w = 0;
	int h = 0;
	SDL_GetWindowSize(window, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GetWindowSurface(window:SDL_Window@):SDL_Surface@ {block?} = `auto

SDL_GetWindowTitle(window:SDL_Window@):char@:const {block?} = `auto

SDL_GetWindowWMInfo(window:SDL_Window@) = `unsupport

SDL_HideWindow(window:SDL_Window@):void = `auto

SDL_IsScreenSaverEnabled():SDL_bool {block?} = `auto

SDL_MaximizeWindow(window:SDL_Window@):void = `auto

SDL_MinimizeWindow(window:SDL_Window@):void = `auto

SDL_RaiseWindow(window:SDL_Window@):void = `auto

SDL_RestoreWindow(window:SDL_Window@):void = `auto

SDL_SetWindowBordered(window:SDL_Window@, bordered:SDL_bool):void = `auto

SDL_SetWindowBrightness(window:SDL_Window@, brightness:float):negerr = `auto

SDL_SetWindowData(window:SDL_Window@, name:char@:const) = `unsupport

SDL_SetWindowDisplayMode(window:SDL_Window@, mode:SDL_DisplayMode@:const):negerr = `auto

SDL_SetWindowFullscreen(window:SDL_Window@, flags:Uint32):negerr = `auto

SDL_SetWindowGammaRamp(window:SDL_Window@, red[]:Uint16, green[]:Uint16, blue[]:Uint16):void = R'''
	if (red.GetSize() != 256 || green.GetSize() != 256 || blue.GetSize() != 256) {
		sig.SetError(ERR_ValueError, "red, green and blue must have 256 elements");
		return Value::Null;
	}
	int _rtn = SDL_SetWindowGammaRamp(window, red, green, blue);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_SetWindowGrab(window:SDL_Window@, grabbed:SDL_bool):void = `auto

SDL_SetWindowHitTest(window:SDL_Window@):negerr = `unsupport

SDL_SetWindowIcon(window:SDL_Window@, icon:SDL_Surface@):void = `auto

SDL_SetWindowMaximumSize(window:SDL_Window@, max_w:int, max_h:int):void = `auto

SDL_SetWindowMinimumSize(window:SDL_Window@, min_w:int, min_h:int):void = `auto

SDL_SetWindowPosition(window:SDL_Window@, x:int, y:int):void = `auto

SDL_SetWindowSize(window:SDL_Window@, w:int, h:int):void = `auto

SDL_SetWindowTitle(window:SDL_Window@, title:char@:const):void = `auto

SDL_ShowMessageBox():negerr = `unsupport

SDL_ShowSimpleMessageBox(flags:Uint32, title:char@:const, message:char@:const, window:SDL_Window@):negerr = `auto

SDL_ShowWindow(window:SDL_Window@):void = `auto

SDL_UpdateWindowSurface(window:SDL_Window@):negerr = `auto

SDL_UpdateWindowSurfaceRects(window:SDL_Window@, rects[]:SDL_Rect):void = R'''
	int numrects = static_cast<int>(rects.GetSize());
	int _rtn = SDL_UpdateWindowSurfaceRects(window, rects, numrects);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_VideoInit(driver_name:char@:const):negerr = `auto

SDL_VideoQuit():void = `auto

//-----------------------------------------------------------------------------
// Video - 2D Accelerated Rendering

SDL_CreateRenderer(window:SDL_Window@, index:int, flags:Uint32):SDL_Renderer@ {block?} = `auto

SDL_CreateSoftwareRenderer(surface:SDL_Surface@):SDL_Renderer@ {block?} = `auto

SDL_CreateTexture(renderer:SDL_Renderer@, format:Uint32, access:int, w:int, h:int):SDL_Texture@ {block?} = `auto

SDL_CreateTextureFromSurface(renderer:SDL_Renderer@, surface:SDL_Surface@):SDL_Texture@ {block?} = `auto

SDL_DestroyRenderer(renderer:SDL_Renderer@):void = `auto

SDL_DestroyTexture(texture:SDL_Texture@):void = `auto

SDL_GL_BindTexture(texture:SDL_Texture@) {block?} = R'''
	float texw = 0;
	float texh = 0;
	SDL_GL_BindTexture(texture, &texw, &texh);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(texw), Value(texh)));
'''

SDL_GL_UnbindTexture(texture:SDL_Texture@):negerr = `auto

SDL_GetNumRenderDrivers():negerr_number {block?} = `auto

SDL_GetRenderDrawBlendMode(renderer:SDL_Renderer@) {block?} = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetRenderDrawBlendMode(renderer, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

SDL_GetRenderDrawColor(renderer:SDL_Renderer@) {block?} = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	Uint8 a = 0;
	int _rtn = SDL_GetRenderDrawColor(renderer, &r, &g, &b, &a);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
								Value(r), Value(g), Value(b), Value(a)));
'''

SDL_GetRenderDriverInfo(index:int) {block?} = R'''
	SDL_RendererInfo info;
	int _rtn = SDL_GetRenderDriverInfo(index, &info);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_RendererInfo(info)));
'''

SDL_GetRenderTarget(renderer:SDL_Renderer@) {block?} = R'''
	SDL_Texture *_rtn = SDL_GetRenderTarget(renderer);
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = Value(new Object_Texture(_rtn));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetRenderer(window:SDL_Window@):SDL_Renderer@ {block?} = `auto

SDL_GetRendererInfo(renderer:SDL_Renderer@) {block?} = R'''
	SDL_RendererInfo info;
	int _rtn = SDL_GetRendererInfo(renderer, &info);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_RendererInfo(info)));
'''

SDL_GetRenderOutputSize(renderer:SDL_Renderer@) {block?} = R'''
	int w = 0;
	int h = 0;
	int _rtn = SDL_GetRendererOutputSize(renderer, &w, &h);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_GetTextureAlphaMod(texture:SDL_Texture@) {block?} = R'''
	Uint8 alpha = 0;
	int _rtn = SDL_GetTextureAlphaMod(texture, &alpha);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(alpha));
'''

SDL_GetTextureBlendMode(texture:SDL_Texture@) {block?} = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetTextureBlendMode(texture, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

SDL_GetTextureColorMod(texture:SDL_Texture@) {block?} = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	int _rtn = SDL_GetTextureColorMod(texture, &r, &g, &b);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
											Value(r), Value(g), Value(b)));
'''

SDL_LockTexture(texture:SDL_Texture@, rect:SDL_Rect@:const):negerr = `unsupport

SDL_QueryTexture(texture:SDL_Texture@) {block?} = R'''
	Uint32 format = 0;
	int access = 0;
	int w = 0;
	int h = 0;
	int _rtn = SDL_QueryTexture(texture, &format, &access, &w, &h);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env,
							Value(format), Value(access), Value(w), Value(h)));
'''

SDL_RenderClear(renderer:SDL_Renderer@):negerr = `auto

SDL_RenderCopy(renderer:SDL_Renderer@, texture:SDL_Texture@, srcrect:SDL_Rect@:const:nil, dstrect:SDL_Rect@:const:nil):negerr = `auto

SDL_RenderCopyEx(renderer:SDL_Renderer@, texture:SDL_Texture@, srcrect:SDL_Rect@:const:nil, dstrect:SDL_Rect@:const:nil, angle:double, center:SDL_Point@:const:nil, flip:SDL_RendererFlip):negerr = `auto

SDL_RenderDrawLine(renderer:SDL_Renderer@, x1:int, y1:int, x2:int, y2:int):negerr = `auto

SDL_RenderDrawLines(renderer:SDL_Renderer@, points[]:SDL_Point):void = R'''
	int count = static_cast<int>(points.GetSize());
	int _rtn = SDL_RenderDrawLines(renderer, points, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_RenderDrawPoint(renderer:SDL_Renderer@, x:int, y:int):negerr = `auto

SDL_RenderDrawPoints(renderer:SDL_Renderer@, points[]:SDL_Point):void = R'''
	int count = static_cast<int>(points.GetSize());
	int _rtn = SDL_RenderDrawPoints(renderer, points, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_RenderDrawRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr = `auto

SDL_RenderDrawRects(renderer:SDL_Renderer@, rects[]:SDL_Rect):void = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_RenderDrawRects(renderer, rects, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_RenderFillRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr = `auto

SDL_RenderFillRects(renderer:SDL_Renderer@, rects[]:SDL_Rect):void = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_RenderFillRects(renderer, rects, count);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_RenderGetClipRect(renderer:SDL_Renderer@) {block?} = R'''
	SDL_Rect rect;
	SDL_RenderGetClipRect(renderer, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

SDL_RenderGetLogicalSize(renderer:SDL_Renderer@) {block?} = R'''
	int w = 0;
	int h = 0;
	SDL_RenderGetLogicalSize(renderer, &w, &h);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(w), Value(h)));
'''

SDL_RenderGetScale(renderer:SDL_Renderer@) {block?} = R'''
	float scaleX = 0;
	float scaleY = 0;
	SDL_RenderGetScale(renderer, &scaleX, &scaleY);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(scaleX), Value(scaleY)));
'''

SDL_RenderGetViewport(renderer:SDL_Renderer@) {block?} = R'''
	SDL_Rect rect;
	SDL_RenderGetViewport(renderer, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

SDL_RenderIsClipEnabled(renderer:SDL_Renderer@):SDL_bool = `unsupport

SDL_RenderPresent(renderer:SDL_Renderer@):void = `auto

SDL_RenderReadPixels(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil, format:symbol) {block?} = R'''
	Uint32 _format = SDL_PIXELFORMAT_UNKNOWN;
	Image::Format fmtImage = Image::FORMAT_None;
	if (format->IsIdentical(Gura_Symbol(rgb))) {
		_format = SDL_PIXELFORMAT_BGR888;
		fmtImage = Image::FORMAT_RGB;
	} else if (format->IsIdentical(Gura_Symbol(rgba))) {
		_format = SDL_PIXELFORMAT_BGRA8888;
		fmtImage = Image::FORMAT_RGBA;
	} else {
		sig.SetError(ERR_ValueError, "format must be `rgb or `rgba");
		return Value::Null;
	}
	AutoPtr<Image> pImage(new Image(fmtImage));
	if (!pImage->AllocBuffer(sig, rect->w, rect->h, 0x00)) return Value::Null;
	void *pixels = pImage->GetBuffer();
	int pitch = pImage->GetBytesPerLine();
	int _rtn = SDL_RenderReadPixels(renderer, rect, _format, pixels, pitch);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_image(env, pImage.release())));
'''

SDL_RenderSetClipRect(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr = `auto

SDL_RenderSetLogicalSize(renderer:SDL_Renderer@, w:int, h:int):negerr = `auto

SDL_RenderSetScale(renderer:SDL_Renderer@, scaleX:float, scaleY:float):negerr = `auto

SDL_RenderSetViewport(renderer:SDL_Renderer@, rect:SDL_Rect@:const:nil):negerr = `auto

SDL_RenderTargetSupported(renderer:SDL_Renderer@):SDL_bool {block?} = `auto

SDL_SetRenderDrawBlendMode(renderer:SDL_Renderer@, blendMode:SDL_BlendMode):void = `auto

SDL_SetRenderDrawColor(renderer:SDL_Renderer@, r:Uint8, g:Uint8, b:Uint8, a:Uint8):negerr = `auto

SDL_SetRenderTarget(renderer:SDL_Renderer@, texture:SDL_Texture@:nil):negerr = `auto

SDL_SetTextureAlphaMod(texture:SDL_Texture@, alpha:Uint8):negerr = `auto

SDL_SetTextureBlendMode(texture:SDL_Texture@, blendMode:SDL_BlendMode):negerr = `auto

SDL_SetTextureColorMod(texture:SDL_Texture@, r:Uint8, g:Uint8, b:Uint8):negerr = `auto

SDL_UnlockTexture(texture:SDL_Texture@):void = `auto

SDL_UpdateTexture(texture:SDL_Texture@, rect:SDL_Rect@:const:nil, pitch:int):negerr = `unsupport

SDL_UpdateYUVTexture() = `unsupport

//-----------------------------------------------------------------------------
// Video - Pixel Formats and Conversion Routines

SDL_AllocFormat(pixel_format:Uint32):SDL_PixelFormat@ {block?} = `auto

SDL_AllocPalette(ncolors:int):SDL_Palette@ {block?} = `auto

SDL_CalculateGammaRamp(gamma:float) {block?} = R'''
	Uint16 ramp[256];
	SDL_CalculateGammaRamp(gamma, ramp);
	return ReturnValue(env, sig, args, Value::CreateList(env, ramp, ArraySizeOf(ramp)));
'''

SDL_FreeFormat(format:SDL_PixelFormat@):void = `auto

SDL_FreePalette(palette:SDL_Palette@):void = `auto

SDL_GetPixelFormatName(format:Uint32):char@:const {block?} = `auto

SDL_GetRGB(pixel:Uint32, format:SDL_PixelFormat@:const) {block?} = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	SDL_GetRGB(pixel, format, &r, &g, &b);
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(r), Value(g), Value(b)));
'''

SDL_GetRGBA(pixel:Uint32, format:SDL_PixelFormat@:const) {block?} = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	Uint8 a = 0;
	SDL_GetRGBA(pixel, format, &r, &g, &b, &a);
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(r), Value(g), Value(b), Value(a)));
'''

SDL_MapRGB(format:SDL_PixelFormat@:const, r:Uint8, g:Uint8, b:Uint8):Uint32 {block?} = `auto

SDL_MapRGBA(format:SDL_PixelFormat@:const, r:Uint8, g:Uint8, b:Uint8, a:Uint8):Uint32 {block?} = `auto

SDL_MasksToPixelFormatEnum(bpp:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32):Uint32 {block?} = `auto

SDL_PixelFormatEnumToMasks(format:Uint32) {block?} = R'''
	int bpp = 0;
	Uint32 Rmask = 0;
	Uint32 Gmask = 0;
	Uint32 Bmask = 0;
	Uint32 Amask = 0;
	SDL_bool _rtn = SDL_PixelFormatEnumToMasks(format, &bpp, &Rmask, &Gmask, &Bmask, &Amask);
	if (_rtn != SDL_TRUE) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(bpp), Value(Rmask), Value(Gmask), Value(Bmask), Value(Amask)));
'''

SDL_SetPaletteColors(palette:SDL_Palette@, colors[]:SDL_Color, firstcolor:int, ncolors:int):void = R'''
	int nmax = static_cast<int>(colors.GetSize());
	if (firstcolor + ncolors > nmax) {
		sig.SetError(ERR_IndexError, "out of range");
		return Value::Null;
	}
	int _rtn = SDL_SetPaletteColors(palette, colors, firstcolor, ncolors);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_SetPixelFormatPalette(format:SDL_PixelFormat@, palette:SDL_Palette@):negerr = `auto

//-----------------------------------------------------------------------------
// Video - Rectangle Functions

SDL_EnclosePoints(points[]:SDL_Point, clip:SDL_Rect@:const) {block?} = R'''
	int count = static_cast<int>(points.GetSize());
	SDL_Rect result;
	SDL_bool _rtn = SDL_EnclosePoints(points, count, clip, &result);
	Value _rtnVal;
	if (_rtn == SDL_TRUE) {
		_rtnVal = Value(new Object_Rect(result));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_HasIntersection(A:SDL_Rect@:const, B:SDL_Rect@:const):SDL_bool {block?} = `auto

SDL_IntersectRect(A:SDL_Rect@:const, B:SDL_Rect@:const) {block?} = R'''
	SDL_Rect result;
	SDL_bool _rtn = SDL_IntersectRect(A, B, &result);
	Value _rtnVal;
	if (_rtn == SDL_TRUE) {
		_rtnVal = Value(new Object_Rect(result));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_IntersectRectAndLine(rect:SDL_Rect@:const, X1:int, Y1:int, X2:int, Y2:int):SDL_bool = `unsupport

SDL_PointInRect(p:SDL_Point@:const, r:SDL_Rect@:const):SDL_bool = `unsupport

SDL_RectEmpty(r:SDL_Rect@:const):SDL_bool {block?} = `auto

SDL_RectEquals(a:SDL_Rect@:const, b:SDL_Rect@:const):SDL_bool {block?} = `auto

SDL_UnionRect(A:SDL_Rect@:const, B:SDL_Rect@:const) {block?} = R'''
	SDL_Rect result;
	SDL_UnionRect(A, B, &result);
	Value _rtnVal = Value(new Object_Rect(result));
	return ReturnValue(env, sig, args, _rtnVal);
'''

//-----------------------------------------------------------------------------
// Video - Surface Creation and Simple Drawing

SDL_BlitScaled(src:SDL_Surface@, srcrect:SDL_Rect@:const:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr = `auto

SDL_BlitSurface(src:SDL_Surface@, srcrect:SDL_Rect@:const:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr = `auto

SDL_ConvertPixels(width:int, height:int, src_format:Uint32, dst_format:Uint32):negerr = `unsupport

SDL_ConvertSurface(src:SDL_Surface@, fmt:SDL_PixelFormat@:const, flags:Uint32):SDL_Surface@ {block?} = `auto

SDL_ConvertSurfaceFormat(src:SDL_Surface@, pixel_format:Uint32, flags:Uint32):SDL_Surface@ {block?} = `auto

SDL_CreateRGBSurface(flags:Uint32, width:int, height:int, depth:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32):SDL_Surface@ {block?} = `auto

SDL_CreateRGBSurfaceFrom(pixels:binary, width:int, height:int, depth:int, pitch:int, Rmask:Uint32, Gmask:Uint32, Bmask:Uint32, Amask:Uint32) {block?} = R'''
	if (pixels.size() < static_cast<size_t>(height * pitch)) {
		sig.SetError(ERR_ValueError, "pixels doesn not contain enough data");
		return Value::Null;
	}
	void *_pixels = const_cast<char *>(pixels.data());
	SDL_Surface *_rtn = SDL_CreateRGBSurfaceFrom(_pixels, width, height,
								depth, pitch, Rmask, Gmask, Bmask, Amask);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Surface(_rtn)));
'''

SDL_CreateRGBSurfaceFromImage(image:image) {block?} = R'''
	Object_Surface *pObjSurface = Object_Surface::CreateSurfaceFromImage(sig, image);
	if (pObjSurface == NULL) return Value::Null;
	return ReturnValue(env, sig, args, Value(pObjSurface));
'''

SDL_FillRect(dst:SDL_Surface@, rect:SDL_Rect@:const:nil, color:Uint32):negerr = `auto

SDL_FillRects(dst:SDL_Surface@, rects[]:SDL_Rect, color:Uint32):void = R'''
	int count = static_cast<int>(rects.GetSize());
	int _rtn = SDL_FillRects(dst, rects, count, color);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_FreeSurface(surface:SDL_Surface@):void = `auto

SDL_GetClipRect(surface:SDL_Surface@) {block?} = R'''
	SDL_Rect rect;
	SDL_GetClipRect(surface, &rect);
	return ReturnValue(env, sig, args, Value(new Object_Rect(rect)));
'''

SDL_GetColorKey(surface:SDL_Surface@) {block?} = R'''
	Uint32 key = 0;
	int _rtn = SDL_GetColorKey(surface, &key);
	Value _rtnVal;
	if (_rtn >= 0) {
		_rtnVal = Value(key);
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetSurfaceAlphaMod(surface:SDL_Surface@) {block?} = R'''
	Uint8 alpha = 0;
	int _rtn = SDL_GetSurfaceAlphaMod(surface, &alpha);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(alpha));
'''

SDL_GetSurfaceBlendMode(surface:SDL_Surface@) {block?} = R'''
	SDL_BlendMode blendMode = SDL_BLENDMODE_NONE;
	int _rtn = SDL_GetSurfaceBlendMode(surface, &blendMode);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(blendMode));
'''

SDL_GetSurfaceColorMod(surface:SDL_Surface@) {block?} = R'''
	Uint8 r = 0;
	Uint8 g = 0;
	Uint8 b = 0;
	int _rtn = SDL_GetSurfaceColorMod(surface, &r, &g, &b);
	return ReturnValue(env, sig, args,
			Value::CreateList(env, Value(r), Value(g), Value(b)));
'''

SDL_LoadBMP(src:stream) {block?} = R'''
	std::auto_ptr<SDL_RWops> _src(CreateRWopsStream(&src, &sig));
	SDL_Surface *_rtn = SDL_LoadBMP_RW(_src.get(), 0);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Surface(_rtn)));
'''

SDL_LoadBMP_RW() = `unsupport

SDL_LockSurface(surface:SDL_Surface@):negerr = `auto

SDL_LowerBlit(src:SDL_Surface@, srcrect:SDL_Rect@:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr = `auto

SDL_LowerBlitScaled(src:SDL_Surface@, srcrect:SDL_Rect@:nil, dst:SDL_Surface@, dstrect:SDL_Rect@:nil):negerr = `auto

SDL_MUSTLOCK(surface:SDL_Surface@):bool {block?} = `auto

SDL_SaveBMP(surface:SDL_Surface@, dst:stream) {block?} = R'''
	std::auto_ptr<SDL_RWops> context(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveBMP_RW(surface, context.get(), 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_SaveBMP_RW() = `unsupport

SDL_SetClipRect(surface:SDL_Surface@, rect:SDL_Rect@:const):SDL_bool {block?} = `auto

SDL_SetColorKey(surface:SDL_Surface@, flag:int, key:Uint32):negerr = `auto

SDL_SetSurfaceAlphaMod(surface:SDL_Surface@, alpha:Uint8):negerr = `auto

SDL_SetSurfaceBlendMode(surface:SDL_Surface@, blendMode:SDL_BlendMode):negerr = `auto

SDL_SetSurfaceColorMod(surface:SDL_Surface@, r:Uint8, g:Uint8, b:Uint8):negerr = `auto

SDL_SetSurfacePalette(surface:SDL_Surface@, palette:SDL_Palette@):negerr = `auto

SDL_SetSurfaceRLE(surface:SDL_Surface@, flag:int):negerr = `auto

SDL_UnlockSurface(surface:SDL_Surface@):void = `auto

//-----------------------------------------------------------------------------
// Video - Clipboard Handling

SDL_GetClipboardText() {block?} = R'''
	char *_rtn = SDL_GetClipboardText();
	Value _rtnVal(_rtn);
	SDL_free(_rtn);
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_HasClipboardText():SDL_bool {block?} = `auto

//-----------------------------------------------------------------------------
// Input Events - Event Handling

SDL_SetClipboardText(text:char@:const):negerr = `auto

SDL_AddEventWatch() = `unsupport

SDL_DelEventWatch() = `unsupport

SDL_EventState(type:Uint32, state:int):Uint8 {block?} = `auto

SDL_FilterEvents() = `unsupport

SDL_FlushEvent(type:Uint32):void = `auto

SDL_FlushEvents(minType:Uint32, maxType:Uint32):void = `auto

SDL_GetEventFilter() = `unsupport

SDL_GetNumTouchDevices():int {block?} = `auto

SDL_GetNumTouchFingers(touchId:SDL_TouchID):negerr_number {block?} = `auto

SDL_GetTouchDevice(index:int) {block?} = R'''
	SDL_TouchID _rtn = SDL_GetTouchDevice(index);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetTouchFinger(touchId:SDL_TouchID, index:int):SDL_Finger@ {block?} = `auto

SDL_HasEvent(type:Uint32):SDL_bool {block?} = `auto

SDL_HasEvents(minType:Uint32, maxType:Uint32):SDL_bool {block?} = `auto

SDL_LoadDollarTemplates(touchId:SDL_TouchID, src:stream) {block?} = R'''
	std::auto_ptr<SDL_RWops> _src(CreateRWopsStream(&src, &sig));
	int _rtn = SDL_LoadDollarTemplates(touchId, _src.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_AddEvents(events[]:SDL_Event) {block?} = R'''
	int numevents = static_cast<int>(events.GetSize());
	int _rtn = SDL_PeepEvents(events, numevents, SDL_ADDEVENT, 0, 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_PeekEvents(numevents:int, minType:Uint32, maxType:Uint32) {block?} = R'''
	CArray<SDL_Event> events(numevents);
	int _rtn = SDL_PeepEvents(events, numevents, SDL_PEEKEVENT, minType, maxType);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, _rtn);
	for (int i = 0; i < _rtn; i++) {
		_valList.push_back(Value(new Object_Event(events[i])));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetEvents(numevents:int, minType:Uint32, maxType:Uint32) {block?} = R'''
	CArray<SDL_Event> events(numevents);
	int _rtn = SDL_PeepEvents(events, numevents, SDL_GETEVENT, minType, maxType);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, _rtn);
	for (int i = 0; i < _rtn; i++) {
		_valList.push_back(Value(new Object_Event(events[i])));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_PollEvent() {block?} = R'''
	SDL_Event event;
	int _rtn = SDL_PollEvent(&event);
	if (_rtn == 0) return Value::Null;
	return ReturnValue(env, sig, args, Value(new Object_Event(event)));
'''

SDL_PumpEvents():void = `auto

SDL_PushEvent(event:SDL_Event@):negerr_boolean {block?} = `auto

SDL_QuitRequested():bool {block?} = `auto

SDL_RecordGesture(touchId:SDL_TouchID):negerr_number {block?} = `auto

SDL_RegisterEvents(numevents:int) {block?} = R'''
	Uint32 _rtn = SDL_RegisterEvents(numevents);
	Value _rtnVal;
	if (_rtn != (Uint32)-1) {
		_rtnVal = Value(_rtn);
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_SaveAllDollarTemplates(dst:stream) {block?} = R'''
	std::auto_ptr<SDL_RWops> _dst(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveAllDollarTemplates(_dst.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_SaveDollarTemplate(gestureId:SDL_GestureID, dst:stream):void = R'''
	std::auto_ptr<SDL_RWops> _dst(CreateRWopsStream(&dst, &sig));
	int _rtn = SDL_SaveDollarTemplate(gestureId, _dst.get());
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return Value::Null;
'''

SDL_SetEventFilter() = `unsupport

SDL_WaitEvent() {block?} = R'''
	SDL_Event event;
	int _rtn = SDL_WaitEvent(&event);
	if (_rtn == 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Event(event)));
'''

SDL_WaitEventTimeout(timeout:int) {block?} = R'''
	SDL_Event event;
	int _rtn = SDL_WaitEventTimeout(&event, timeout);
	Value _rtnVal;
	if (_rtn > 0) {
		_rtnVal = Value(new Object_Event(event));
	} else if (*SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

//-----------------------------------------------------------------------------
// Input Events - Keyboard Support

SDL_CheckKeyboardState(scancode:SDL_Scancode) {block?} = R'''
	int numkeys = 0;
	const Uint8 *_keystate = SDL_GetKeyboardState(&numkeys);
	bool _rtn = (0 <= scancode && scancode < numkeys && _keystate[scancode] != 0);
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetKeyFromName(name:char@:const) {block?} = R'''
	SDL_Keycode _rtn = SDL_GetKeyFromName(name);
	if (_rtn == SDLK_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetKeyFromScancode(scancode:SDL_Scancode):SDL_Keycode {block?} = `auto

SDL_GetKeyName(key:SDL_Keycode):char@:const {block?} = `auto

SDL_GetKeyboardFocus():SDL_Window@ {block?} = `auto

SDL_GetKeyboardState() {block?} = R'''
	int numkeys = 0;
	const Uint8 *_keystate = SDL_GetKeyboardState(&numkeys);
	Value _rtnVal;
	ValueList &_valList = _rtnVal.InitAsList(env, numkeys);
	for (int i = 0; i < numkeys; i++) {
		_valList.push_back(Value(_keystate[i] != 0));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetModState():SDL_Keymod {block?} = `auto

SDL_GetScancodeFromKey(key:SDL_Keycode):SDL_Scancode {block?} = `auto

SDL_GetScancodeFromName(name:char@:const) {block?} = R'''
	SDL_Scancode _rtn = SDL_GetScancodeFromName(name);
	if (_rtn == SDL_SCANCODE_UNKNOWN) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GetScancodeName(scancode:SDL_Scancode):char@:const {block?} = `auto

SDL_HasScreenKeyboardSupport():SDL_bool {block?} = `auto

SDL_IsScreenKeyboardShown(window:SDL_Window@):SDL_bool {block?} = `auto

SDL_IsTextInputActive():SDL_bool {block?} = `auto

SDL_SetModState(modstate:SDL_Keymod):void = `auto

SDL_SetTextInputRect(rect:SDL_Rect@):void = `auto

SDL_StartTextInput():void = `auto

SDL_StopTextInput():void = `auto

//-----------------------------------------------------------------------------
// Input Events - Mouse Support

SDL_CaptureMouse(enalbed:SDL_bool):negerr = `unsupport

SDL_CreateColorCursor(surface:SDL_Surface@, hot_x:int, hot_y:int):SDL_Cursor@ {block?} = `auto

SDL_CreateCursor(data:binary, mask:binary, w:int, h:int, hot_x:int, hot_y:int) {block?} = R'''
	size_t bytesLeast = int((w + 7) / 8) * h;
	if (data.size() < bytesLeast) {
		sig.SetError(ERR_ValueError, "data has insufficient content");
		return Value::Null;
	}
	if (mask.size() < bytesLeast) {
		sig.SetError(ERR_ValueError, "mask has insufficient content");
		return Value::Null;
	}
	const Uint8 *_data = reinterpret_cast<const Uint8 *>(data.data());
	const Uint8 *_mask = reinterpret_cast<const Uint8 *>(mask.data());
	SDL_Cursor *_rtn = SDL_CreateCursor(_data, _mask, w, h, hot_x, hot_y);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Cursor(_rtn, true)));
'''

SDL_CreateSystemCursor(id:SDL_SystemCursor):SDL_Cursor@ {block?} = `auto

SDL_FreeCursor(cursor:SDL_Cursor@):void = `auto

SDL_GetCursor() {block?} = R'''
	SDL_Cursor *_rtn = SDL_GetCursor();
	Value _rtnVal;
	if (_rtn != NULL) {
		_rtnVal = Value(new Object_Cursor(_rtn, false));
	}
	return ReturnValue(env, sig, args, _rtnVal);
'''

SDL_GetDefaultCursor():SDL_Cursor@ {block?} = `auto

SDL_GetGlobalMouseState() = `unsupport

SDL_GetMouseFocus():SDL_Window@ {block?} = `auto

SDL_GetMouseState() {block?} = R'''
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
'''

SDL_GetRelativeMouseMode():SDL_bool {block?} = `auto

SDL_GetRelativeMouseState() {block?} = R'''
	int x = 0;
	int y = 0;
	Uint32 _rtn = SDL_GetRelativeMouseState(&x, &y);
	return ReturnValue(env, sig, args, Value::CreateList(env,
										Value(_rtn), Value(x), Value(y)));
'''

SDL_SetCursor(cursor:SDL_Cursor@):void = `auto

SDL_SetRelativeMouseMode(enabled:SDL_bool):negerr = `auto

SDL_ShowCursor(toggle:int):negerr = `auto

SDL_WarpMouseGlobal(x:int, y:int) = `unsupport

SDL_WarpMouseInWindow(window:SDL_Window@, x:int, y:int):void = `auto

//-----------------------------------------------------------------------------
// Input Events - Joystick Support

SDL_JoystickClose(joystick:SDL_Joystick@):void = `auto

SDL_JoystickEventState(state:int):negerr_boolean {block?} = `auto

SDL_JoystickGetAttached(joystick:SDL_Joystick@):SDL_bool {block?} = `auto

SDL_JoystickGetAxis(joystick:SDL_Joystick@, axis:int):Sint16 {block?} = `auto

SDL_JoystickGetBall(joystick:SDL_Joystick@, ball:int) {block?} = R'''
	int dx = 0;
	int dy = 0;
	int _rtn = SDL_JoystickGetBall(joystick, ball, &dx, &dy);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value::CreateList(env, Value(dx), Value(dy)));
'''

SDL_JoystickGetButton(joystick:SDL_Joystick@, button:int) {block?} = R'''
	Uint8 _rtn = SDL_JoystickGetButton(joystick, button);
	return ReturnValue(env, sig, args, Value(_rtn != 0));
'''

SDL_JoystickGetDeviceGUID(device_index:int):SDL_JoystickGUID {block?} = `auto

SDL_JoystickGetGUID(joystick:SDL_Joystick@):SDL_JoystickGUID {block?} = `auto

SDL_JoystickGetGUIDFromString(pchGUID:char@:const):SDL_JoystickGUID {block?} = `auto

SDL_JoystickGetGUIDString(guid:SDL_JoystickGUID) {block?} = R'''
	char szGUID[64];
	int cbGUID = sizeof(szGUID);
	SDL_JoystickGetGUIDString(guid, szGUID, cbGUID);
	return ReturnValue(env, sig, args, Value(szGUID));
'''

SDL_JoystickGetHat(joystick:SDL_Joystick@, hat:int):Uint8 {block?} = `auto

SDL_JoystickInstanceID(joystick:SDL_Joystick@) {block?} = R'''
	SDL_JoystickID _rtn = SDL_JoystickInstanceID(joystick);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_JoystickName(joystick:SDL_Joystick@):char@:const {block?} = `auto

SDL_JoystickNameForIndex(device_index:int):char@:const {block?} = `auto

SDL_JoystickNumAxes(joystick:SDL_Joystick@):negerr_number {block?} = `auto

SDL_JoystickNumBalls(joystick:SDL_Joystick@):negerr_number {block?} = `auto

SDL_JoystickNumButtons(joystick:SDL_Joystick@):negerr_number {block?} = `auto

SDL_JoystickNumHats(joystick:SDL_Joystick@):negerr_number {block?} = `auto

SDL_JoystickOpen(device_index:int):SDL_Joystick@ {block?} = `auto

SDL_JoystickUpdate():void = `auto

SDL_NumJoysticks():negerr_number {block?} = `auto

//-----------------------------------------------------------------------------
// Input Events - Game Controller Support

SDL_GameControllerAddMapping(mappingString:char@:const):negerr_boolean {block?} = `auto

SDL_GameControllerAddMappingsFromFile(file:stream) {block?} = R'''
	std::auto_ptr<SDL_RWops> _file(CreateRWopsStream(&file, &sig));
	int _rtn = SDL_GameControllerAddMappingsFromRW(_file.get(), 0);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn));
'''

SDL_GameControllerAddMappingsFromRW() = `unsupport

SDL_GameControllerClose(gamecontroller:SDL_GameController@):void = `auto

SDL_GameControllerEventState(state:int):int {block?} = `auto

SDL_GameControllerGetAttached(gamecontroller:SDL_GameController@):SDL_bool {block?} = `auto

SDL_GameControllerGetAxis(gamecontroller:SDL_GameController@, axis:SDL_GameControllerAxis):Sint16 {block?} = `auto

SDL_GameControllerGetAxisFromString(pchString:char@:const):SDL_GameControllerAxis {block?} = `auto

SDL_GameControllerGetBindForAxis(gamecontroller:SDL_GameController@, axis:SDL_GameControllerAxis):SDL_GameControllerButtonBind {block?} = `auto

SDL_GameControllerGetBindForButton(gamecontroller:SDL_GameController@, button:SDL_GameControllerButton):SDL_GameControllerButtonBind {block?} = `auto

SDL_GameControllerGetButton(gamecontroller:SDL_GameController@, button:SDL_GameControllerButton) {block?} = R'''
	Uint8 _rtn = SDL_GameControllerGetButton(gamecontroller, button);
	if (_rtn == 0 && *SDL_GetError() != '\0') {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(_rtn != 0));
'''

SDL_GameControllerGetButtonFromString(pchString:char@:const):SDL_GameControllerButton {block?} = `auto

SDL_GameControllerGetJoystick(gamecontroller:SDL_GameController@):SDL_Joystick@ {block?} = `auto

SDL_GameControllerGetStringForAxis(axis:SDL_GameControllerAxis):char@:const {block?} = `auto

SDL_GameControllerGetStringForButton(button:SDL_GameControllerButton):char@:const {block?} = `auto

SDL_GameControllerMapping(gamecontroller:SDL_GameController@):char@:const {block?} = `auto

SDL_GameControllerMappingForGUID(guid:SDL_JoystickGUID):char@:const {block?} = `auto

SDL_GameControllerName(gamecontroller:SDL_GameController@):char@:const {block?} = `auto

SDL_GameControllerNameForIndex(joystick_index:int):char@:const {block?} = `auto

SDL_GameControllerOpen(joystick_index:int):SDL_GameController@ {block?} = `auto

SDL_GameControllerUpdate():void = `auto

SDL_IsGameController(joystick_index:int):SDL_bool {block?} = `auto

//-----------------------------------------------------------------------------
// Force Feedback - Force Feedback Support

SDL_HapticClose(haptic:SDL_Haptic@):void = `auto

SDL_HapticDestroyEffect(haptic:SDL_Haptic@, effect:int):void = `auto

SDL_HapticEffectSupported(haptic:SDL_Haptic@, effect:SDL_HapticEffect@):negerr_boolean {block?} = `auto

SDL_HapticGetEffectStatus(haptic:SDL_Haptic@, effect:int):negerr_boolean {block?} = `auto

SDL_HapticIndex(haptic:SDL_Haptic@):negerr_number {block?} = `auto

SDL_HapticName(device_index:int):char@:const {block?} = `auto

SDL_HapticNewEffect(haptic:SDL_Haptic@, effect:SDL_HapticEffect@):negerr_number {block?} = `auto

SDL_HapticNumAxes(haptic:SDL_Haptic@):negerr_number {block?} = `auto

SDL_HapticNumEffects(haptic:SDL_Haptic@):negerr_number {block?} = `auto

SDL_HapticNumEffectsPlaying(haptic:SDL_Haptic@):negerr_number {block?} = `auto

SDL_HapticOpen(device_index:int):SDL_Haptic@ {block?} = `auto

SDL_HapticOpenFromJoystick(joystick:SDL_Joystick@):SDL_Haptic@ {block?} = `auto

SDL_HapticOpenFromMouse():SDL_Haptic@ {block?} = `auto

SDL_HapticOpened(device_index:int):negerr_boolean {block?} = `auto

SDL_HapticPause(haptic:SDL_Haptic@):negerr = `auto

SDL_HapticQuery(haptic:SDL_Haptic@):unsigned_int {block?} = `auto

SDL_HapticRumbleInit(haptic:SDL_Haptic@):negerr = `auto

SDL_HapticRumblePlay(haptic:SDL_Haptic@, strength:float, length:Uint32):negerr = `auto

SDL_HapticRumbleStop(haptic:SDL_Haptic@):negerr = `auto

SDL_HapticRumbleSupported(haptic:SDL_Haptic@):negerr_boolean {block?} = `auto

SDL_HapticRunEffect(haptic:SDL_Haptic@, effect:int, iterations:Uint32):negerr = `auto

SDL_HapticSetAutocenter(haptic:SDL_Haptic@, autocenter:int):negerr = `auto

SDL_HapticSetGain(haptic:SDL_Haptic@, gain:int):negerr = `auto

SDL_HapticStopAll(haptic:SDL_Haptic@):negerr = `auto

SDL_HapticStopEffect(haptic:SDL_Haptic@, effect:int):negerr = `auto

SDL_HapticUnpause(haptic:SDL_Haptic@):negerr = `auto

SDL_HapticUpdateEffect(haptic:SDL_Haptic@, effect:int, data:SDL_HapticEffect@):negerr = `auto

SDL_JoystickIsHaptic(joystick:SDL_Joystick@):negerr_boolean {block?} = `auto

SDL_MouseIsHaptic():negerr_boolean {block?} = `auto

SDL_NumHaptics():negerr_number {block?} = `auto

//-----------------------------------------------------------------------------
// Audio - Audio Device Management, Playing and Recording

SDL_AudioInit(driver_name:char@:const):negerr = `auto

SDL_AudioQuit():void = `auto

SDL_BuildAudioCVT(cvt:SDL_AudioCVT@, src_format:SDL_AudioFormat, src_channels:Uint8, src_rate:int, dst_format:SDL_AudioFormat, dst_channels:Uint8, dst_rate:int):negerr_boolean {block?} = `auto

SDL_ClearQueuedAudio(dev:SDL_AudioDeviceID) = `unsupport

SDL_CloseAudio():void = `auto

SDL_CloseAudioDevice(dev:SDL_AudioDeviceID):void = `auto

SDL_ConvertAudio(cvt:SDL_AudioCVT@):negerr = `auto

SDL_FreeWAV(wav:Wav@):void = R'''
	Object_Wav *pObj = Object_Wav::GetObject(args, 0);
	Uint8 *buffer = pObj->GetBuffer();
	SDL_FreeWAV(buffer);
	return Value::Null;
'''

SDL_GetAudioDeviceName(index:int, iscapture:int):char@:const {block?} = `auto

SDL_GetAudioDeviceStatus(dev:SDL_AudioDeviceID):SDL_AudioStatus {block?} = `auto

SDL_GetAudioDriver(index:int):char@:const {block?} = `auto

SDL_GetAudioStatus():SDL_AudioStatus {block?} = `auto

SDL_GetCurrentAudioDriver():char@:const {block?} = `auto

SDL_GetNumAudioDevices(iscapture:int):negerr_number {block?} = `auto

SDL_GetNumAudioDrivers():int {block?} = `auto

SDL_GetQueuedAudioSize(dev:SDL_AudioDeviceID):Uint32 = `unsupport

SDL_LoadWAV(file:stream) {block?} = R'''
	std::auto_ptr<SDL_RWops> _file(CreateRWopsStream(&file, &sig));
	SDL_AudioSpec spec;
	Uint8 *audio_buf = NULL;
	Uint32 audio_len = 0;
	SDL_AudioSpec *_rtn = SDL_LoadWAV_RW(_file.get(), 0, &spec, &audio_buf, &audio_len);
	if (_rtn == NULL) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_Wav(spec, audio_buf, audio_len)));
'''

SDL_LoadWAV_RW() = `unsupport

SDL_LockAudio():void = `auto

SDL_LockAudioDevice(dev:SDL_AudioDeviceID):void = `auto

SDL_MixAudio(volume:int) = `unsupport

SDL_MixAudioFormat(format:SDL_AudioFormat, volume:int) = `unsupport

SDL_OpenAudio(desired:SDL_AudioSpec@) {block?} = R'''
	SDL_AudioSpec obtained;
	int _rtn = SDL_OpenAudio(desired, &obtained);
	if (_rtn < 0) {
		SetError_SDL(sig);
		return Value::Null;
	}
	return ReturnValue(env, sig, args, Value(new Object_AudioSpec(obtained)));
'''

SDL_OpenAudioDevice(device:char@:const, iscapture:int, desired:SDL_AudioSpec@:const, allowed_changes:int):SDL_AudioDeviceID = `unsupport

SDL_PauseAudio(pause_on:int):void = `auto

SDL_PauseAudioDevice(dev:SDL_AudioDeviceID, pause_on:int):void = `auto

SDL_QueueAudio(dev:SDL_AudioDeviceID):negerr = `unsupport

SDL_UnlockAudio():void = `auto

SDL_UnlockAudioDevice(dev:SDL_AudioDeviceID):void = `auto

SDL_AUDIO_BITSIZE(x:Uint16):Uint16 {block?} = `auto

SDL_AUDIO_ISFLOAT(x:Uint16):Uint16_boolean {block?} = `auto

SDL_AUDIO_ISBIGENDIAN(x:Uint16):Uint16_boolean {block?} = `auto

SDL_AUDIO_ISSIGNED(x:Uint16):Uint16_boolean {block?} = `auto

SDL_AUDIO_ISINT(x:Uint16):bool {block?} = `auto

SDL_AUDIO_ISLITTLEENDIAN(x:Uint16):bool {block?} = `auto

SDL_AUDIO_ISUNSIGNED(x:Uint16):bool {block?} = `auto

//-----------------------------------------------------------------------------
// Threads - Thread Management

SDL_CreateThread() = `unsupport

SDL_DetachThread() = `unsupport

SDL_GetThreadID() = `unsupport

SDL_GetThreadName() = `unsupport

SDL_GetThreadPriority() = `unsupport

SDL_TLSCreate() = `unsupport

SDL_TLSGet() = `unsupport

SDL_TLSSet() = `unsupport

SDL_ThreadID() = `unsupport

SDL_WaitThread() = `unsupport

//-----------------------------------------------------------------------------
// Threads - Thread Synchronization Primitives

SDL_CondBroadcast() = `unsupport

SDL_CondSignal() = `unsupport

SDL_CondWait() = `unsupport

SDL_CondWaitTimeout() = `unsupport

SDL_CreateCond() = `unsupport

SDL_CreateMutex() = `unsupport

SDL_CreateSemaphore() = `unsupport

SDL_DestroyCond() = `unsupport

SDL_DestroyMutex() = `unsupport

SDL_DestroySemaphore() = `unsupport

SDL_LockMutex() = `unsupport

SDL_SemPost() = `unsupport

SDL_SemTryWait() = `unsupport

SDL_SemValue() = `unsupport

SDL_SemWait() = `unsupport

SDL_SemWaitTimeout() = `unsupport

SDL_TryLockMutex() = `unsupport

SDL_UnlockMutex() = `unsupport

//-----------------------------------------------------------------------------
// Threads - Atomic Operations

SDL_AtomicAdd() = `unsupport

SDL_AtomicCAS() = `unsupport

SDL_AtomicCASPtr() = `unsupport

SDL_AtomicDecRef() = `unsupport

SDL_AtomicGet() = `unsupport

SDL_AtomicGetPtr() = `unsupport

SDL_AtomicIncRef() = `unsupport

SDL_AtomicLock() = `unsupport

SDL_AtomicSet() = `unsupport

SDL_AtomicSetPtr() = `unsupport

SDL_AtomicTryLock() = `unsupport

SDL_AtomicUnlock() = `unsupport

SDL_CompilerBarrier() = `unsupport

//-----------------------------------------------------------------------------
// Timers - Timer Support

SDL_AddTimer(interval:Uint32):SDL_TimerID = `unsupport

SDL_Delay(ms:Uint32):void = `auto

SDL_GetPerformanceCounter():Uint64 {block?} = `auto

SDL_GetPerformanceFrequency():Uint64 {block?} = `auto

SDL_GetTicks():Uint32 {block?} = `auto

SDL_RemoveTimer(id:SDL_TimerID):SDL_bool {block?} = `auto

SDL_TICKS_PASSED(A:Uint32, B:Uint32):bool {block?} = `auto

//-----------------------------------------------------------------------------
// File Abstraction - Filesystem Paths

SDL_GetBasePath():char@ = `unsupport

SDL_GetPrefPath(org:char@:const, app:char@:const):char@ = `unsupport

//-----------------------------------------------------------------------------
// File Abstraction - File I/O Abstraction

SDL_AllocRW() = `unsupport

SDL_FreeRW() = `unsupport

SDL_RWFromConstMem() = `unsupport

SDL_RWFromFP() = `unsupport

SDL_RWFromFile() = `unsupport

SDL_RWFromMem() = `unsupport

SDL_RWclose() = `unsupport

SDL_RWread() = `unsupport

SDL_RWseek() = `unsupport

SDL_RWtell() = `unsupport

SDL_RWwrite() = `unsupport

SDL_ReadBE16() = `unsupport

SDL_ReadBE32() = `unsupport

SDL_ReadBE64() = `unsupport

SDL_ReadLE16() = `unsupport

SDL_ReadLE32() = `unsupport

SDL_ReadLE64() = `unsupport

SDL_WriteBE16() = `unsupport

SDL_WriteBE32() = `unsupport

SDL_WriteBE64() = `unsupport

SDL_WriteLE16() = `unsupport

SDL_WriteLE32() = `unsupport

SDL_WriteLE64() = `unsupport

//-----------------------------------------------------------------------------
// Shared Object Support - Shared Object Loading and Function Lookup

//-----------------------------------------------------------------------------
// Platform and CPU Information - Platform Detection

SDL_GetPlatform():char@:const {block?} = `auto

//-----------------------------------------------------------------------------
// Platform and CPU Information - CPU Feature Detection

SDL_GetCPUCacheLineSize():int {block?} = `auto

SDL_GetCPUCount():int {block?} = `auto

SDL_GetSystemRAM():int {block?} = `auto

SDL_Has3DNow():SDL_bool {block?} = `auto

SDL_HasAVX():SDL_bool {block?} = `auto

SDL_HasAVX2():SDL_bool = `unsupport

SDL_HasAltiVec():SDL_bool {block?} = `auto

SDL_HasMMX():SDL_bool {block?} = `auto

SDL_HasRDTSC():SDL_bool {block?} = `auto

SDL_HasSSE():SDL_bool {block?} = `auto

SDL_HasSSE2():SDL_bool {block?} = `auto

SDL_HasSSE3():SDL_bool {block?} = `auto

SDL_HasSSE41():SDL_bool {block?} = `auto

SDL_HasSSE42():SDL_bool {block?} = `auto

//-----------------------------------------------------------------------------
// Platform and CPU Information - Byte Order and Byte Swapping

SDL_Swap16() = `unsupport

SDL_Swap32() = `unsupport

SDL_Swap64() = `unsupport

SDL_SwapBE16() = `unsupport

SDL_SwapBE32() = `unsupport

SDL_SwapBE64() = `unsupport

SDL_SwapFloat() = `unsupport

SDL_SwapFloatBE() = `unsupport

SDL_SwapFloatLE() = `unsupport

SDL_SwapLE16() = `unsupport

SDL_SwapLE32() = `unsupport

SDL_SwapLE64() = `unsupport

//-----------------------------------------------------------------------------
// Platform and CPU Information - Bit Manipulation

SDL_MostSignificantBitIndex32(x:Uint32):int = `unsupport

//-----------------------------------------------------------------------------
// Power Management - Power Management Status

SDL_GetPowerInfo() {block?} = R'''
	int secs = 0;
	int pct = 0;
	SDL_PowerState _rtn = SDL_GetPowerInfo(&secs, &pct);
	return ReturnValue(env, sig, args, Value::CreateList(env,
									Value(_rtn), Value(secs), Value(pct)));
'''

//-----------------------------------------------------------------------------
// Additional - Platform-specific functionality

SDL_AndroidGetActivity() = `unsupport

SDL_AndroidGetExternalStoragePath() = `unsupport

SDL_AndroidGetExternalStorageState() = `unsupport

SDL_AndroidGetInternalStoragePath() = `unsupport

SDL_AndroidGetJNIEnv() = `unsupport

//-----------------------------------------------------------------------------
// Additional - Other

SDL_acos(x:double):double {block?} = `auto
}

import(modimp) {TypeConv, Renderer}

TypeConv_Enum(typeName:string) = {
	typeName => TypeConv(
			'number', 'Once', [],
			'%s ${arg.name} = static_cast<%s>(args.GetInt(${idx}));' % [typeName, typeName],
			nil,
			R'''
			%s _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''' % [typeName])
}

TypeConv_Class(typeName:string) = {
	fields = typeName.split(':'):list
	if (fields.len() > 1) {
		[typeNameTmp, attr] = fields
		constFlag = (attr == 'const')
	} else {
		typeNameTmp = fields[0]
		constFlag = false
	}
	pointerFlag = typeNameTmp.find('@')
	typeNameTmp = typeNameTmp.replace('@', '')
	typeNameBase = typeNameTmp.replace('SDL_', '')
	if (pointerFlag) {
		typeName => TypeConv(
				typeNameBase, 'Once', [],
				'%sSDL_%s *${arg.name} = Object_%s::GetObject(args, ${idx})->GetEntity();' % \
								[cond(constFlag, 'const ', ''), typeNameBase, typeNameBase]
				'%sSDL_%s *${arg.name} = args.IsValid(${idx})? Object_%s::GetObject(args, ${idx})->GetEntity() : NULL;' % \
								[cond(constFlag, 'const ', ''), typeNameBase, typeNameBase]
				R'''
				SDL_%s *_rtn = ${fi.MakeCaller()};
				Value _rtnVal;
				if (_rtn != NULL) {
					_rtnVal = Value(new Object_%s(_rtn));
				} else if (*SDL_GetError() != '\0') {
					SetError_SDL(sig);
					return Value::Null;
				}
				return ReturnValue(env, sig, args, _rtnVal);''' % [typeNameBase, typeNameBase])
	} else {
		typeName => TypeConv(
				typeNameBase, 'Once', [],
				'SDL_%s ${arg.name} = Object_%s::GetObject(args, ${idx})->GetEntity();' % \
																[typeNameBase, typeNameBase]
				nil,
				R'''
				SDL_%s _rtn = ${fi.MakeCaller()};
				Value _rtnVal(new Object_%s(_rtn));
				return ReturnValue(env, sig, args, _rtnVal);''' % [typeNameBase, typeNameBase])
	}
}

typeConvDict = %{
	// overwrite built-in converter
	'char@' => TypeConv(
			'string', 'Once', [],
			'char *${arg.name} = args.GetString(${idx});',
			nil,
			R'''
			char *_rtn = ${fi.MakeCaller()};
			Value _rtnVal;
			if (_rtn != NULL) {
				_rtnVal = Value(_rtn);
				// free buffer of _rtn
			} else if (*SDL_GetError() != '\0') {
				SetError_SDL(sig);
				return Value::Null;
			}
			return ReturnValue(env, sig, args, _rtnVal);''')
	'char@:const' => TypeConv(
			'string', 'Once', [],
			'const char *${arg.name} = args.GetString(${idx});',
			nil,
			R'''
			const char *_rtn = ${fi.MakeCaller()};
			Value _rtnVal;
			if (_rtn != NULL) {
				_rtnVal = Value(_rtn);
			} else if (*SDL_GetError() != '\0') {
				SetError_SDL(sig);
				return Value::Null;
			}
			return ReturnValue(env, sig, args, _rtnVal);''')
	// type converter specific to SDL library
	'Uint16[]' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<Uint16> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'Sint8' => TypeConv(
			'number', 'Once', [],
			'Sint8 ${arg.name} = args.GetChar(${idx});',
			nil,
			R'''
			Sint8 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Sint16' => TypeConv(
			'number', 'Once', [],
			'Sint16 ${arg.name} = args.GetShort(${idx});',
			nil,
			R'''
			Sint16 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Sint32' => TypeConv(
			'number', 'Once', [],
			'Sint32 ${arg.name} = args.GetLong(${idx});',
			nil,
			R'''
			Sint32 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Sint64' => TypeConv(
			'number', 'Once', [],
			'Sint64 ${arg.name} = static_cast<Sint64>(args.GetDouble(${idx}));',
			nil,
			R'''
			Sint64 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Uint8' => TypeConv(
			'number', 'Once', [],
			'Uint8 ${arg.name} = args.GetUChar(${idx});',
			nil,
			R'''
			Uint8 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Uint16' => TypeConv(
			'number', 'Once', [],
			'Uint16 ${arg.name} = args.GetUShort(${idx});',
			nil,
			R'''
			Uint16 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Uint32' => TypeConv(
			'number', 'Once', [],
			'Uint32 ${arg.name} = args.GetULong(${idx});',
			nil,
			R'''
			Uint32 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Uint64' => TypeConv(
			'number', 'Once', [],
			'Uint64 ${arg.name} = static_cast<Uint64>(args.GetDouble(${idx}));',
			nil,
			R'''
			Uint64 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Wav@' => TypeConv(
			'Wav', 'Once', [],
			'Object_Wav *${arg.name} = Object_Wav::GetObject(args, ${idx});',
			nil,
			nil)
	'SDL_bool' => TypeConv(
			'boolean', 'Once', [],
			'SDL_bool ${arg.name} = (args.GetBoolean(${idx})? SDL_TRUE : SDL_FALSE);',
			nil,
			R'''
			SDL_bool _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn != SDL_FALSE));''')
	'SDL_Color[]' => TypeConv(
			'Color', 'Once', ['List'],
			'CArray<SDL_Color> ${arg.name} = ' \
			'CreateCArray<SDL_Color, Object_Color>(args.GetList(${idx}));',
			nil,
			nil)
	'SDL_Event[]' => TypeConv(
			'Event', 'Once', ['List'],
			'CArray<SDL_Event> ${arg.name} = ' \
					'CreateCArray<SDL_Event, Object_Event>(args.GetList(${idx}));',
			nil,
			nil)
	'SDL_Point[]' => TypeConv(
			'Point', 'Once', ['List'],
			'CArray<SDL_Point> ${arg.name} = ' \
					'CreateCArray<SDL_Point, Object_Point>(args.GetList(${idx}));',
			nil,
			nil)
	'SDL_Rect[]' => TypeConv(
			'Rect', 'Once', ['List'],
			'CArray<SDL_Rect> ${arg.name} = ' \
					'CreateCArray<SDL_Rect, Object_Rect>(args.GetList(${idx}));',
			nil,
			nil)
	'negerr' => TypeConv(
			nil, nil, [],
			nil,
			nil,
			R'''
			int _rtn = ${fi.MakeCaller()};
			if (_rtn < 0) {
				SetError_SDL(sig);
				return Value::Null;
			}
			return Value::Null;''', true)
	'negerr_boolean' => TypeConv(
			nil, nil, [],
			nil,
			nil,
			R'''
			int _rtn = ${fi.MakeCaller()};
			if (_rtn < 0) {
				SetError_SDL(sig);
				return Value::Null;
			}
			return ReturnValue(env, sig, args, Value(_rtn != 0));''')
	'negerr_number' => TypeConv(
			nil, nil, [],
			nil,
			nil,
			R'''
			int _rtn = ${fi.MakeCaller()};
			if (_rtn < 0) {
				SetError_SDL(sig);
				return Value::Null;
			}
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'Uint16_boolean' => TypeConv(
			nil, nil, [],
			nil,
			nil,
			R'''
			Uint16 _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn != 0));''')
	TypeConv_Enum('SDL_AudioFormat')
	TypeConv_Enum('SDL_AudioDeviceID')
	TypeConv_Enum('SDL_AudioStatus')
	TypeConv_Enum('SDL_BlendMode')
	TypeConv_Enum('SDL_GameControllerAxis')
	TypeConv_Enum('SDL_GameControllerButton')
	TypeConv_Enum('SDL_GestureID')
	TypeConv_Enum('SDL_GLattr')
	TypeConv_Enum('SDL_Keycode')
	TypeConv_Enum('SDL_Keymod')
	TypeConv_Enum('SDL_RendererFlip')
	TypeConv_Enum('SDL_Scancode')
	TypeConv_Enum('SDL_SystemCursor')
	TypeConv_Enum('SDL_TimerID')
	TypeConv_Enum('SDL_TouchID')
	TypeConv_Class('SDL_AudioCVT@')
	TypeConv_Class('SDL_AudioSpec@')
	TypeConv_Class('SDL_AudioSpec@:const')
	'SDL_Cursor@' => TypeConv(
			'Cursor', 'Once', [],
			'SDL_Cursor *${arg.name} = Object_Cursor::GetObject(args, ${idx})->GetEntity();',
			nil,
			R'''
			SDL_Cursor *_rtn = ${fi.MakeCaller()};
			Value _rtnVal;
			if (_rtn != NULL) {
				_rtnVal = Value(new Object_Cursor(_rtn, true));
			} else if (*SDL_GetError() != '\0') {
				SetError_SDL(sig);
				return Value::Null;
			}
			return ReturnValue(env, sig, args, _rtnVal);''')
	TypeConv_Class('SDL_DisplayMode@')
	TypeConv_Class('SDL_DisplayMode@:const')
	TypeConv_Class('SDL_Event@')
	TypeConv_Class('SDL_Event@:const')
	TypeConv_Class('SDL_Finger@')
	TypeConv_Class('SDL_GameController@')
	TypeConv_Class('SDL_GameControllerButtonBind')
	TypeConv_Class('SDL_GLContext')
	TypeConv_Class('SDL_Haptic@')
	TypeConv_Class('SDL_HapticEffect@')
	TypeConv_Class('SDL_Joystick@')
	TypeConv_Class('SDL_JoystickGUID')
	TypeConv_Class('SDL_Palette@')
	TypeConv_Class('SDL_PixelFormat@')
	TypeConv_Class('SDL_PixelFormat@:const')
	TypeConv_Class('SDL_Point@:const')
	TypeConv_Class('SDL_Rect@')
	TypeConv_Class('SDL_Rect@:const')
	TypeConv_Class('SDL_Renderer@')
	TypeConv_Class('SDL_Surface@')
	TypeConv_Class('SDL_Texture@')
	TypeConv_Class('SDL_Window@')
}

tmplSource = R"""
#include "stdafx.h"

#undef CreateWindow
#undef CreateMutex
#undef CreateSemaphore

Gura_BeginModuleScope(sdl2)

${renderer.RenderImplementation()}

// sdl2.test()
Gura_DeclareFunction(test)
{
}

Gura_ImplementFunction(test)
{
	return Value::Null;
}

void AssignFunctions(Environment &env)
{
	${renderer.RenderAssignment()}
	Gura_AssignFunction(test);
}

Gura_EndModuleScope(sdl2)
""".template()

Renderer('sdl2', decls.children, typeConvDict, &{$funcNameC.sub('^SDL_', '')}) {|renderer|
	if (sys.argv.len() > 1 && sys.argv[1] == 'test') {
		print(renderer.RenderImplementation())
		print(renderer.RenderAssignment())
	} else {
		fileNameOut = 'Functions.cpp'
		tmplSource.render(fileNameOut)
		println(fileNameOut, ' was created')
	}
}
