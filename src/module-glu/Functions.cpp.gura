#!/usr/bin/env gura
sys.path.add('../module-opengl')
import(cbridge_glcmn)

cbridge_glcmn.Implement {

gluBeginCurve(nurb:GLUnurbs@):void {block?} = R'''
	gluBeginCurve(nurb);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluEndCurve(nurb);
	}
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluBeginPolygon(tess:GLUtesselator@):void {block?} = R'''
	gluBeginPolygon(tess);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluEndPolygon(tess);
	}
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluBeginSurface(nurb:GLUnurbs@):void {block?} = R'''
	gluBeginSurface(nurb);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluEndSurface(nurb);
	}
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluBeginTrim(nurb:GLUnurbs@):void {block?} = R'''
	gluBeginTrim(nurb);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluEndTrim(nurb);
	}
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

/*
gluBuild1DMipmapLevels(target:GLenum, internalFormat:GLint, level:GLint, base:GLint, max:GLint, image:image):GLint = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLenum format = static_cast<GLsizei>(GetImageFormat(sig, image));
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const void *data = image->GetBuffer();
	GLint _rtn = gluBuild1DMipmapLevels(target,
					internalFormat, width, format, type, level, base, max, data);
	return Value(_rtn);
''' % {`en, 'markdown',
	R'''
	'''
}
*/

gluBuild1DMipmaps(target:GLenum, internalFormat:GLint, width:GLsizei, format:GLenum, type:GLenum, data:binary):GLint = R'''
	GLint _rtn = gluBuild1DMipmaps(target,
					internalFormat, width, format, type, data->data());
	return Value(_rtn);
''' % {`en, 'markdown',
	R'''
	'''
}

gluBuild1DMipmapsFromImage(target:GLenum, internalFormat:GLint, image:image):GLint = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLenum format = static_cast<GLsizei>(GetImageFormat(sig, image));
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const void *data = image->GetBuffer();
	GLint _rtn = gluBuild1DMipmaps(target,
					internalFormat, width, format, type, data);
	return Value(_rtn);
''' % {`en, 'markdown',
	R'''
	'''
}

/*
gluBuild2DMipmapLevels(target:GLenum, internalFormat:GLint, level:GLint, base:GLint, max:GLint, image:image):GLint = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = static_cast<GLsizei>(GetImageFormat(sig, image));
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const void *data = image->GetBuffer();
	GLint _rtn = gluBuild2DMipmapLevels(target,
					internalFormat, width, height, format, type, level, base, max, data);
	return Value(_rtn);
''' % {`en, 'markdown',
	R'''
	'''
}
*/

gluBuild2DMipmaps(target:GLenum, internalFormat:GLint, width:GLsizei, height:GLsizei, format:GLenum, type:GLenum, data:binary):GLint = R'''
	GLint _rtn = gluBuild2DMipmaps(target,
					internalFormat, width, height, format, type, data->data());
	return Value(_rtn);
''' % {`en, 'markdown',
	R'''
	'''
}

gluBuild2DMipmapsFromImage(target:GLenum, internalFormat:GLint, image:image):GLint = R'''
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = static_cast<GLsizei>(GetImageFormat(sig, image));
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const void *data = image->GetBuffer();
	GLint _rtn = gluBuild2DMipmaps(target,
					internalFormat, width, height, format, type, data);
	return Value(_rtn);
''' % {`en, 'markdown',
	R'''
	'''
}

/*
gluBuild3DMipmapLevels(target:GLenum, internalFormat:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, type:GLenum, level:GLint, base:GLint, max:GLint, data:void@:const):GLint = R'''
''' % {`en, 'markdown',
	R'''
	'''
}

gluBuild3DMipmaps(target:GLenum, internalFormat:GLint, width:GLsizei, height:GLsizei, depth:GLsizei, format:GLenum, type:GLenum, data:void@:const):GLint = R'''

''' % {`en, 'markdown',
	R'''
	'''
}
*/

/*
gluCheckExtension(extName:GLubyte@:const, extString:GLubyte@:const):GLboolean = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

gluCylinder(quad:GLUquadric@, base:GLdouble, top:GLdouble, height:GLdouble, slices:GLint, stacks:GLint):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluDeleteNurbsRenderer(nurb:GLUnurbs@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluDeleteQuadric(quad:GLUquadric@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluDeleteTess(tess:GLUtesselator@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluDisk(quad:GLUquadric@, inner:GLdouble, outer:GLdouble, slices:GLint, loops:GLint):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluEndCurve(nurb:GLUnurbs@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluEndPolygon(tess:GLUtesselator@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluEndSurface(nurb:GLUnurbs@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluEndTrim(nurb:GLUnurbs@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluErrorString(error:GLenum):GLubyte@:const = `auto % {`en, 'markdown',
	R'''
	'''
}

gluGetNurbsProperty(nurb:GLUnurbs@, property:GLenum, data:GLfloat@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluGetString(name:GLenum):GLubyte@:const = `auto % {`en, 'markdown',
	R'''
	'''
}

gluGetTessProperty(tess:GLUtesselator@, which:GLenum, data:GLdouble@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluLoadSamplingMatrices(nurb:GLUnurbs@, model:GLfloat@:const, perspective:GLfloat@:const, view:GLint@:const):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluLookAt(eyeX:GLdouble, eyeY:GLdouble, eyeZ:GLdouble, centerX:GLdouble, centerY:GLdouble, centerZ:GLdouble, upX:GLdouble, upY:GLdouble, upZ:GLdouble):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluNewNurbsRenderer():GLUnurbs@ = `auto % {`en, 'markdown',
	R'''
	'''
}

gluNewQuadric():GLUquadric@ = `auto % {`en, 'markdown',
	R'''
	'''
}

gluNewTess():GLUtesselator@ = `auto % {`en, 'markdown',
	R'''
	'''
}

gluNextContour(tess:GLUtesselator@, type:GLenum):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluNurbsCallback(nurbs:GLUnurbs@, which:GLenum, CallBackFunc:int) = `unsupport % {`en, 'markdown',
	R'''
	'''
}

gluNurbsCallbackData(nurb:GLUnurbs@, userData:int):void = `unsupport % {`en, 'markdown',
	R'''
	'''
}

gluNurbsCallbackDataEXT(nurb:GLUnurbs@, userData:int):void = `unsupport % {`en, 'markdown',
	R'''
	'''
}

gluNurbsCurve(nurb:GLUnurbs@, knots:GLfloat@, stride:GLint,
			  control:GLfloat@, order:GLint, type:GLenum):void = R'''
	GLint knotCount = static_cast<GLint>(knots.GetSize());
	gluNurbsCurve(nurb, knotCount, knots, stride, control, order, type);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluNurbsProperty(nurb:GLUnurbs@, property:GLenum, value:GLfloat):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluNurbsSurface(nurb:GLUnurbs@, sKnots:GLfloat@, tKnots:GLfloat@, sStride:GLint, tStride:GLint,
				control:GLfloat@, sOrder:GLint, tOrder:GLint, type:GLenum):void = R'''
	GLint sKnotCount = static_cast<GLint>(sKnots.GetSize());
	GLint tKnotCount = static_cast<GLint>(tKnots.GetSize());
	gluNurbsSurface(nurb, sKnotCount, sKnots, tKnotCount, tKnots, sStride, tStride,
					control, sOrder, tOrder, type);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluOrtho2D(left:GLdouble, right:GLdouble, bottom:GLdouble, top:GLdouble):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluPartialDisk(quad:GLUquadric@, inner:GLdouble, outer:GLdouble, slices:GLint, loops:GLint, start:GLdouble, sweep:GLdouble):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluPerspective(fovy:GLdouble, aspect:GLdouble, zNear:GLdouble, zFar:GLdouble):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluPickMatrix(x:GLdouble, y:GLdouble, delX:GLdouble, delY:GLdouble, viewport:GLint@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluProject(objX:GLdouble, objY:GLdouble, objZ:GLdouble,
		   model:GLdouble@:const, proj:GLdouble@:const, view:GLint@:const,
		   winX:GLdouble@, winY:GLdouble@, winZ:GLdouble@):GLint = `auto % {`en, 'markdown',
	R'''
	'''
}

gluPwlCurve(nurb:GLUnurbs@, data:GLfloat@, stride:GLint, type:GLenum):void = R'''
	GLint count = static_cast<GLint>(data.GetSize());
	gluPwlCurve(nurb, count, data, stride, type);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluQuadricCallback(quad:GLUquadric@, which:GLenum, CallbackFunc:function):void = R'''
	typedef void (__stdcall *funcType)();
	Object_Quadric::GetObject(args, 0)->SetQuadricErrorProc(CallbackFunc->Reference());
	gluQuadricCallback(quad, which,
		reinterpret_cast<funcType>(Object_Quadric::Callback_QuadricErrorProc));
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluQuadricDrawStyle(quad:GLUquadric@, draw:GLenum):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluQuadricNormals(quad:GLUquadric@, normal:GLenum):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluQuadricOrientation(quad:GLUquadric@, orientation:GLenum):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluQuadricTexture(quad:GLUquadric@, texture:GLboolean):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluScaleImage(imageIn:image, wOut:GLsizei, hOut:GLsizei):GLint = R'''
	GLenum format = GetImageFormat(sig, imageIn);
	if (sig.IsSignalled()) return Value::Null;
	GLsizei wIn = static_cast<GLsizei>(imageIn->GetWidth());
	GLsizei hIn = static_cast<GLsizei>(imageIn->GetHeight());
	GLenum typeIn = GL_UNSIGNED_BYTE;
	const void *dataIn = imageIn->GetBuffer();
	GLenum typeOut = GL_UNSIGNED_BYTE;
	if (sig.IsSignalled()) return Value::Null;
	AutoPtr<Image> imageOut(new Image(imageIn->GetFormat()));
	if (!imageOut->AllocBuffer(sig, wOut, hOut, 0xff)) {
		return Value::Null;
	}
	GLvoid *dataOut = imageOut->GetBuffer();
	GLint rtn = gluScaleImage(format, wIn, hIn, typeIn, dataIn,
										 	wOut, hOut, typeOut, dataOut);
	if (rtn != 0) {
		sig.SetError(ERR_RuntimeError, "gluScaleImage error");
		return Value::Null;
	}
	return Value(new Object_image(env, imageOut.release()));
''' % {`en, 'markdown',
	R'''
	'''
}

gluSphere(quad:GLUquadric@, radius:GLdouble, slices:GLint, stacks:GLint):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluTessBeginContour(tess:GLUtesselator@):void {block?} = R'''
	gluTessBeginContour(tess);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluTessEndContour(tess);
	}
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluTessBeginPolygon(tess:GLUtesselator@, data:int):void {block?} = R'''
	gluTessBeginPolygon(tess, tess); // pass this object pointer to callback
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluTessEndPolygon(tess);
	}
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluTessCallback(tess:GLUtesselator@, which:GLenum, CallBackFunc:int) = `unsupport % {`en, 'markdown',
	R'''
	'''
}

gluTessEndContour(tess:GLUtesselator@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluTessEndPolygon(tess:GLUtesselator@):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluTessNormal(tess:GLUtesselator@, valueX:GLdouble, valueY:GLdouble, valueZ:GLdouble):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluTessProperty(tess:GLUtesselator@, which:GLenum, data:GLdouble):void = `auto % {`en, 'markdown',
	R'''
	'''
}

gluTessVertex(tess:GLUtesselator@, location:GLdouble@):void = R'''
	gluTessVertex(tess, location, tess); // pass this object pointer to callback
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

gluUnProject(winX:GLdouble, winY:GLdouble, winZ:GLdouble, model:GLdouble@:const, proj:GLdouble@:const, view:GLint@:const, objX:GLdouble@, objY:GLdouble@, objZ:GLdouble@):GLint = `auto % {`en, 'markdown',
	R'''
	'''
}

/*
gluUnProject4(winX:GLdouble, winY:GLdouble, winZ:GLdouble, clipW:GLdouble, model:GLdouble@:const, proj:GLdouble@:const, view:GLint@:const, nearPlane:GLdouble, farPlane:GLdouble, objX:GLdouble@, objY:GLdouble@, objZ:GLdouble@, objW:GLdouble@):GLint = `auto % {`en, 'markdown',
	R'''
	'''
}
*/

}

// GLU-specific type converter
cbridge_glcmn.AddTypeConvs {
	'GLUnurbs@' => TypeConv(
			'Nurbs', 'Once', [],
			R'''
			GLUnurbs *${arg.name} = Object_Nurbs::GetObject(args, ${idx})->GetNurbs();
			''',
			nil,
			R'''
			GLUnurbs *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Nurbs(_rtn)));
			''')
	'GLUtesselator@' => TypeConv(
			'Tesselator', 'Once', [],
			R'''
			GLUtesselator *${arg.name} = Object_Tesselator::GetObject(args, ${idx})->GetTesselator();
			''',
			nil,
			R'''
			GLUtesselator *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Tesselator(_rtn)));
			''')
	'GLUquadric@' => TypeConv(
			'Quadric', 'Once', [],
			R'''
			GLUquadric *${arg.name} = Object_Quadric::GetObject(args, ${idx})->GetQuadric();
			''',
			nil,
			R'''
			GLUquadric *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Quadric(_rtn)));
			''')
}

tmplSource = R"""
// Don't edit this file. This has been generated by Functions.cpp.gura.
#include "stdafx.h"

#if defined(GURA_ON_MSWIN)
typedef char GLchar;
#endif

Gura_BeginModuleScope(${renderer.moduleName})

${renderer.RenderImplementation()}

void AssignFunctions(Environment &env)
{
	${renderer.RenderAssignment()}
}

Gura_EndModuleScope(${renderer.moduleName})
""".template()

cbridge_glcmn.Renderer('glu', nil).Render(tmplSource, 'Functions.cpp')
