// Don't edit this file. This has been generated by Functions.cpp.gura.
#include "stdafx.h"

#if defined(GURA_ON_MSWIN)
typedef char GLchar;
#endif

Gura_BeginModuleScope(glu)

const void *GetArrayPointer(Signal sig, GLenum type, const Value &value)
{
	const void *p = NULL;
	if (value.IsType(VTYPE_array_char)) {
		if (type != GL_BYTE) {
			sig.SetError(ERR_TypeError, "invalid argument type");
			return NULL;			
		}
		p = Object_array<char>::GetObject(value)->GetArray()->GetPointer();
	} else if (value.IsType(VTYPE_array_uchar)) {
		if (type != GL_BITMAP &&
			type != GL_UNSIGNED_BYTE &&
			type != GL_UNSIGNED_BYTE_3_3_2 && 
			type != GL_UNSIGNED_BYTE_2_3_3_REV) {
		}
		p = Object_array<UChar>::GetObject(value)->GetArray()->GetPointer();
	} else if (value.IsType(VTYPE_array_short)) {
		if (type != GL_SHORT) {
			sig.SetError(ERR_TypeError, "invalid argument type");
			return NULL;			
		}
		p = Object_array<short>::GetObject(value)->GetArray()->GetPointer();
	} else if (value.IsType(VTYPE_array_ushort)) {
		if (type != GL_UNSIGNED_SHORT &&
			type != GL_UNSIGNED_SHORT_5_6_5 &&
			type != GL_UNSIGNED_SHORT_5_6_5_REV &&
			type != GL_UNSIGNED_SHORT_4_4_4_4 &&
			type != GL_UNSIGNED_SHORT_4_4_4_4_REV &&
			type != GL_UNSIGNED_SHORT_5_5_5_1 &&
			type != GL_UNSIGNED_SHORT_1_5_5_5_REV) {
			sig.SetError(ERR_TypeError, "invalid argument type");
			return NULL;			
		}
		p = Object_array<ushort>::GetObject(value)->GetArray()->GetPointer();
	} else if (value.IsType(VTYPE_array_long)) {
		if (type != GL_INT) {
			sig.SetError(ERR_TypeError, "invalid argument type");
			return NULL;			
		}
		p = Object_array<long>::GetObject(value)->GetArray()->GetPointer();
	} else if (value.IsType(VTYPE_array_ulong)) {
		if (type != GL_UNSIGNED_INT &&
			type != GL_UNSIGNED_INT_8_8_8_8 &&
			type != GL_UNSIGNED_INT_8_8_8_8_REV &&
			type != GL_UNSIGNED_INT_10_10_10_2 &&
			type != GL_UNSIGNED_INT_2_10_10_10_REV) {
			sig.SetError(ERR_TypeError, "invalid argument type");
			return NULL;			
		}
		p = Object_array<ULong>::GetObject(value)->GetArray()->GetPointer();
	} else if (value.IsType(VTYPE_array_float)) {
		if (type != GL_FLOAT) {
			sig.SetError(ERR_TypeError, "invalid argument type");
			return NULL;			
		}
		p = Object_array<float>::GetObject(value)->GetArray()->GetPointer();
	} else {
		sig.SetError(ERR_TypeError, "invalid argument type");
		return NULL;
	}
	return p;
}

// glu.gluBeginCurve
Gura_DeclareFunctionAlias(__gluBeginCurve, "gluBeginCurve")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareBlock(OCCUR_ZeroOrOnce);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluBeginCurve)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	gluBeginCurve(nurb);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluEndCurve(nurb);
	}
	return Value::Null;
}

// glu.gluBeginPolygon
Gura_DeclareFunctionAlias(__gluBeginPolygon, "gluBeginPolygon")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareBlock(OCCUR_ZeroOrOnce);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluBeginPolygon)
{
	Object_Tesselator *tess = Object_Tesselator::GetObject(args, 0);
	tess->CreatePolygonPack(Value::Null);
	gluBeginPolygon(tess->GetTesselator());
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluEndPolygon(tess->GetTesselator());
		tess->DeletePolygonPack();
	}
	return Value::Null;
}

// glu.gluBeginSurface
Gura_DeclareFunctionAlias(__gluBeginSurface, "gluBeginSurface")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareBlock(OCCUR_ZeroOrOnce);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluBeginSurface)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	gluBeginSurface(nurb);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluEndSurface(nurb);
	}
	return Value::Null;
}

// glu.gluBeginTrim
Gura_DeclareFunctionAlias(__gluBeginTrim, "gluBeginTrim")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareBlock(OCCUR_ZeroOrOnce);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluBeginTrim)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	gluBeginTrim(nurb);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluEndTrim(nurb);
	}
	return Value::Null;
}

// glu.gluBuild1DMipmaps
Gura_DeclareFunctionAlias(__gluBuild1DMipmaps, "gluBuild1DMipmaps")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "target", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "internalFormat", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "width", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "format", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "type", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "data", VTYPE_any, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluBuild1DMipmaps)
{
	GLenum target = static_cast<GLenum>(args.GetInt(0));
	GLint internalFormat = args.GetInt(1);
	GLsizei width = args.GetInt(2);
	GLenum format = static_cast<GLenum>(args.GetInt(3));
	GLenum type = static_cast<GLenum>(args.GetInt(4));
	Value data = args.GetValue(5);
	const void *p = GetArrayPointer(sig, type, data);
	if (p == NULL) return Value::Null;
	GLint _rtn = gluBuild1DMipmaps(target,
					internalFormat, width, format, type, p);
	return Value(_rtn);
}

// glu.gluBuild1DMipmapsFromImage
Gura_DeclareFunctionAlias(__gluBuild1DMipmapsFromImage, "gluBuild1DMipmapsFromImage")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "target", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "internalFormat", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "image", VTYPE_image, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluBuild1DMipmapsFromImage)
{
	GLenum target = static_cast<GLenum>(args.GetInt(0));
	GLint internalFormat = args.GetInt(1);
	Image *image = Object_image::GetObject(args, 2)->GetImage();
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLenum format = static_cast<GLsizei>(GetImageFormat(sig, image));
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const void *data = image->GetBuffer();
	GLint _rtn = gluBuild1DMipmaps(target,
					internalFormat, width, format, type, data);
	return Value(_rtn);
}

// glu.gluBuild2DMipmaps
Gura_DeclareFunctionAlias(__gluBuild2DMipmaps, "gluBuild2DMipmaps")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "target", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "internalFormat", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "width", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "height", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "format", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "type", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "data", VTYPE_any, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluBuild2DMipmaps)
{
	GLenum target = static_cast<GLenum>(args.GetInt(0));
	GLint internalFormat = args.GetInt(1);
	GLsizei width = args.GetInt(2);
	GLsizei height = args.GetInt(3);
	GLenum format = static_cast<GLenum>(args.GetInt(4));
	GLenum type = static_cast<GLenum>(args.GetInt(5));
	Value data = args.GetValue(6);
	const void *p = GetArrayPointer(sig, type, data);
	if (p == NULL) return Value::Null;
	GLint _rtn = gluBuild2DMipmaps(target,
					internalFormat, width, height, format, type, p);
	return Value(_rtn);
}

// glu.gluBuild2DMipmapsFromImage
Gura_DeclareFunctionAlias(__gluBuild2DMipmapsFromImage, "gluBuild2DMipmapsFromImage")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "target", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "internalFormat", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "image", VTYPE_image, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluBuild2DMipmapsFromImage)
{
	GLenum target = static_cast<GLenum>(args.GetInt(0));
	GLint internalFormat = args.GetInt(1);
	Image *image = Object_image::GetObject(args, 2)->GetImage();
	GLsizei width = static_cast<GLsizei>(image->GetWidth());
	GLsizei height = static_cast<GLsizei>(image->GetHeight());
	GLenum format = static_cast<GLsizei>(GetImageFormat(sig, image));
	if (sig.IsSignalled()) return Value::Null;
	GLenum type = GL_UNSIGNED_BYTE;
	const void *data = image->GetBuffer();
	GLint _rtn = gluBuild2DMipmaps(target,
					internalFormat, width, height, format, type, data);
	return Value(_rtn);
}

// glu.gluCylinder
Gura_DeclareFunctionAlias(__gluCylinder, "gluCylinder")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "base", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "top", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "height", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "slices", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "stacks", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluCylinder)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	GLdouble base = args.GetDouble(1);
	GLdouble top = args.GetDouble(2);
	GLdouble height = args.GetDouble(3);
	GLint slices = args.GetInt(4);
	GLint stacks = args.GetInt(5);
	gluCylinder(quad, base, top, height, slices, stacks);
	return Value::Null;
}

// glu.gluDeleteNurbsRenderer
Gura_DeclareFunctionAlias(__gluDeleteNurbsRenderer, "gluDeleteNurbsRenderer")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluDeleteNurbsRenderer)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	gluDeleteNurbsRenderer(nurb);
	return Value::Null;
}

// glu.gluDeleteQuadric
Gura_DeclareFunctionAlias(__gluDeleteQuadric, "gluDeleteQuadric")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluDeleteQuadric)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	gluDeleteQuadric(quad);
	return Value::Null;
}

// glu.gluDeleteTess
Gura_DeclareFunctionAlias(__gluDeleteTess, "gluDeleteTess")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluDeleteTess)
{
	GLUtesselator *tess = Object_Tesselator::GetObject(args, 0)->GetTesselator();
	gluDeleteTess(tess);
	return Value::Null;
}

// glu.gluDisk
Gura_DeclareFunctionAlias(__gluDisk, "gluDisk")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "inner", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "outer", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "slices", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "loops", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluDisk)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	GLdouble inner = args.GetDouble(1);
	GLdouble outer = args.GetDouble(2);
	GLint slices = args.GetInt(3);
	GLint loops = args.GetInt(4);
	gluDisk(quad, inner, outer, slices, loops);
	return Value::Null;
}

// glu.gluEndCurve
Gura_DeclareFunctionAlias(__gluEndCurve, "gluEndCurve")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluEndCurve)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	gluEndCurve(nurb);
	return Value::Null;
}

// glu.gluEndPolygon
Gura_DeclareFunctionAlias(__gluEndPolygon, "gluEndPolygon")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluEndPolygon)
{
	Object_Tesselator *tess = Object_Tesselator::GetObject(args, 0);
	gluEndPolygon(tess->GetTesselator());
	tess->DeletePolygonPack();
	return Value::Null;
}

// glu.gluEndSurface
Gura_DeclareFunctionAlias(__gluEndSurface, "gluEndSurface")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluEndSurface)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	gluEndSurface(nurb);
	return Value::Null;
}

// glu.gluEndTrim
Gura_DeclareFunctionAlias(__gluEndTrim, "gluEndTrim")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluEndTrim)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	gluEndTrim(nurb);
	return Value::Null;
}

// glu.gluErrorString
Gura_DeclareFunctionAlias(__gluErrorString, "gluErrorString")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "error", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluErrorString)
{
	GLenum error = static_cast<GLenum>(args.GetInt(0));
	const GLubyte *_rtn = gluErrorString(error);
	return ReturnValue(env, sig, args, Value(reinterpret_cast<const char *>(_rtn)));
}

// glu.gluGetNurbsProperty
Gura_DeclareFunctionAlias(__gluGetNurbsProperty, "gluGetNurbsProperty")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "property", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "data", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluGetNurbsProperty)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	GLenum property = static_cast<GLenum>(args.GetInt(1));
	Array<float> *_data = Object_array<float>::GetObject(args, 2)->GetArray();
	GLfloat *data = reinterpret_cast<GLfloat *>(_data->GetPointer());
	gluGetNurbsProperty(nurb, property, data);
	return Value::Null;
}

// glu.gluGetString
Gura_DeclareFunctionAlias(__gluGetString, "gluGetString")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "name", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluGetString)
{
	GLenum name = static_cast<GLenum>(args.GetInt(0));
	const GLubyte *_rtn = gluGetString(name);
	return ReturnValue(env, sig, args, Value(reinterpret_cast<const char *>(_rtn)));
}

// glu.gluGetTessProperty
Gura_DeclareFunctionAlias(__gluGetTessProperty, "gluGetTessProperty")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	DeclareArg(env, "which", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "data", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluGetTessProperty)
{
	GLUtesselator *tess = Object_Tesselator::GetObject(args, 0)->GetTesselator();
	GLenum which = static_cast<GLenum>(args.GetInt(1));
	Array<double> *_data = Object_array<double>::GetObject(args, 2)->GetArray();
	GLdouble *data = reinterpret_cast<GLdouble *>(_data->GetPointer());
	gluGetTessProperty(tess, which, data);
	return Value::Null;
}

// glu.gluLoadSamplingMatrices
Gura_DeclareFunctionAlias(__gluLoadSamplingMatrices, "gluLoadSamplingMatrices")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "model", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "perspective", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "view", VTYPE_array_int, OCCUR_Once, FLAG_NoMap);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluLoadSamplingMatrices)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	Array<float> *_model = Object_array<float>::GetObject(args, 1)->GetArray();
	GLfloat *model = reinterpret_cast<GLfloat *>(_model->GetPointer());
	Array<float> *_perspective = Object_array<float>::GetObject(args, 2)->GetArray();
	GLfloat *perspective = reinterpret_cast<GLfloat *>(_perspective->GetPointer());
	Array<int> *_view = Object_array<int>::GetObject(args, 3)->GetArray();
	GLint *view = reinterpret_cast<GLint *>(_view->GetPointer());
	gluLoadSamplingMatrices(nurb, model, perspective, view);
	return Value::Null;
}

// glu.gluLookAt
Gura_DeclareFunctionAlias(__gluLookAt, "gluLookAt")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "eyeX", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "eyeY", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "eyeZ", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "centerX", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "centerY", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "centerZ", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "upX", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "upY", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "upZ", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluLookAt)
{
	GLdouble eyeX = args.GetDouble(0);
	GLdouble eyeY = args.GetDouble(1);
	GLdouble eyeZ = args.GetDouble(2);
	GLdouble centerX = args.GetDouble(3);
	GLdouble centerY = args.GetDouble(4);
	GLdouble centerZ = args.GetDouble(5);
	GLdouble upX = args.GetDouble(6);
	GLdouble upY = args.GetDouble(7);
	GLdouble upZ = args.GetDouble(8);
	gluLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
	return Value::Null;
}

// glu.gluNewNurbsRenderer
Gura_DeclareFunctionAlias(__gluNewNurbsRenderer, "gluNewNurbsRenderer")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNewNurbsRenderer)
{
	GLUnurbs *_rtn = gluNewNurbsRenderer();
	return ReturnValue(env, sig, args, Value(new Object_Nurbs(_rtn)));
}

// glu.gluNewQuadric
Gura_DeclareFunctionAlias(__gluNewQuadric, "gluNewQuadric")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNewQuadric)
{
	GLUquadric *_rtn = gluNewQuadric();
	return ReturnValue(env, sig, args, Value(new Object_Quadric(_rtn)));
}

// glu.gluNewTess
Gura_DeclareFunctionAlias(__gluNewTess, "gluNewTess")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNewTess)
{
	GLUtesselator *_rtn = gluNewTess();
	return ReturnValue(env, sig, args, Value(new Object_Tesselator(_rtn)));
}

// glu.gluNextContour
Gura_DeclareFunctionAlias(__gluNextContour, "gluNextContour")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	DeclareArg(env, "type", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNextContour)
{
	GLUtesselator *tess = Object_Tesselator::GetObject(args, 0)->GetTesselator();
	GLenum type = static_cast<GLenum>(args.GetInt(1));
	gluNextContour(tess, type);
	return Value::Null;
}

// glu.gluNurbsCallback
Gura_DeclareFunctionAlias(__gluNurbsCallback, "gluNurbsCallback")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "nurbs", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "which", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "func", VTYPE_function, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNurbsCallback)
{
	Object_Nurbs *nurbs = Object_Nurbs::GetObject(args, 0);
	GLenum which = static_cast<GLenum>(args.GetInt(1));
	const Function *func = Object_function::GetObject(args, 2)->GetFunction();
	nurbs->SetCallback(sig, which, func);
	return Value::Null;
}

// glu.gluNurbsCallbackData
Gura_DeclareFunctionAlias(__gluNurbsCallbackData, "gluNurbsCallbackData")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "userData", VTYPE_any, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNurbsCallbackData)
{
	Object_Nurbs *nurb = Object_Nurbs::GetObject(args, 0);
	Value userData = args.GetValue(1);
#if defined(GLU_VERSION_1_3)
	nurb->SetCallbackData(userData);
	gluNurbsCallbackData(nurb->GetNurbs(), nurb);
	return Value::Null;
#else
	sig.SetError(ERR_NotImplementedError,
				"this function is provided in GLU 1.3 or later");
	return Value::Null;
#endif
}

// glu.gluNurbsCallbackDataEXT
Gura_DeclareFunctionAlias(__gluNurbsCallbackDataEXT, "gluNurbsCallbackDataEXT")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "userData", VTYPE_any, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNurbsCallbackDataEXT)
{
	Object_Nurbs *nurb = Object_Nurbs::GetObject(args, 0);
	Value userData = args.GetValue(1);
#if defined(GLU_VERSION_1_3)
	nurb->SetCallbackDataEXT(userData);
	gluNurbsCallbackData(nurb->GetNurbs(), nurb);
	return Value::Null;
#else
	sig.SetError(ERR_NotImplementedError,
				"this function is provided in GLU 1.3 or later");
	return Value::Null;
#endif
}

// glu.gluNurbsCurve
Gura_DeclareFunctionAlias(__gluNurbsCurve, "gluNurbsCurve")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "knots", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "stride", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "control", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "order", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "type", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNurbsCurve)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	Array<float> *_knots = Object_array<float>::GetObject(args, 1)->GetArray();
	GLfloat *knots = reinterpret_cast<GLfloat *>(_knots->GetPointer());
	GLint stride = args.GetInt(2);
	Array<float> *_control = Object_array<float>::GetObject(args, 3)->GetArray();
	GLfloat *control = reinterpret_cast<GLfloat *>(_control->GetPointer());
	GLint order = args.GetInt(4);
	GLenum type = static_cast<GLenum>(args.GetInt(5));
	GLint knotCount = static_cast<GLint>(_knots->GetSize());
	gluNurbsCurve(nurb, knotCount, knots, stride, control, order, type);
	return Value::Null;
}

// glu.gluNurbsProperty
Gura_DeclareFunctionAlias(__gluNurbsProperty, "gluNurbsProperty")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "property", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "value", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNurbsProperty)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	GLenum property = static_cast<GLenum>(args.GetInt(1));
	GLfloat value = args.GetFloat(2);
	gluNurbsProperty(nurb, property, value);
	return Value::Null;
}

// glu.gluNurbsSurface
Gura_DeclareFunctionAlias(__gluNurbsSurface, "gluNurbsSurface")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "sKnots", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "tKnots", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "sStride", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "tStride", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "control", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "sOrder", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "tOrder", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "type", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluNurbsSurface)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	Array<float> *_sKnots = Object_array<float>::GetObject(args, 1)->GetArray();
	GLfloat *sKnots = reinterpret_cast<GLfloat *>(_sKnots->GetPointer());
	Array<float> *_tKnots = Object_array<float>::GetObject(args, 2)->GetArray();
	GLfloat *tKnots = reinterpret_cast<GLfloat *>(_tKnots->GetPointer());
	GLint sStride = args.GetInt(3);
	GLint tStride = args.GetInt(4);
	Array<float> *_control = Object_array<float>::GetObject(args, 5)->GetArray();
	GLfloat *control = reinterpret_cast<GLfloat *>(_control->GetPointer());
	GLint sOrder = args.GetInt(6);
	GLint tOrder = args.GetInt(7);
	GLenum type = static_cast<GLenum>(args.GetInt(8));
	GLint sKnotCount = static_cast<GLint>(_sKnots->GetSize());
	GLint tKnotCount = static_cast<GLint>(_tKnots->GetSize());
	gluNurbsSurface(nurb, sKnotCount, sKnots, tKnotCount, tKnots, sStride, tStride,
	control, sOrder, tOrder, type);
	return Value::Null;
}

// glu.gluOrtho2D
Gura_DeclareFunctionAlias(__gluOrtho2D, "gluOrtho2D")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "left", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "right", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "bottom", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "top", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluOrtho2D)
{
	GLdouble left = args.GetDouble(0);
	GLdouble right = args.GetDouble(1);
	GLdouble bottom = args.GetDouble(2);
	GLdouble top = args.GetDouble(3);
	gluOrtho2D(left, right, bottom, top);
	return Value::Null;
}

// glu.gluPartialDisk
Gura_DeclareFunctionAlias(__gluPartialDisk, "gluPartialDisk")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "inner", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "outer", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "slices", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "loops", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "start", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "sweep", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluPartialDisk)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	GLdouble inner = args.GetDouble(1);
	GLdouble outer = args.GetDouble(2);
	GLint slices = args.GetInt(3);
	GLint loops = args.GetInt(4);
	GLdouble start = args.GetDouble(5);
	GLdouble sweep = args.GetDouble(6);
	gluPartialDisk(quad, inner, outer, slices, loops, start, sweep);
	return Value::Null;
}

// glu.gluPerspective
Gura_DeclareFunctionAlias(__gluPerspective, "gluPerspective")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "fovy", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "aspect", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "zNear", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "zFar", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluPerspective)
{
	GLdouble fovy = args.GetDouble(0);
	GLdouble aspect = args.GetDouble(1);
	GLdouble zNear = args.GetDouble(2);
	GLdouble zFar = args.GetDouble(3);
	gluPerspective(fovy, aspect, zNear, zFar);
	return Value::Null;
}

// glu.gluPickMatrix
Gura_DeclareFunctionAlias(__gluPickMatrix, "gluPickMatrix")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "x", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "y", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "delX", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "delY", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "viewport", VTYPE_array_int, OCCUR_Once, FLAG_NoMap);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluPickMatrix)
{
	GLdouble x = args.GetDouble(0);
	GLdouble y = args.GetDouble(1);
	GLdouble delX = args.GetDouble(2);
	GLdouble delY = args.GetDouble(3);
	Array<int> *_viewport = Object_array<int>::GetObject(args, 4)->GetArray();
	GLint *viewport = reinterpret_cast<GLint *>(_viewport->GetPointer());
	gluPickMatrix(x, y, delX, delY, viewport);
	return Value::Null;
}

// glu.gluProject
Gura_DeclareFunctionAlias(__gluProject, "gluProject")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "objX", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "objY", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "objZ", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "model", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "proj", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "view", VTYPE_array_int, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "winX", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "winY", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "winZ", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluProject)
{
	GLdouble objX = args.GetDouble(0);
	GLdouble objY = args.GetDouble(1);
	GLdouble objZ = args.GetDouble(2);
	Array<double> *_model = Object_array<double>::GetObject(args, 3)->GetArray();
	GLdouble *model = reinterpret_cast<GLdouble *>(_model->GetPointer());
	Array<double> *_proj = Object_array<double>::GetObject(args, 4)->GetArray();
	GLdouble *proj = reinterpret_cast<GLdouble *>(_proj->GetPointer());
	Array<int> *_view = Object_array<int>::GetObject(args, 5)->GetArray();
	GLint *view = reinterpret_cast<GLint *>(_view->GetPointer());
	Array<double> *_winX = Object_array<double>::GetObject(args, 6)->GetArray();
	GLdouble *winX = reinterpret_cast<GLdouble *>(_winX->GetPointer());
	Array<double> *_winY = Object_array<double>::GetObject(args, 7)->GetArray();
	GLdouble *winY = reinterpret_cast<GLdouble *>(_winY->GetPointer());
	Array<double> *_winZ = Object_array<double>::GetObject(args, 8)->GetArray();
	GLdouble *winZ = reinterpret_cast<GLdouble *>(_winZ->GetPointer());
	GLint _rtn = gluProject(objX, objY, objZ, model, proj, view, winX, winY, winZ);
	return ReturnValue(env, sig, args, Value(_rtn));
}

// glu.gluPwlCurve
Gura_DeclareFunctionAlias(__gluPwlCurve, "gluPwlCurve")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "nurb", VTYPE_Nurbs, OCCUR_Once, FLAG_None);
	DeclareArg(env, "data", VTYPE_array_float, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "stride", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "type", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluPwlCurve)
{
	GLUnurbs *nurb = Object_Nurbs::GetObject(args, 0)->GetNurbs();
	Array<float> *_data = Object_array<float>::GetObject(args, 1)->GetArray();
	GLfloat *data = reinterpret_cast<GLfloat *>(_data->GetPointer());
	GLint stride = args.GetInt(2);
	GLenum type = static_cast<GLenum>(args.GetInt(3));
	GLint count = static_cast<GLint>(_data->GetSize());
	gluPwlCurve(nurb, count, data, stride, type);
	return Value::Null;
}

// glu.gluQuadricCallback
Gura_DeclareFunctionAlias(__gluQuadricCallback, "gluQuadricCallback")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "which", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "func", VTYPE_function, OCCUR_Once, FLAG_Nil);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluQuadricCallback)
{
	Object_Quadric *quad = Object_Quadric::GetObject(args, 0);
	GLenum which = static_cast<GLenum>(args.GetInt(1));
	const Function *func = args.IsValid(2)? Object_function::GetObject(args, 2)->GetFunction() : NULL;
	quad->SetCallback(sig, which, func);
	return Value::Null;
}

// glu.gluQuadricDrawStyle
Gura_DeclareFunctionAlias(__gluQuadricDrawStyle, "gluQuadricDrawStyle")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "draw", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluQuadricDrawStyle)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	GLenum draw = static_cast<GLenum>(args.GetInt(1));
	gluQuadricDrawStyle(quad, draw);
	return Value::Null;
}

// glu.gluQuadricNormals
Gura_DeclareFunctionAlias(__gluQuadricNormals, "gluQuadricNormals")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "normal", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluQuadricNormals)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	GLenum normal = static_cast<GLenum>(args.GetInt(1));
	gluQuadricNormals(quad, normal);
	return Value::Null;
}

// glu.gluQuadricOrientation
Gura_DeclareFunctionAlias(__gluQuadricOrientation, "gluQuadricOrientation")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "orientation", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluQuadricOrientation)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	GLenum orientation = static_cast<GLenum>(args.GetInt(1));
	gluQuadricOrientation(quad, orientation);
	return Value::Null;
}

// glu.gluQuadricTexture
Gura_DeclareFunctionAlias(__gluQuadricTexture, "gluQuadricTexture")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "texture", VTYPE_boolean, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluQuadricTexture)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	GLboolean texture = (args.GetBoolean(1)? GL_TRUE : GL_FALSE);
	gluQuadricTexture(quad, texture);
	return Value::Null;
}

// glu.gluScaleImage
Gura_DeclareFunctionAlias(__gluScaleImage, "gluScaleImage")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "imageIn", VTYPE_image, OCCUR_Once, FLAG_None);
	DeclareArg(env, "wOut", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "hOut", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluScaleImage)
{
	Image *imageIn = Object_image::GetObject(args, 0)->GetImage();
	GLsizei wOut = args.GetInt(1);
	GLsizei hOut = args.GetInt(2);
	GLenum format = GetImageFormat(sig, imageIn);
	if (sig.IsSignalled()) return Value::Null;
	GLsizei wIn = static_cast<GLsizei>(imageIn->GetWidth());
	GLsizei hIn = static_cast<GLsizei>(imageIn->GetHeight());
	GLenum typeIn = GL_UNSIGNED_BYTE;
	const void *dataIn = imageIn->GetBuffer();
	GLenum typeOut = GL_UNSIGNED_BYTE;
	if (sig.IsSignalled()) return Value::Null;
	AutoPtr<Image> imageOut(new Image(imageIn->GetFormat()));
	if (!imageOut->AllocBuffer(sig, wOut, hOut, 0xff)) {
		return Value::Null;
	}
	GLvoid *dataOut = imageOut->GetBuffer();
	GLint rtn = gluScaleImage(format, wIn, hIn, typeIn, dataIn,
										 	wOut, hOut, typeOut, dataOut);
	if (rtn != 0) {
		sig.SetError(ERR_RuntimeError, "gluScaleImage error");
		return Value::Null;
	}
	return Value(new Object_image(env, imageOut.release()));
}

// glu.gluSphere
Gura_DeclareFunctionAlias(__gluSphere, "gluSphere")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "quad", VTYPE_Quadric, OCCUR_Once, FLAG_None);
	DeclareArg(env, "radius", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "slices", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "stacks", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluSphere)
{
	GLUquadric *quad = Object_Quadric::GetObject(args, 0)->GetQuadric();
	GLdouble radius = args.GetDouble(1);
	GLint slices = args.GetInt(2);
	GLint stacks = args.GetInt(3);
	gluSphere(quad, radius, slices, stacks);
	return Value::Null;
}

// glu.gluTessBeginContour
Gura_DeclareFunctionAlias(__gluTessBeginContour, "gluTessBeginContour")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareBlock(OCCUR_ZeroOrOnce);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluTessBeginContour)
{
	GLUtesselator *tess = Object_Tesselator::GetObject(args, 0)->GetTesselator();
	gluTessBeginContour(tess);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluTessEndContour(tess);
	}
	return Value::Null;
}

// glu.gluTessBeginPolygon
Gura_DeclareFunctionAlias(__gluTessBeginPolygon, "gluTessBeginPolygon")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareBlock(OCCUR_ZeroOrOnce);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	DeclareArg(env, "polygon_data", VTYPE_any, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluTessBeginPolygon)
{
	Object_Tesselator *tess = Object_Tesselator::GetObject(args, 0);
	Value polygon_data = args.GetValue(1);
	PolygonPack *pPolygonPack = tess->CreatePolygonPack(polygon_data);
	gluTessBeginPolygon(tess->GetTesselator(), pPolygonPack);
	if (args.IsBlockSpecified()) {
		SeqPostHandler *pSeqPostHandler = NULL;
		const Expr_Block *pExprBlock = args.GetBlock(env, sig);
		if (sig.IsSignalled()) return Value::Null;
		pExprBlock->Exec2(env, sig, pSeqPostHandler);
		gluTessEndPolygon(tess->GetTesselator());
		tess->DeletePolygonPack();
	}
	return Value::Null;
}

// glu.gluTessCallback
Gura_DeclareFunctionAlias(__gluTessCallback, "gluTessCallback")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	DeclareArg(env, "which", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "func", VTYPE_function, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluTessCallback)
{
	Object_Tesselator *tess = Object_Tesselator::GetObject(args, 0);
	GLenum which = static_cast<GLenum>(args.GetInt(1));
	const Function *func = Object_function::GetObject(args, 2)->GetFunction();
	tess->SetCallback(sig, which, func);
	return Value::Null;
}

// glu.gluTessEndContour
Gura_DeclareFunctionAlias(__gluTessEndContour, "gluTessEndContour")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluTessEndContour)
{
	GLUtesselator *tess = Object_Tesselator::GetObject(args, 0)->GetTesselator();
	gluTessEndContour(tess);
	return Value::Null;
}

// glu.gluTessEndPolygon
Gura_DeclareFunctionAlias(__gluTessEndPolygon, "gluTessEndPolygon")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluTessEndPolygon)
{
	Object_Tesselator *tess = Object_Tesselator::GetObject(args, 0);
	gluTessEndPolygon(tess->GetTesselator());
	tess->DeletePolygonPack();
	return Value::Null;
}

// glu.gluTessNormal
Gura_DeclareFunctionAlias(__gluTessNormal, "gluTessNormal")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	DeclareArg(env, "valueX", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "valueY", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "valueZ", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluTessNormal)
{
	GLUtesselator *tess = Object_Tesselator::GetObject(args, 0)->GetTesselator();
	GLdouble valueX = args.GetDouble(1);
	GLdouble valueY = args.GetDouble(2);
	GLdouble valueZ = args.GetDouble(3);
	gluTessNormal(tess, valueX, valueY, valueZ);
	return Value::Null;
}

// glu.gluTessProperty
Gura_DeclareFunctionAlias(__gluTessProperty, "gluTessProperty")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	DeclareArg(env, "which", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "data", VTYPE_number, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluTessProperty)
{
	GLUtesselator *tess = Object_Tesselator::GetObject(args, 0)->GetTesselator();
	GLenum which = static_cast<GLenum>(args.GetInt(1));
	GLdouble data = args.GetDouble(2);
	gluTessProperty(tess, which, data);
	return Value::Null;
}

// glu.gluTessVertex
Gura_DeclareFunctionAlias(__gluTessVertex, "gluTessVertex")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
	DeclareArg(env, "tess", VTYPE_Tesselator, OCCUR_Once, FLAG_None);
	DeclareArg(env, "location", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "vertex_data", VTYPE_any, OCCUR_Once, FLAG_None);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluTessVertex)
{
	Object_Tesselator *tess = Object_Tesselator::GetObject(args, 0);
	Array<double> *_location = Object_array<double>::GetObject(args, 1)->GetArray();
	GLdouble *location = reinterpret_cast<GLdouble *>(_location->GetPointer());
	Value vertex_data = args.GetValue(2);
	PolygonPack *pPolygonPack = tess->GetPolygonPack();
	if (pPolygonPack == NULL) {
		sig.SetError(ERR_SyntaxError, "gluTessBeginPolygon has not been called");
		return Value::Null;
	}
	VertexPack *pVertexPack = pPolygonPack->CreateVertexPack(vertex_data);
	gluTessVertex(tess->GetTesselator(), location, pVertexPack);
	return Value::Null;
}

// glu.gluUnProject
Gura_DeclareFunctionAlias(__gluUnProject, "gluUnProject")
{
	SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_None);
	DeclareArg(env, "winX", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "winY", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "winZ", VTYPE_number, OCCUR_Once, FLAG_None);
	DeclareArg(env, "model", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "proj", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "view", VTYPE_array_int, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "objX", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "objY", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	DeclareArg(env, "objZ", VTYPE_array_double, OCCUR_Once, FLAG_NoMap);
	AddHelp(
		Gura_Symbol(en), Help::FMT_markdown,
		"");
}

Gura_ImplementFunction(__gluUnProject)
{
	GLdouble winX = args.GetDouble(0);
	GLdouble winY = args.GetDouble(1);
	GLdouble winZ = args.GetDouble(2);
	Array<double> *_model = Object_array<double>::GetObject(args, 3)->GetArray();
	GLdouble *model = reinterpret_cast<GLdouble *>(_model->GetPointer());
	Array<double> *_proj = Object_array<double>::GetObject(args, 4)->GetArray();
	GLdouble *proj = reinterpret_cast<GLdouble *>(_proj->GetPointer());
	Array<int> *_view = Object_array<int>::GetObject(args, 5)->GetArray();
	GLint *view = reinterpret_cast<GLint *>(_view->GetPointer());
	Array<double> *_objX = Object_array<double>::GetObject(args, 6)->GetArray();
	GLdouble *objX = reinterpret_cast<GLdouble *>(_objX->GetPointer());
	Array<double> *_objY = Object_array<double>::GetObject(args, 7)->GetArray();
	GLdouble *objY = reinterpret_cast<GLdouble *>(_objY->GetPointer());
	Array<double> *_objZ = Object_array<double>::GetObject(args, 8)->GetArray();
	GLdouble *objZ = reinterpret_cast<GLdouble *>(_objZ->GetPointer());
	GLint _rtn = gluUnProject(winX, winY, winZ, model, proj, view, objX, objY, objZ);
	return ReturnValue(env, sig, args, Value(_rtn));
}


void AssignFunctions(Environment &env)
{
	Gura_AssignFunction(__gluBeginCurve);
	Gura_AssignFunction(__gluBeginPolygon);
	Gura_AssignFunction(__gluBeginSurface);
	Gura_AssignFunction(__gluBeginTrim);
	Gura_AssignFunction(__gluBuild1DMipmaps);
	Gura_AssignFunction(__gluBuild1DMipmapsFromImage);
	Gura_AssignFunction(__gluBuild2DMipmaps);
	Gura_AssignFunction(__gluBuild2DMipmapsFromImage);
	Gura_AssignFunction(__gluCylinder);
	Gura_AssignFunction(__gluDeleteNurbsRenderer);
	Gura_AssignFunction(__gluDeleteQuadric);
	Gura_AssignFunction(__gluDeleteTess);
	Gura_AssignFunction(__gluDisk);
	Gura_AssignFunction(__gluEndCurve);
	Gura_AssignFunction(__gluEndPolygon);
	Gura_AssignFunction(__gluEndSurface);
	Gura_AssignFunction(__gluEndTrim);
	Gura_AssignFunction(__gluErrorString);
	Gura_AssignFunction(__gluGetNurbsProperty);
	Gura_AssignFunction(__gluGetString);
	Gura_AssignFunction(__gluGetTessProperty);
	Gura_AssignFunction(__gluLoadSamplingMatrices);
	Gura_AssignFunction(__gluLookAt);
	Gura_AssignFunction(__gluNewNurbsRenderer);
	Gura_AssignFunction(__gluNewQuadric);
	Gura_AssignFunction(__gluNewTess);
	Gura_AssignFunction(__gluNextContour);
	Gura_AssignFunction(__gluNurbsCallback);
	Gura_AssignFunction(__gluNurbsCallbackData);
	Gura_AssignFunction(__gluNurbsCallbackDataEXT);
	Gura_AssignFunction(__gluNurbsCurve);
	Gura_AssignFunction(__gluNurbsProperty);
	Gura_AssignFunction(__gluNurbsSurface);
	Gura_AssignFunction(__gluOrtho2D);
	Gura_AssignFunction(__gluPartialDisk);
	Gura_AssignFunction(__gluPerspective);
	Gura_AssignFunction(__gluPickMatrix);
	Gura_AssignFunction(__gluProject);
	Gura_AssignFunction(__gluPwlCurve);
	Gura_AssignFunction(__gluQuadricCallback);
	Gura_AssignFunction(__gluQuadricDrawStyle);
	Gura_AssignFunction(__gluQuadricNormals);
	Gura_AssignFunction(__gluQuadricOrientation);
	Gura_AssignFunction(__gluQuadricTexture);
	Gura_AssignFunction(__gluScaleImage);
	Gura_AssignFunction(__gluSphere);
	Gura_AssignFunction(__gluTessBeginContour);
	Gura_AssignFunction(__gluTessBeginPolygon);
	Gura_AssignFunction(__gluTessCallback);
	Gura_AssignFunction(__gluTessEndContour);
	Gura_AssignFunction(__gluTessEndPolygon);
	Gura_AssignFunction(__gluTessNormal);
	Gura_AssignFunction(__gluTessProperty);
	Gura_AssignFunction(__gluTessVertex);
	Gura_AssignFunction(__gluUnProject);
}

Gura_EndModuleScope(glu)
