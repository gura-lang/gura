#!/usr/bin/env gura
import(cbridge)

decls = `{
glutInit(argv[]:string) {block?} = R'''
	int argc = static_cast<int>(argv.size());
	char **_argv = NULL;
	if (argc > 0) {
		_argv = new char *[argc];
		int i = 0;
		foreach_const (ValueList, pValue, argv) {
			_argv[i++] = strdup(pValue->GetString());
		}
	}
	glutInit(&argc, _argv);
	Value _rtnVal;
	ValueList &valList = _rtnVal.InitAsList(env);
	if (argc > 0) {
		valList.reserve(argc);
		for (int i = 0; i < argc; i++) {
			valList.push_back(Value(_argv[i]));
			::free(_argv[i]);
		}
		delete[] _argv;
	}
	return ReturnValue(env, sig, args, _rtnVal);
''' % {`en, 'markdown',
	R'''
	`glutInit` is used to initialize the GLUT library.
	'''
}

glutInitDisplayMode(mode:unsigned_int):void:map = `auto % {`en, 'markdown',
	R'''
	`glutInitDisplayMode` sets the *initial display mode*.
	'''
}

glutInitDisplayString(string:char@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutInitWindowPosition(x:int, y:int):void:map = `auto % {`en, 'markdown',
	R'''
	`glutInitWindowPosition` sets the initial window position.	
	'''
}

glutInitWindowSize(width:int, height:int):void:map = `auto % {`en, 'markdown',
	R'''
	`glutInitWindowSize` sets the initial window size.	
	'''
}

glutMainLoop():void = `auto % {`en, 'markdown',
	R'''
	`glutMainLoop` enters the GLUT event processing loop.
	'''
}

glutCreateWindow(title:char@:const):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	`glutCreateWindow` creates a top-level window.
	'''
}

glutCreateSubWindow(win:int, x:int, y:int, width:int, height:int):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	`glutCreateSubWindow` creates a subwindow.
	'''
}

glutDestroyWindow(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	`glutDestroyWindow` destroys the specified window.
	'''
}

glutPostRedisplay():void = `auto % {`en, 'markdown',
	R'''
	`glutPostRedisplay marks the *current window* as needing to be redisplayed.
	'''
}

glutPostWindowRedisplay(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSwapBuffers():void = `auto % {`en, 'markdown',
	R'''
	`glutSwapBuffers` swaps the buffers of the *current window* if double buffered.
	'''
}

glutGetWindow():int {block?} = `auto % {`en, 'markdown',
	R'''
	`glutGetWindow` returns the identifier of the *current window*.
	'''
}

glutSetWindow(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	`glutSetWindow` sets the *current window*.
	'''
}

glutSetWindowTitle(title:char@:const):void:map = `auto % {`en, 'markdown',
	R'''
	`glutSetWindowTitle` changes the window title of the current top-level window.
	'''
}

glutSetIconTitle(title:char@:const):void:map = `auto % {`en, 'markdown',
	R'''
	`glutSetIconTitle` changes the icon title of the current top-level window.
	'''
}

glutPositionWindow(x:int, y:int):void:map = `auto % {`en, 'markdown',
	R'''
	`glutPositionWindow` requests a change to the position of the *current window*.
	'''
}

glutReshapeWindow(width:int, height:int):void:map = `auto % {`en, 'markdown',
	R'''
	`glutReshapeWindow` requests a change to the size of the *current window*.
	'''
}

glutPopWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPushWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutIconifyWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutShowWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutHideWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutFullScreen():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetCursor(cursor:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWarpPointer(x:int, y:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

//glutSurfaceTexture(target:GLenum, internalformat:GLenum, surfacewin:int):void:map = `auto % {`en, 'markdown',
//	R'''
//	'''
//}

//glutWMCloseFunc(func:function):void = R'''
//	g_pContext->funcPackOnWMClose.SetFunc(env, sig, func->Reference());
//	glutWMCloseFunc(OnWMClose);
//	return Value::Null;
//''' % {`en, 'markdown',
//	R'''
//	'''
//}

//glutCheckLoop():void = `auto % {`en, 'markdown',
//	R'''
//	'''
//}

glutEstablishOverlay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutRemoveOverlay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutUseLayer(layer:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPostOverlayRedisplay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPostWindowOverlayRedisplay(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutShowOverlay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutHideOverlay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutCreateMenu(func:function):int {block?} = R'''
	g_pContext->funcPackOnMenu.SetFunc(env, sig, func->Reference());
	int _rtn = glutCreateMenu(OnMenu);
	return ReturnValue(env, sig, args, Value(_rtn));
''' % {`en, 'markdown',
	R'''
	'''
}

glutDestroyMenu(menu:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGetMenu():int {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetMenu(menu:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutAddMenuEntry(label:char@:const, value:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutAddSubMenu(label:char@:const, submenu:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutChangeToMenuEntry(item:int, label:char@:const, value:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutChangeToSubMenu(item:int, label:char@:const, submenu:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutRemoveMenuItem(item:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutAttachMenu(button:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutDetachMenu(button:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutDisplayFunc(func:function):void = R'''
	g_pContext->funcPackOnDisplay.SetFunc(env, sig, func->Reference());
	glutDisplayFunc(OnDisplay);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutReshapeFunc(func:function):void = R'''
	g_pContext->funcPackOnReshape.SetFunc(env, sig, func->Reference());
	glutReshapeFunc(OnReshape);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutKeyboardFunc(func:function):void = R'''
	g_pContext->funcPackOnKeyboard.SetFunc(env, sig, func->Reference());
	glutKeyboardFunc(OnKeyboard);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutMouseFunc(func:function):void = R'''
	g_pContext->funcPackOnMouse.SetFunc(env, sig, func->Reference());
	glutMouseFunc(OnMouse);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutMotionFunc(func:function):void = R'''
	g_pContext->funcPackOnMotion.SetFunc(env, sig, func->Reference());
	glutMotionFunc(OnMotion);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutPassiveMotionFunc(func:function):void = R'''
	g_pContext->funcPackOnPassiveMotion.SetFunc(env, sig, func->Reference());
	glutPassiveMotionFunc(OnPassiveMotion);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutEntryFunc(func:function):void = R'''
	g_pContext->funcPackOnEntry.SetFunc(env, sig, func->Reference());
	glutEntryFunc(OnEntry);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutVisibilityFunc(func:function):void = R'''
	g_pContext->funcPackOnVisibility.SetFunc(env, sig, func->Reference());
	glutVisibilityFunc(OnVisibility);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutIdleFunc(func:function):void = R'''
	g_pContext->funcPackOnIdle.SetFunc(env, sig, func->Reference());
	glutIdleFunc(OnIdle);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutTimerFunc(millis:unsigned_int, func:function, value:int):void = R'''
	g_pContext->funcPackOnTimer.SetFunc(env, sig, func->Reference());
	glutTimerFunc(millis, OnTimer, value);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutMenuStateFunc(func:function):void = R'''
	g_pContext->funcPackOnMenuState.SetFunc(env, sig, func->Reference());
	glutMenuStateFunc(OnMenuState);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpecialFunc(func:function):void = R'''
	g_pContext->funcPackOnSpecial.SetFunc(env, sig, func->Reference());
	glutSpecialFunc(OnSpecial);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpaceballMotionFunc(func:function):void = R'''
	g_pContext->funcPackOnSpaceballMotion.SetFunc(env, sig, func->Reference());
	glutSpaceballMotionFunc(OnSpaceballMotion);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpaceballRotateFunc(func:function):void = R'''
	g_pContext->funcPackOnSpaceballRotate.SetFunc(env, sig, func->Reference());
	glutSpaceballRotateFunc(OnSpaceballRotate);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpaceballButtonFunc(func:function):void = R'''
	g_pContext->funcPackOnSpaceballButton.SetFunc(env, sig, func->Reference());
	glutSpaceballButtonFunc(OnSpaceballButton);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutButtonBoxFunc(func:function):void = R'''
	g_pContext->funcPackOnButtonBox.SetFunc(env, sig, func->Reference());
	glutButtonBoxFunc(OnButtonBox);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutDialsFunc(func:function):void = R'''
	g_pContext->funcPackOnDials.SetFunc(env, sig, func->Reference());
	glutDialsFunc(OnDials);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutTabletMotionFunc(func:function):void = R'''
	g_pContext->funcPackOnTabletMotion.SetFunc(env, sig, func->Reference());
	glutTabletMotionFunc(OnTabletMotion);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutTabletButtonFunc(func:function):void = R'''
	g_pContext->funcPackOnTabletButton.SetFunc(env, sig, func->Reference());
	glutTabletButtonFunc(OnTabletButton);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutMenuStatusFunc(func:function):void = R'''
	g_pContext->funcPackOnMenuStatus.SetFunc(env, sig, func->Reference());
	glutMenuStatusFunc(OnMenuStatus);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutOverlayDisplayFunc(func:function):void = R'''
	g_pContext->funcPackOnOverlayDisplay.SetFunc(env, sig, func->Reference());
	glutOverlayDisplayFunc(OnOverlayDisplay);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutWindowStatusFunc(func:function):void = R'''
	g_pContext->funcPackOnWindowStatus.SetFunc(env, sig, func->Reference());
	glutWindowStatusFunc(OnWindowStatus);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutKeyboardUpFunc(func:function):void = R'''
	g_pContext->funcPackOnKeyboardUp.SetFunc(env, sig, func->Reference());
	glutKeyboardUpFunc(OnKeyboardUp);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpecialUpFunc(func:function):void = R'''
	g_pContext->funcPackOnSpecialUp.SetFunc(env, sig, func->Reference());
	glutSpecialUpFunc(OnSpecialUp);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutJoystickFunc(func:function, pollInterval:int):void = R'''
	g_pContext->funcPackOnJoystick.SetFunc(env, sig, func->Reference());
	glutJoystickFunc(OnJoystick, pollInterval);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}
			
glutSetColor(ndx:int, red:GLfloat, green:GLfloat, blue:GLfloat):void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGetColor(ndx:int, component:int):GLfloat:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutCopyColormap(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGet(type:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutDeviceGet(type:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutExtensionSupported(name:char@:const):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGetModifiers():int {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutLayerGet(type:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

/*
glutGetProcAddress(procName:char@:const):void@:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}
*/

glutBitmapCharacter(font:Font, character:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutBitmapWidth(font:Font, character:int):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutStrokeCharacter(font:Font, character:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutStrokeWidth(font:Font, character:int):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutBitmapLength(font:Font, string:unsigned_char@:const):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutStrokeLength(font:Font, string:unsigned_char@:const):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireSphere(radius:GLdouble, slices:GLint, stacks:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidSphere(radius:GLdouble, slices:GLint, stacks:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireCone(base:GLdouble, height:GLdouble, slices:GLint, stacks:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidCone(base:GLdouble, height:GLdouble, slices:GLint, stacks:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireCube(size:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidCube(size:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireTorus(innerRadius:GLdouble, outerRadius:GLdouble, sides:GLint, rings:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidTorus(innerRadius:GLdouble, outerRadius:GLdouble, sides:GLint, rings:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireDodecahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidDodecahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireTeapot(size:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidTeapot(size:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireOctahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidOctahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireTetrahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidTetrahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireIcosahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidIcosahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutVideoResizeGet(param:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetupVideoResizing():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutStopVideoResizing():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutVideoResize(x:int, y:int, width:int, height:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutVideoPan(x:int, y:int, width:int, height:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutReportErrors():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutIgnoreKeyRepeat(ignore:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetKeyRepeat(repeatMode:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutForceJoystickFunc():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGameModeString(string:char@:const):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutEnterGameMode():int {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutLeaveGameMode():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGameModeGet(mode:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

}

typeConvDict = %{
	'unsigned_char@:const' => cbridge.TypeConv(
			'string', 'Once', [],
			'const unsigned char *${arg.name} = reinterpret_cast<const unsigned char *>(args.GetString(${idx}));',
			nil,
			R'''
			const char *_rtn = reinterpret_cast<const char *>(${fi.MakeCaller()});
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'string[]' => cbridge.TypeConv(
			'string', 'Once', ['List'],
			'const ValueList &${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLenum' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLenum ${arg.name} = static_cast<GLenum>(args.GetInt(${idx}));',
			nil,
			R'''
			GLenum _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLboolean' => cbridge.TypeConv(
			'boolean', 'Once', [],
			'GLboolean ${arg.name} = (args.GetBoolean(${idx})? GL_TRUE : GL_FALSE);',
			nil,
			R'''
			GLboolean _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn != GL_FALSE));
			''')
	'GLbitfield' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLbitfield ${arg.name} = args.GetUInt(${idx});',
			nil,
			R'''
			GLbitfield _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLbyte' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLbyte ${arg.name} = args.GetChar(${idx});',
			nil,
			R'''
			GLbyte _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLshort' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLshort ${arg.name} = args.GetShort(${idx});',
			nil,
			R'''
			GLshort _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLint' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLint ${arg.name} = args.GetInt(${idx});',
			nil,
			R'''
			GLint _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLsizei' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLsizei ${arg.name} = args.GetInt(${idx});',
			nil,
			R'''
			GLsizei _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLubyte' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLubyte ${arg.name} = args.GetUChar(${idx});',
			nil,
			R'''
			GLubyte _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLushort' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLushort ${arg.name} = args.GetUShort(${idx});',
			nil,
			R'''
			GLushort _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLuint' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLuint ${arg.name} = args.GetUInt(${idx});',
			nil,
			R'''
			GLuint _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLfloat' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLfloat ${arg.name} = args.GetFloat(${idx});',
			nil,
			R'''
			GLfloat _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLclampf' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLclampf ${arg.name} = args.GetFloat(${idx});',
			nil,
			R'''
			GLclampf _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLdouble' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLdouble ${arg.name} = args.GetDouble(${idx});',
			nil,
			R'''
			GLdouble _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLclampd' => cbridge.TypeConv(
			'number', 'Once', [],
			'GLclampd ${arg.name} = args.GetDouble(${idx});',
			nil,
			R'''
			GLclampd _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));
			''')
	'GLenum@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLenum> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLenum@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLenum> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@' => cbridge.TypeConv(
			'boolean', 'Once', ['List'],
			'CArray<GLboolean> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@:const' => cbridge.TypeConv(
			'boolean', 'Once', ['List'],
			'CArray<GLboolean> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@1:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLboolean@2:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLboolean@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLbyte@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLbyte> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLbyte@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLbyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLbyte@4:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLbyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLbyte@pname:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLbyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLchar@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLchar> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLchar@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLchar> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLubyte@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'const GLubyte *${arg.name} = reinterpret_cast<const GLubyte *>(args.GetString(${idx}));',
			nil,
			R'''
			const GLubyte *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(reinterpret_cast<const char *>(_rtn)));
			''')
	'GLubyte@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLubyte> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLubyte@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLubyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLubyte@4:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLubyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLubyte@pname:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLubyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLshort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLshort@1:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@2:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@4:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@pname:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLushort@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLushort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLushort@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLushort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLushort@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLushort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLushort@4:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLushort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLushort@pname:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLushort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLint@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLint@1:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@2:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@4:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@pname:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLsizei@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLsizei> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLsizei@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLsizei> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLuint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLuint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLuint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLuint@4:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLuint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLuint@pname:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLuint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLfloat> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLfloat@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLfloat> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLfloat@1:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@2:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@4:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@16:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 16) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@pname:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLclampf@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLclampf> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLdouble> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLdouble> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@1:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@2:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@3:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@4:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@16:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 16) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@pname:const' => cbridge.TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	// GLU-specific
	'GLUnurbs@' => cbridge.TypeConv(
			'Nurbs', 'Once', [],
			R'''
			GLUnurbs *${arg.name} = Object_Nurbs::GetObject(args, ${idx})->GetNurbs();
			''',
			nil,
			R'''
			GLUnurbs *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Nurbs(_rtn)));
			''')
	'GLUtesselator@' => cbridge.TypeConv(
			'Tesselator', 'Once', [],
			R'''
			GLUtesselator *${arg.name} = Object_Tesselator::GetObject(args, ${idx})->GetTesselator();
			''',
			nil,
			R'''
			GLUtesselator *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Tesselator(_rtn)));
			''')
	'GLUquadric@' => cbridge.TypeConv(
			'Quadric', 'Once', [],
			R'''
			GLUquadric *${arg.name} = Object_Quadric::GetObject(args, ${idx})->GetQuadric();
			''',
			nil,
			R'''
			GLUquadric *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Quadric(_rtn)));
			''')
	// GLUT-specific
	'Font' => cbridge.TypeConv(
			'Font', 'Once', [],
			R'''
			void *${arg.name} = Object_Font::GetObject(args, ${idx})->GetEntity();
			''',
			nil,
			nil)
}

tmplSource = R"""
// Don't edit this file. This has been generated by Functions.cpp.gura.
#include "stdafx.h"

Gura_BeginModuleScope(glut)

class FunctionPack {
private:
	AutoPtr<Environment> _pEnv;
	Signal _sig;
	AutoPtr<Function> _pFunc;
public:
	inline FunctionPack() {}
	inline void SetFunc(Environment &env, Signal sig, Function *pFunc) {
		_pEnv.reset(new Environment(env));
		_sig = sig;
		_pFunc.reset(pFunc);
	}
	inline Value Eval(Args &args) {
		if (_pFunc.IsNull()) return Value::Null;
		Value result = _pFunc->Eval(*_pEnv, _sig, args);
		if (_sig.IsSignalled()) {
			_sig.PrintSignal(*_pEnv->GetConsoleErr());
			exit(1);
		}
		return result;
	}
};

struct Context {
	FunctionPack funcPackOnWMClose;
	FunctionPack funcPackOnMenu;
	FunctionPack funcPackOnDisplay;
	FunctionPack funcPackOnReshape;
	FunctionPack funcPackOnKeyboard;
	FunctionPack funcPackOnMouse;
	FunctionPack funcPackOnMotion;
	FunctionPack funcPackOnPassiveMotion;
	FunctionPack funcPackOnEntry;
	FunctionPack funcPackOnVisibility;
	FunctionPack funcPackOnIdle;
	FunctionPack funcPackOnTimer;
	FunctionPack funcPackOnMenuState;
	FunctionPack funcPackOnSpecial;
	FunctionPack funcPackOnSpaceballMotion;
	FunctionPack funcPackOnSpaceballRotate;
	FunctionPack funcPackOnSpaceballButton;
	FunctionPack funcPackOnButtonBox;
	FunctionPack funcPackOnDials;
	FunctionPack funcPackOnTabletMotion;
	FunctionPack funcPackOnTabletButton;
	FunctionPack funcPackOnMenuStatus;
	FunctionPack funcPackOnOverlayDisplay;
	FunctionPack funcPackOnWindowStatus;
	FunctionPack funcPackOnKeyboardUp;
	FunctionPack funcPackOnSpecialUp;
	FunctionPack funcPackOnJoystick;
};

Context *g_pContext = NULL;

void OnWMClose()
{
	AutoPtr<Args> pArgs(new Args());
	g_pContext->funcPackOnWMClose.Eval(*pArgs);
}

void OnMenu(int value)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValue(Value(value));
	g_pContext->funcPackOnMenu.Eval(*pArgs);
}

void OnDisplay(void)
{
	AutoPtr<Args> pArgs(new Args());
	g_pContext->funcPackOnDisplay.Eval(*pArgs);
}

void OnReshape(int width, int height)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(width), Value(height));
	g_pContext->funcPackOnReshape.Eval(*pArgs);
}

void OnKeyboard(unsigned char key, int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(key), Value(x), Value(y));
	g_pContext->funcPackOnKeyboard.Eval(*pArgs);
}

void OnMouse(int button, int state, int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(button), Value(state), Value(x), Value(y));
	g_pContext->funcPackOnMouse.Eval(*pArgs);
}

void OnMotion(int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(x), Value(y));
	g_pContext->funcPackOnMotion.Eval(*pArgs);
}

void OnPassiveMotion(int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(x), Value(y));
	g_pContext->funcPackOnPassiveMotion.Eval(*pArgs);
}

void OnEntry(int state)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValue(Value(state));
	g_pContext->funcPackOnEntry.Eval(*pArgs);
}

void OnVisibility(int state)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValue(Value(state));
	g_pContext->funcPackOnVisibility.Eval(*pArgs);
}

void OnIdle(void)
{
	AutoPtr<Args> pArgs(new Args());
	g_pContext->funcPackOnIdle.Eval(*pArgs);
}

void OnTimer(int value)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValue(Value(value));
	g_pContext->funcPackOnTimer.Eval(*pArgs);
}

void OnMenuState(int state)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValue(Value(state));
	g_pContext->funcPackOnMenuState.Eval(*pArgs);
}

void OnSpecial(int key, int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(key), Value(x), Value(y));
	g_pContext->funcPackOnSpecial.Eval(*pArgs);
}

void OnSpaceballMotion(int x, int y, int z)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(x), Value(y), Value(z));
	g_pContext->funcPackOnSpaceballMotion.Eval(*pArgs);
}

void OnSpaceballRotate(int x, int y, int z)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(x), Value(y), Value(z));
	g_pContext->funcPackOnSpaceballRotate.Eval(*pArgs);
}

void OnSpaceballButton(int button, int state)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(button), Value(state));
	g_pContext->funcPackOnSpaceballButton.Eval(*pArgs);
}

void OnButtonBox(int button, int state)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(button), Value(state));
	g_pContext->funcPackOnButtonBox.Eval(*pArgs);
}

void OnDials(int dial, int value)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(dial), Value(value));
	g_pContext->funcPackOnDials.Eval(*pArgs);
}

void OnTabletMotion(int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(x), Value(y));
	g_pContext->funcPackOnTabletMotion.Eval(*pArgs);
}

void OnTabletButton(int button, int state, int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(button), Value(state), Value(x), Value(y));
	g_pContext->funcPackOnTabletButton.Eval(*pArgs);
}

void OnMenuStatus(int status, int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(status), Value(x), Value(y));
	g_pContext->funcPackOnMenuStatus.Eval(*pArgs);
}

void OnOverlayDisplay(void)
{
	AutoPtr<Args> pArgs(new Args());
	g_pContext->funcPackOnOverlayDisplay.Eval(*pArgs);
}

void OnWindowStatus(int state)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValue(Value(state));
	g_pContext->funcPackOnWindowStatus.Eval(*pArgs);
}

void OnKeyboardUp(unsigned char key, int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(key), Value(x), Value(y));
	g_pContext->funcPackOnKeyboardUp.Eval(*pArgs);
}

void OnSpecialUp(int key, int x, int y)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(key), Value(x), Value(y));
	g_pContext->funcPackOnSpecialUp.Eval(*pArgs);
}

void OnJoystick(unsigned int buttonMask, int x, int y, int z)
{
	AutoPtr<Args> pArgs(new Args());
	pArgs->SetValues(Value(buttonMask), Value(x), Value(y), Value(z));
	g_pContext->funcPackOnJoystick.Eval(*pArgs);
}

${renderer.RenderImplementation()}

void AssignFunctions(Environment &env)
{
	g_pContext = new Context();
	${renderer.RenderAssignment()}
}

Gura_EndModuleScope(glut)
""".template()

cbridge.Renderer('glut', decls.children, typeConvDict, nil).Render(tmplSource, 'Functions.cpp')
