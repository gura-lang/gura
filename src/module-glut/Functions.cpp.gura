#!/usr/bin/env gura
import(cbridge) {TypeConv, Renderer}

decls = `{
glutInit(argv[]:string) {block?} = R'''
	int argc = static_cast<int>(argv.size());
	char **_argv = new char *[argc];
	int i = 0;
	foreach_const (ValueList, pValue, argv) {
		_argv[i++] = strdup(pValue->GetString());
	}
	glutInit(&argc, _argv);
	Value _rtnVal(Value::CreateList(env, _argv, argc));
	for (int i = 0; i < argc; i++) {
		::free(_argv[i]);
	}
	delete[] _argv;
	return ReturnValue(env, sig, args, _rtnVal);
''' % {`en, 'markdown',
	R'''
	'''
}

glutInitDisplayMode(mode:unsigned_int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutInitDisplayString(string:char@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutInitWindowPosition(x:int, y:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutInitWindowSize(width:int, height:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutMainLoop():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutCreateWindow(title:char@:const):int:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutCreateSubWindow(win:int, x:int, y:int, width:int, height:int):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutDestroyWindow(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPostRedisplay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPostWindowRedisplay(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSwapBuffers():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGetWindow():int {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetWindow(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetWindowTitle(title:char@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutSetIconTitle(title:char@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutPositionWindow(x:int, y:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutReshapeWindow(width:int, height:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPopWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPushWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutIconifyWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutShowWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutHideWindow():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutFullScreen():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetCursor(cursor:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWarpPointer(x:int, y:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSurfaceTexture(target:GLenum, internalformat:GLenum, surfacewin:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWMCloseFunc(func:function):void = R'''
	g_pContext->pFuncWMClose.reset(func->Reference());
	glutWMCloseFunc(OnDisplay);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutCheckLoop():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutEstablishOverlay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutRemoveOverlay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutUseLayer(layer:GLenum):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPostOverlayRedisplay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutPostWindowOverlayRedisplay(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutShowOverlay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutHideOverlay():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutCreateMenu():int {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutDestroyMenu(menu:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGetMenu():int {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetMenu(menu:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutAddMenuEntry(label:char@:const, value:int):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutAddSubMenu(label:char@:const, submenu:int):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutChangeToMenuEntry(item:int, label:char@:const, value:int):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutChangeToSubMenu(item:int, label:char@:const, submenu:int):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutRemoveMenuItem(item:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutAttachMenu(button:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutDetachMenu(button:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutDisplayFunc(func:function):void = R'''
	g_pContext->pFuncDisplay.reset(func->Reference());
	glutDisplayFunc(OnDisplay);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutReshapeFunc(func:function):void = R'''
	g_pContext->pFuncReshape.reset(func->Reference());
	glutReshapeFunc(OnReshape);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutKeyboardFunc(func:function):void = R'''
	g_pContext->pFuncKeyboard.reset(func->Reference());
	glutKeyboardFunc(OnKeyboard);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutMouseFunc(func:function):void = R'''
	g_pContext->pFuncMouse.reset(func->Reference());
	glutMouseFunc(OnMouse);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutMotionFunc(func:function):void = R'''
	g_pContext->pFuncMotion.reset(func->Reference());
	glutMotionFunc(OnMotion);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutPassiveMotionFunc(func:function):void = R'''
	g_pContext->pFuncPassiveMotion.reset(func->Reference());
	glutPassiveMotionFunc(OnPassiveMotion);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutEntryFunc(func:function):void = R'''
	g_pContext->pFuncEntry.reset(func->Reference());
	glutEntryFunc(OnEntry);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutVisibilityFunc(func:function):void = R'''
	g_pContext->pFuncVisibility.reset(func->Reference());
	glutVisibilityFunc(OnVisibility);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutIdleFunc(func:function):void = R'''
	g_pContext->pFuncIdle.reset(func->Reference());
	glutIdleFunc(OnIdle);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutTimerFunc(millis:unsigned_int, func:function, value:int):void = R'''
	g_pContext->pFuncTimer.reset(func->Reference());
	glutTimerFunc(millis, OnTimer, value);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutMenuStateFunc(func:function):void = R'''
	g_pContext->pFuncMenuState.reset(func->Reference());
	glutMenuStateFunc(OnMenuState);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpecialFunc(func:function):void = R'''
	g_pContext->pFuncSpecial.reset(func->Reference());
	glutSpecialFunc(OnSpecial);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpaceballMotionFunc(func:function):void = R'''
	g_pContext->pFuncSpaceballMotion.reset(func->Reference());
	glutSpaceballMotionFunc(OnSpaceballMotion);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpaceballRotateFunc(func:function):void = R'''
	g_pContext->pFuncSpaceballRotate.reset(func->Reference());
	glutSpaceballRotateFunc(OnSpaceballRotate);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpaceballButtonFunc(func:function):void = R'''
	g_pContext->pFuncSpaceballButton.reset(func->Reference());
	glutSpaceballButtonFunc(OnSpaceballButton);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutButtonBoxFunc(func:function):void = R'''
	g_pContext->pFuncButtonBox.reset(func->Reference());
	glutButtonBoxFunc(OnButtonBox);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutDialsFunc(func:function):void = R'''
	g_pContext->pFuncDials.reset(func->Reference());
	glutDialsFunc(OnDials);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutTabletMotionFunc(func:function):void = R'''
	g_pContext->pFuncTabletMotion.reset(func->Reference());
	glutTabletMotionFunc(OnTabletMotion);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutTabletButtonFunc(func:function):void = R'''
	g_pContext->pFuncTabletButton.reset(func->Reference());
	glutTabletButtonFunc(OnTabletButton);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutMenuStatusFunc(func:function):void = R'''
	g_pContext->pFuncMenuStatus.reset(func->Reference());
	glutMenuStatusFunc(OnMenuStatus);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutOverlayDisplayFunc(func:function):void = R'''
	g_pContext->pFuncOverlayDisplay.reset(func->Reference());
	glutOverlayDisplayFunc(OnOverlayDisplay);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutWindowStatusFunc(func:function):void = R'''
	g_pContext->pFuncWindowStatus.reset(func->Reference());
	glutWindowStatusFunc(OnWindowStatus);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutKeyboardUpFunc(func:function):void = R'''
	g_pContext->pFuncKeyboardUp.reset(func->Reference());
	glutKeyboardUpFunc(OnKeyboardUp);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutSpecialUpFunc(func:function):void = R'''
	g_pContext->pFuncSpecialUp.reset(func->Reference());
	glutSpecialUpFunc(OnSpecialUp);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}

glutJoystickFunc(func:function, pollInterval:int):void = R'''
	g_pContext->pFuncJoystick.reset(func->Reference());
	glutJoystickFunc(OnJoystick, pollInterval);
	return Value::Null;
''' % {`en, 'markdown',
	R'''
	'''
}
			
glutSetColor():void = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutGetColor(ndx:int, component:int):GLfloat:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutCopyColormap(win:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGet(type:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutDeviceGet(type:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutExtensionSupported(name:char@:const):int:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutGetModifiers():int {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutLayerGet(type:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

/*
glutGetProcAddress(procName:char@:const):void@:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}
*/

/*
glutBitmapCharacter(font:void@, character:int):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutBitmapWidth(font:void@, character:int):int:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutStrokeCharacter(font:void@, character:int):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutStrokeWidth(font:void@, character:int):int:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutBitmapLength(font:void@, string:unsigned_char@:const):int:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutStrokeLength(font:void@, string:unsigned_char@:const):int:map {block?} = `unsupport % {`en, 'markdown',
	R'''
	'''
}
*/

glutWireSphere(radius:GLdouble, slices:GLint, stacks:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidSphere(radius:GLdouble, slices:GLint, stacks:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireCone(base:GLdouble, height:GLdouble, slices:GLint, stacks:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidCone(base:GLdouble, height:GLdouble, slices:GLint, stacks:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireCube(size:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidCube(size:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireTorus(innerRadius:GLdouble, outerRadius:GLdouble, sides:GLint, rings:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidTorus(innerRadius:GLdouble, outerRadius:GLdouble, sides:GLint, rings:GLint):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireDodecahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidDodecahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireTeapot(size:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidTeapot(size:GLdouble):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireOctahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidOctahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireTetrahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidTetrahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutWireIcosahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSolidIcosahedron():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutVideoResizeGet(param:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetupVideoResizing():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutStopVideoResizing():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutVideoResize(x:int, y:int, width:int, height:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutVideoPan(x:int, y:int, width:int, height:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutReportErrors():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutIgnoreKeyRepeat(ignore:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutSetKeyRepeat(repeatMode:int):void:map = `auto % {`en, 'markdown',
	R'''
	'''
}

glutForceJoystickFunc():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGameModeString(string:char@:const):void:map = `unsupport % {`en, 'markdown',
	R'''
	'''
}

glutEnterGameMode():int {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

glutLeaveGameMode():void = `auto % {`en, 'markdown',
	R'''
	'''
}

glutGameModeGet(mode:GLenum):int:map {block?} = `auto % {`en, 'markdown',
	R'''
	'''
}

}

typeConvDict = %{
	'string[]' => TypeConv(
			'string', 'Once', ['List'],
			'const ValueList &${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLenum' => TypeConv(
			'number', 'Once', [],
			'GLenum ${arg.name} = static_cast<GLenum>(args.GetInt(${idx}));',
			nil,
			R'''
			GLenum _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLboolean' => TypeConv(
			'boolean', 'Once', [],
			'GLboolean ${arg.name} = (args.GetBoolean(${idx})? GL_TRUE : GL_FALSE);',
			nil,
			R'''
			GLboolean _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn != GL_FALSE));''')
	'GLbitfield' => TypeConv(
			'number', 'Once', [],
			'GLbitfield ${arg.name} = args.GetUInt(${idx});',
			nil,
			R'''
			GLbitfield _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLbyte' => TypeConv(
			'number', 'Once', [],
			'GLbyte ${arg.name} = args.GetChar(${idx});',
			nil,
			R'''
			GLbyte _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLshort' => TypeConv(
			'number', 'Once', [],
			'GLshort ${arg.name} = args.GetShort(${idx});',
			nil,
			R'''
			GLshort _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLint' => TypeConv(
			'number', 'Once', [],
			'GLint ${arg.name} = args.GetInt(${idx});',
			nil,
			R'''
			GLint _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLsizei' => TypeConv(
			'number', 'Once', [],
			'GLsizei ${arg.name} = args.GetInt(${idx});',
			nil,
			R'''
			GLsizei _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLubyte' => TypeConv(
			'number', 'Once', [],
			'GLubyte ${arg.name} = args.GetUChar(${idx});',
			nil,
			R'''
			GLubyte _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLushort' => TypeConv(
			'number', 'Once', [],
			'GLushort ${arg.name} = args.GetUShort(${idx});',
			nil,
			R'''
			GLushort _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLuint' => TypeConv(
			'number', 'Once', [],
			'GLuint ${arg.name} = args.GetUInt(${idx});',
			nil,
			R'''
			GLuint _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLfloat' => TypeConv(
			'number', 'Once', [],
			'GLfloat ${arg.name} = args.GetFloat(${idx});',
			nil,
			R'''
			GLfloat _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLclampf' => TypeConv(
			'number', 'Once', [],
			'GLclampf ${arg.name} = args.GetFloat(${idx});',
			nil,
			R'''
			GLclampf _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLdouble' => TypeConv(
			'number', 'Once', [],
			'GLdouble ${arg.name} = args.GetDouble(${idx});',
			nil,
			R'''
			GLdouble _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLclampd' => TypeConv(
			'number', 'Once', [],
			'GLclampd ${arg.name} = args.GetDouble(${idx});',
			nil,
			R'''
			GLclampd _rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(_rtn));''')
	'GLenum@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLenum> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLenum@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLenum> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@' => TypeConv(
			'boolean', 'Once', ['List'],
			'CArray<GLboolean> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@:const' => TypeConv(
			'boolean', 'Once', ['List'],
			'CArray<GLboolean> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLboolean@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLboolean@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLboolean@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLboolean> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLbyte@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLbyte> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLbyte@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLbyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLbyte@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLbyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLbyte@pname:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLbyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLchar@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLchar> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLchar@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLchar> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLubyte@:const' => TypeConv(
			'number', 'Once', ['List'],
			'const GLubyte *${arg.name} = reinterpret_cast<const GLubyte *>(args.GetString(${idx}));',
			nil,
			R'''
			const GLubyte *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(reinterpret_cast<const char *>(_rtn)));''')
	'GLubyte@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLubyte> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLubyte@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLubyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLubyte@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLubyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLubyte@pname:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLubyte> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLshort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLshort@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLshort@pname:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLshort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLushort@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLushort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLushort@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLushort> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLushort@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLushort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLushort@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLushort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLushort@pname:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLushort> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLint@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLint@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLint@pname:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLsizei@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLsizei> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLsizei@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLsizei> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLuint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLuint> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLuint@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLuint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLuint@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLuint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLuint@pname:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLuint> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLfloat> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLfloat@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLfloat> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLfloat@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@16:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 16) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLfloat@pname:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLfloat> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	'GLclampf@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLclampf> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLdouble> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@:const' => TypeConv(
			'number', 'Once', ['List'],
			'CArray<GLdouble> ${arg.name} = args.GetList(${idx});',
			nil,
			nil)
	'GLdouble@1:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 1) {
				sig.SetError(ERR_ValueError, "the list must have one element");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@2:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 2) {
				sig.SetError(ERR_ValueError, "the list must have two elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@3:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 3) {
				sig.SetError(ERR_ValueError, "the list must have three elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@4:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 4) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@16:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != 16) {
				sig.SetError(ERR_ValueError, "the list must have four elements");
				return Value::Null;
			}''',
			nil,
			nil)
	'GLdouble@pname:const' => TypeConv(
			'number', 'Once', ['List'],
			R'''
			CArray<GLdouble> ${arg.name} = args.GetList(${idx});
			if (${arg.name}.GetSize() != GetParamCount(pname)) {
				sig.SetError(ERR_ValueError,
						"the list must have %d elements", GetParamCount(pname));
				return Value::Null;
			}''',
			nil,
			nil)
	// GLU-specific
	'GLUnurbs@' => TypeConv(
			'Nurbs', 'Once', [],
			R'''
			GLUnurbs *${arg.name} = Object_Nurbs::GetObject(args, ${idx})->GetNurbs();
			''',
			nil,
			R'''
			GLUnurbs *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Nurbs(_rtn)));''')
	'GLUtesselator@' => TypeConv(
			'Tesselator', 'Once', [],
			R'''
			GLUtesselator *${arg.name} = Object_Tesselator::GetObject(args, ${idx})->GetTesselator();
			''',
			nil,
			R'''
			GLUtesselator *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Tesselator(_rtn)));''')
	'GLUquadric@' => TypeConv(
			'Quadric', 'Once', [],
			R'''
			GLUquadric *${arg.name} = Object_Quadric::GetObject(args, ${idx})->GetQuadric();
			''',
			nil,
			R'''
			GLUquadric *_rtn = ${fi.MakeCaller()};
			return ReturnValue(env, sig, args, Value(new Object_Quadric(_rtn)));''')
}

tmplSource = R"""
// Don't edit this file. This has been generated by Functions.cpp.gura.
#include "stdafx.h"

Gura_BeginModuleScope(glut)

struct Context {
	AutoPtr<Function> pFuncWMClose;
	AutoPtr<Function> pFuncDisplay;
	AutoPtr<Function> pFuncReshape;
	AutoPtr<Function> pFuncKeyboard;
	AutoPtr<Function> pFuncMouse;
	AutoPtr<Function> pFuncMotion;
	AutoPtr<Function> pFuncPassiveMotion;
	AutoPtr<Function> pFuncEntry;
	AutoPtr<Function> pFuncVisibility;
	AutoPtr<Function> pFuncIdle;
	AutoPtr<Function> pFuncTimer;
	AutoPtr<Function> pFuncMenuState;
	AutoPtr<Function> pFuncSpecial;
	AutoPtr<Function> pFuncSpaceballMotion;
	AutoPtr<Function> pFuncSpaceballRotate;
	AutoPtr<Function> pFuncSpaceballButton;
	AutoPtr<Function> pFuncButtonBox;
	AutoPtr<Function> pFuncDials;
	AutoPtr<Function> pFuncTabletMotion;
	AutoPtr<Function> pFuncTabletButton;
	AutoPtr<Function> pFuncMenuStatus;
	AutoPtr<Function> pFuncOverlayDisplay;
	AutoPtr<Function> pFuncWindowStatus;
	AutoPtr<Function> pFuncKeyboardUp;
	AutoPtr<Function> pFuncSpecialUp;
	AutoPtr<Function> pFuncJoystick;
};

Context *g_pContext = NULL;

void OnDisplay(void)
{
}

void OnReshape(int width, int height)
{
}

void OnKeyboard(unsigned char key, int x, int y)
{
}

void OnMouse(int button, int state, int x, int y)
{
}

void OnMotion(int x, int y)
{
}

void OnPassiveMotion(int x, int y)
{
}

void OnEntry(int state)
{
}

void OnVisibility(int state)
{
}

void OnIdle(void)
{
}

void OnTimer(int value)
{
}

void OnMenuState(int state)
{
}

void OnSpecial(int key, int x, int y)
{
}

void OnSpaceballMotion(int x, int y, int z)
{
}

void OnSpaceballRotate(int x, int y, int z)
{
}

void OnSpaceballButton(int button, int state)
{
}

void OnButtonBox(int button, int state)
{
}

void OnDials(int dial, int value)
{
}

void OnTabletMotion(int x, int y)
{
}

void OnTabletButton(int button, int state, int x, int y)
{
}

void OnMenuStatus(int status, int x, int y)
{
}

void OnOverlayDisplay(void)
{
}

void OnWindowStatus(int state)
{
}

void OnKeyboardUp(unsigned char key, int x, int y)
{
}

void OnSpecialUp(int key, int x, int y)
{
}

void OnJoystick(unsigned int buttonMask, int x, int y, int z)
{
}

${renderer.RenderImplementation()}

void AssignFunctions(Environment &env)
{
	g_pContext = new Context();
	${renderer.RenderAssignment()}
}

Gura_EndModuleScope(glut)
""".template()

Renderer('glut', decls.children, typeConvDict, nil).Render(tmplSource, 'Functions.cpp')
