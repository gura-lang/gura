#!/usr/bin/env gura
import(sdl)
import(gif)

gif.content(sys.argv[1], `rgba) {|g|
	imgs = g.images::resize(300)
	imgs:*delayTime:public = g.images:*gif:*GraphicControl:*DelayTime / 100
}
createHatchImage(width:number, height:number, wdHatch:number, htHatch:number) = {
	colors = [color(`gray), color(`white)]
	iCols = range(width / wdHatch + 1)
	img = image(`rgb, width, height)
	repeat (height / htHatch + 1) {|iRow|
		img.fillrect(iCols * wdHatch, iRow * htHatch, wdHatch, htHatch,
								colors.cycle().offset(iRow % 2))
	}
	img
}

imgHatch = createHatchImage(imgs[0].width, imgs[0].height, 8, 8)

sdl.Init(sdl.INIT_EVERYTHING)
screen = sdl.SetVideoMode(imgs[0].width, imgs[0].height, 16, sdl.SWSURFACE)
imgIter = imgs.cycle()
tickPrev = os.clock()
delayTime = 0
sdl.AddTimer(5) {
	if (os.clock() - tickPrev > delayTime) {
		sdl.BlitSurface(imgHatch, nil, screen, nil)
		img = imgIter.next()
		sdl.BlitSurface(img, nil, screen, sdl.Rect(0, screen.h - img.height, 0, 0))
		screen.UpdateRect()
		delayTime:extern = img.delayTime
		tickPrev = os.clock()
	}
	true
}
repeat {
	event = sdl.WaitEvent()
	if (event.type == sdl.QUIT || \
		(event.type == sdl.KEYDOWN && event.sym == sdl.K_ESCAPE)) { break }
}
