//=============================================================================
// Gura class: arrayT
//=============================================================================
#ifndef __GURA_CLASS_ARRAYT_H__
#define __GURA_CLASS_ARRAYT_H__

#include "Class.h"
#include "ArrayT.h"

namespace Gura {

//-----------------------------------------------------------------------------
// Object_arrayT
//-----------------------------------------------------------------------------
template<typename T_Elem>
class Object_arrayT : public Object {
public:
	Gura_DeclareObjectAccessor(arrayT)
private:
	AutoPtr<ArrayT<T_Elem> > _pArrayT;
public:
	inline Object_arrayT(Environment &env, ValueType valType, ArrayT<T_Elem> *pArrayT) :
				Object(env.LookupClass(valType)), _pArrayT(pArrayT) {}
	inline Object_arrayT(Class *pClass, ArrayT<T_Elem> *pArrayT) :
				Object(pClass), _pArrayT(pArrayT) {}
	inline ArrayT<T_Elem> *GetArrayT() { return _pArrayT.get(); }
	inline const ArrayT<T_Elem> *GetArrayT() const { return _pArrayT.get(); }
	virtual Object *Clone() const;
	virtual String ToString(bool exprFlag);
	virtual Value IndexGet(Environment &env, const Value &valueIdx);
	virtual void IndexSet(Environment &env, const Value &valueIdx, const Value &value);
};

//-----------------------------------------------------------------------------
// Class_arrayT
//-----------------------------------------------------------------------------
template<typename T_Elem>
class Class_arrayT : public Class {
public:
	//-------------------------------------------------------------------------
	// array@T(src) {block?}
	class Func_Constructor : public Function {
	private:
		ValueType _valType;
	public:
		Func_Constructor(Environment &env, const Symbol *pSymbol, ValueType valType) :
				Function(env, pSymbol, FUNCTYPE_Function, FLAG_None), _valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_None);
			DeclareArg(env, "src", VTYPE_any, OCCUR_Once);
			SetClassToConstruct(env.LookupClass(valType));
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Creates an `array@T` instance.\n"
				"You can call this function in the following formats:\n"
				"\n"
				"- `array@T(list:list)` .. Creates an `array@T` instance initialized with\n"
				"  numbers contained in the `list`.\n"
				"- `array@T(iter:iterator)` .. Creates an `array@T` instance initialized with\n"
				"  numbers generated by the `iterator`.\n"
				"\n"
				GURA_HELPTEXT_BLOCK_en("array", "array@T")
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			AutoPtr<ArrayT<T_Elem> > pArrayT;
			if (arg.Is_list(0)) {
				const ValueList &valList = arg.GetList(0);
				pArrayT.reset(ArrayT<T_Elem>::CreateFromList(sig, valList));
				if (pArrayT.IsNull()) return Value::Nil;
			} else if (arg.Is_iterator(0)) {
				Iterator *pIterator = arg.GetIterator(0);
				if (pIterator->IsInfinite()) {
					Iterator::SetError_InfiniteNotAllowed(sig);
					return false;
				}
				pArrayT.reset(ArrayT<T_Elem>::CreateFromIterator(env, pIterator));
				if (pArrayT.IsNull()) return false;
			} else {
				Declaration::SetError_InvalidArgument(env);
				return Value::Nil;
			}
			Value value(new Object_arrayT<T_Elem>(env, _valType, pArrayT.release()));
			return ReturnValue(env, arg, value);
		}
	};
	//-------------------------------------------------------------------------
	// @T() {block}
	class Func_Initializer : public Function {
	private:
		ValueType _valType;
	public:
		Func_Initializer(Environment &env, const Symbol *pSymbol, ValueType valType) :
				Function(env, pSymbol, FUNCTYPE_Function, FLAG_None), _valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_None);
			DeclareBlock(OCCUR_Once);
			AddHelp(
				Gura_Symbol(en),
				"Creates an `array@T` instance that is initialized with values described in `block`.\n"
				"\n"
				"The code below creates an `array@uchar` instance that has four elements.\n"
				"\n"
				"    @uchar { 0x01, 0x23, 0x45, 0x67 }\n"
				"\n"
				"The code below creates an `array@ushort` instance that has three elements.\n"
				"\n"
				"    @ushort { 0x0123, 0x4567, 0x89ab }\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
			const ExprOwner &exprOwner = pExprBlock->GetExprOwner();
			AutoPtr<ArrayT<T_Elem> > pArrayT(new ArrayT<T_Elem>(exprOwner.size()));
			T_Elem *p = pArrayT->GetPointer();
			foreach_const (ExprOwner, ppExpr, exprOwner) {
				const Expr *pExpr = *ppExpr;
				if (pExpr->IsBlock()) {
					sig.SetError(ERR_ValueError, "invalid element for array initialization");
					return Value::Nil;
				}
				Value value = pExpr->Exec(env);
				if (!value.Is_number() && !value.Is_boolean()) {
					sig.SetError(ERR_ValueError, "invalid element for array initialization");
					return Value::Nil;
				}
				*p++ = static_cast<T_Elem>(value.GetNumber());
			}
			return Value(new Object_arrayT<T_Elem>(env, _valType, pArrayT.release()));
		}
	};
	//-------------------------------------------------------------------------
	// array@T#average() {block?}
	class Func_average : public Function {
	private:
		ValueType _valType;
	public:
		Func_average(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("average"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_Map);
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Calculates an average value of elements in the array.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			const ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			size_t cnt = pArrayT->GetCountTotal();
			return ReturnValue(env, arg, Value((cnt == 0)? 0 : pArrayT->Sum() / cnt));
		}
	};
	//-------------------------------------------------------------------------
	// array@T#each() {block?}
	class Func_each : public Function {
	private:
		ValueType _valType;
	public:
		Func_each(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("each"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(VTYPE_iterator, RSLTMODE_Normal, FLAG_None);
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Creates an iterator that iterates each element in the array.\n"
				"\n"
				GURA_HELPTEXT_ITERATOR_en()
				"\n"
				"The block parameter is `|elem:number, idx:number|`\n"
				"where `elem` is the element value.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			const ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			AutoPtr<Iterator> pIterator(new Iterator_ArrayT_Each<T_Elem>(pArrayT->Reference()));
			return ReturnIterator(env, arg, pIterator.release());
		}
	};
	//-------------------------------------------------------------------------
	// array@T#dump():void
	class Func_dump : public Function {
	private:
		ValueType _valType;
	public:
		Func_dump(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("dump"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_None);
			DeclareArg(env, "stream", VTYPE_stream, OCCUR_ZeroOrOnce);
			DeclareAttr(Gura_Symbol(upper));
			AddHelp(
				Gura_Symbol(en),
				"Prints out a binary dump of the array's content.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			const ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			bool upperFlag = arg.IsSet(Gura_Symbol(upper));
			Stream *pStream = arg.IsValid(0)?
				&Object_stream::GetObject(arg, 0)->GetStream() : env.GetConsole();
			pArrayT->Dump(sig, *pStream, upperFlag);
			return Value::Nil;
		}
	};
	//-------------------------------------------------------------------------
	// array@T#fill(value:number):void
	class Func_fill : public Function {
	private:
		ValueType _valType;
	public:
		Func_fill(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("fill"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(VTYPE_any, RSLTMODE_Void, FLAG_Map);
			DeclareArg(env, "value", VTYPE_number, OCCUR_Once);
			AddHelp(
				Gura_Symbol(en),
				"Fills array with a specified value.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			pArrayT->Fill(static_cast<T_Elem>(arg.GetNumber(0)));
			return Value::Nil;
		}
	};
	//-------------------------------------------------------------------------
	// array@T#head(n:number):map {block?}
	class Func_head : public Function {
	private:
		ValueType _valType;
	public:
		Func_head(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("head"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_Map);
			DeclareArg(env, "n", VTYPE_number, OCCUR_Once);
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Creates an array that has extracted specified number of elements\n"
				"from the beginning of the source.\n"
				"\n"
				"If `block` is specified, it would be evaluated with a block parameter\n"
				"`|array:array@T|`, where `array` is the created instance.\n"
				"In this case, the block's result would become the function's returned value.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			const ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			size_t n = arg.GetSizeT(0);
			if (n > pArrayT->GetCountTotal()) {
				sig.SetError(ERR_OutOfRangeError, "offset is out of range");
				return Value::Nil;
			}
			size_t offsetBase = pArrayT->GetOffsetBase();
			AutoPtr<ArrayT<T_Elem> > pArrayTRtn(new ArrayT<T_Elem>(pArrayT->GetMemory().Reference()));
			pArrayTRtn->SetSize1D(n);
			pArrayTRtn->SetOffsetBase(offsetBase);
			Value value(new Object_arrayT<T_Elem>(env, _valType, pArrayTRtn.release()));
			return ReturnValue(env, arg, value);
		}
	};
	//-------------------------------------------------------------------------
	// array@T#offset(n:number):map {block?}
	class Func_offset : public Function {
	private:
		ValueType _valType;
	public:
		Func_offset(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("offset"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_Map);
			DeclareArg(env, "n", VTYPE_number, OCCUR_Once);
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Creates an array that has extracted elements of the source\n"
				"after skipping the first `n` elements.\n"
				"\n"
				"If `block` is specified, it would be evaluated with a block parameter\n"
				"`|array:array@T|`, where `array` is the created instance.\n"
				"In this case, the block's result would become the function's returned value.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			const ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			size_t n = arg.GetSizeT(0);
			if (n > pArrayT->GetCountTotal()) {
				sig.SetError(ERR_OutOfRangeError, "offset is out of range");
				return Value::Nil;
			}
			size_t cnt = pArrayT->GetCountTotal() - n;
			size_t offsetBase = pArrayT->GetOffsetBase() + n;
			AutoPtr<ArrayT<T_Elem> > pArrayTRtn(
				new ArrayT<T_Elem>(pArrayT->GetMemory().Reference()));
			pArrayTRtn->SetSize1D(cnt);
			pArrayTRtn->SetOffsetBase(offsetBase);
			Value value(new Object_arrayT<T_Elem>(env, _valType, pArrayTRtn.release()));
			return ReturnValue(env, arg, value);
		}
	};
	//-------------------------------------------------------------------------
	// array@T.ones(dim+:number):static:map {block?}
	class Func_ones : public Function {
	private:
		ValueType _valType;
	public:
		Func_ones(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("ones"), FUNCTYPE_Class, FLAG_None),
				_valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_Map);
			DeclareArg(env, "dim", VTYPE_number, OCCUR_OnceOrMore);
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Creates an array with the specified dimensions, which elements are initialized by one.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			AutoPtr<ArrayT<T_Elem> > pArrayT(new ArrayT<T_Elem>());
			Array::Dimensions &dims = pArrayT->GetDimensions();
			const ValueList &valList = arg.GetList(0);
			dims.reserve(dims.size());
			foreach_const (ValueList, pValue, valList) {
				dims.push_back(pValue->GetSizeT());
			}
			pArrayT->UpdateMetrics();
			pArrayT->AllocMemory();
			pArrayT->Fill(1);
			Value value(new Object_arrayT<T_Elem>(env, _valType, pArrayT.release()));
			return ReturnValue(env, arg, value);
		}
	};
	//-------------------------------------------------------------------------
	// array@T#paste(offset:number, src:array):map:void
	class Func_paste : public Function {
	private:
		ValueType _valType;
	public:
		Func_paste(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("paste"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(VTYPE_any, RSLTMODE_Normal, FLAG_Map);
			DeclareArg(env, "offset", VTYPE_number, OCCUR_Once);
			DeclareArg(env, "src", valType, OCCUR_Once);
			AddHelp(
				Gura_Symbol(en),
				"Pastes elements of `src` into the target `array` instance.\n"
				"\n"
				"The argument `offset` specifies the posision where elements are pasted in\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			size_t offset = arg.GetSizeT(0);
			const ArrayT<T_Elem> *pArrayTSrc = Object_arrayT<T_Elem>::GetObject(arg, 1)->GetArrayT();
			pArrayT->Paste(sig, offset, pArrayTSrc);
			return Value::Nil;
		}
	};
	//-------------------------------------------------------------------------
	// array@T#sum() {block?}
	class Func_sum : public Function {
	private:
		ValueType _valType;
	public:
		Func_sum(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("sum"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_Map);
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Calculates a summation value of elements in the array.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			const ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			return ReturnValue(env, arg, Value(pArrayT->Sum()));
		}
	};
	//-------------------------------------------------------------------------
	// array@T#tail(n:number):map {block?}
	class Func_tail : public Function {
	private:
		ValueType _valType;
	public:
		Func_tail(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("tail"), FUNCTYPE_Instance, FLAG_None),
				_valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_Map);
			DeclareArg(env, "n", VTYPE_number, OCCUR_Once);
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Creates an array that has extracted specified number of elements\n"
				"from the bottom of the source.\n"
				"\n"
				"If `block` is specified, it would be evaluated with a block parameter\n"
				"`|array:array@T|`, where `array` is the created instance.\n"
				"In this case, the block's result would become the function's returned value.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			const ArrayT<T_Elem> *pArrayT = Object_arrayT<T_Elem>::GetObjectThis(arg)->GetArrayT();
			size_t n = arg.GetSizeT(0);
			if (n > pArrayT->GetCountTotal()) {
				sig.SetError(ERR_OutOfRangeError, "offset is out of range");
				return Value::Nil;
			}
			size_t offsetBase = pArrayT->GetOffsetBase() + pArrayT->GetCountTotal() - n;
			AutoPtr<ArrayT<T_Elem> > pArrayTRtn(
				new ArrayT<T_Elem>(pArrayT->GetMemory().Reference()));
			pArrayTRtn->SetSize1D(n);
			pArrayTRtn->SetOffsetBase(offsetBase);
			Value value(new Object_arrayT<T_Elem>(env, _valType, pArrayTRtn.release()));
			return ReturnValue(env, arg, value);
		}
	};
	//-------------------------------------------------------------------------
	// array@T.zeros(dim+:number):static:map {block?}
	class Func_zeros : public Function {
	private:
		ValueType _valType;
	public:
		Func_zeros(Environment &env, ValueType valType) :
				Function(env, Symbol::Add("zeros"), FUNCTYPE_Class, FLAG_None),
				_valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_Map);
			DeclareArg(env, "dim", VTYPE_number, OCCUR_OnceOrMore);
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Creates an array with the specified dimensions, which elements are initialized by zero.\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			AutoPtr<ArrayT<T_Elem> > pArrayT(new ArrayT<T_Elem>());
			Array::Dimensions &dims = pArrayT->GetDimensions();
			const ValueList &valList = arg.GetList(0);
			dims.reserve(dims.size());
			foreach_const (ValueList, pValue, valList) {
				dims.push_back(pValue->GetSizeT());
			}
			pArrayT->UpdateMetrics();
			pArrayT->AllocMemory();
			pArrayT->FillZero();
			Value value(new Object_arrayT<T_Elem>(env, _valType, pArrayT.release()));
			return ReturnValue(env, arg, value);
		}
	};
private:
	String _elemName;
public:
	inline Class_arrayT(Environment *pEnvOuter, ValueType valType, const String &elemName) :
							Class(pEnvOuter, valType), _elemName(elemName) {}
	virtual void Prepare(Environment &env);
	virtual bool CastFrom(Environment &env, Value &value, const Declaration *pDecl);
	virtual bool CastTo(Environment &env, Value &value, const Declaration &decl);
};

}

#endif
