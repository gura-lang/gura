//=============================================================================
// Gura class: arrayT
//=============================================================================
#ifndef __GURA_CLASS_ARRAYT_H__
#define __GURA_CLASS_ARRAYT_H__

#include "Class.h"
#include "ArrayT.h"

namespace Gura {

//-----------------------------------------------------------------------------
// Object_arrayT
//-----------------------------------------------------------------------------
template<typename T_Elem>
class Object_arrayT : public Object {
public:
	Gura_DeclareObjectAccessor(arrayT)
private:
	AutoPtr<ArrayT<T_Elem> > _pArrayT;
public:
	inline Object_arrayT(Environment &env, ValueType valType, ArrayT<T_Elem> *pArrayT) :
				Object(env.LookupClass(valType)), _pArrayT(pArrayT) {}
	inline Object_arrayT(Class *pClass, ArrayT<T_Elem> *pArrayT) :
				Object(pClass), _pArrayT(pArrayT) {}
	inline ArrayT<T_Elem> *GetArrayT() { return _pArrayT.get(); }
	inline const ArrayT<T_Elem> *GetArrayT() const { return _pArrayT.get(); }
	virtual Object *Clone() const;
	virtual String ToString(bool exprFlag);
	virtual Value IndexGet(Environment &env, const Value &valueIdx);
	virtual void IndexSet(Environment &env, const Value &valueIdx, const Value &value);
};

//-----------------------------------------------------------------------------
// Class_arrayT
//-----------------------------------------------------------------------------
template<typename T_Elem>
class Class_arrayT : public Class {
public:
#if 0
	//-------------------------------------------------------------------------
	// array@T(src) {block?}
	class Func_Constructor : public Function {
	private:
		ValueType _valType;
	public:
		Func_Constructor(Environment &env, const Symbol *pSymbol, ValueType valType) :
				Function(env, pSymbol, FUNCTYPE_Function, FLAG_None), _valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_None);
			DeclareArg(env, "src", VTYPE_any, OCCUR_Once);
			SetClassToConstruct(env.LookupClass(valType));
			DeclareBlock(OCCUR_ZeroOrOnce);
			AddHelp(
				Gura_Symbol(en),
				"Creates an `array@T` instance.\n"
				"You can call this function in the following formats:\n"
				"\n"
				"- `array@T(list:list)` .. Creates an `array@T` instance initialized with\n"
				"  numbers contained in the `list`.\n"
				"- `array@T(iter:iterator)` .. Creates an `array@T` instance initialized with\n"
				"  numbers generated by the `iterator`.\n"
				"\n"
				GURA_HELPTEXT_BLOCK_en("array", "array@T")
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			AutoPtr<ArrayT<T_Elem> > pArrayT;
			if (arg.Is_list(0)) {
				const ValueList &valList = arg.GetList(0);
				pArrayT.reset(ArrayT<T_Elem>::CreateFromList(sig, valList));
				if (pArrayT.IsNull()) return Value::Nil;
			} else if (arg.Is_iterator(0)) {
				Iterator *pIterator = arg.GetIterator(0);
				if (pIterator->IsInfinite()) {
					Iterator::SetError_InfiniteNotAllowed(sig);
					return false;
				}
				pArrayT.reset(ArrayT<T_Elem>::CreateFromIterator(env, pIterator));
				if (pArrayT.IsNull()) return false;
			} else {
				Declaration::SetError_InvalidArgument(env);
				return Value::Nil;
			}
			Value value(new Object_arrayT<T_Elem>(env, _valType, pArrayT.release()));
			return ReturnValue(env, arg, value);
		}
	};
	//-------------------------------------------------------------------------
	// @T() {block}
	class Func_Initializer : public Function {
	private:
		ValueType _valType;
	public:
		Func_Initializer(Environment &env, const Symbol *pSymbol, ValueType valType) :
				Function(env, pSymbol, FUNCTYPE_Function, FLAG_None), _valType(valType) {
			SetFuncAttr(valType, RSLTMODE_Normal, FLAG_None);
			DeclareBlock(OCCUR_Once);
			AddHelp(
				Gura_Symbol(en),
				"Creates an `array@T` instance that is initialized with values described in `block`.\n"
				"\n"
				"The code below creates an `array@uchar` instance that has four elements.\n"
				"\n"
				"    @uchar { 0x01, 0x23, 0x45, 0x67 }\n"
				"\n"
				"The code below creates an `array@ushort` instance that has three elements.\n"
				"\n"
				"    @ushort { 0x0123, 0x4567, 0x89ab }\n"
			);
		}
		virtual Value DoEval(Environment &env, Argument &arg) const {
			Signal &sig = env.GetSignal();
			const Expr_Block *pExprBlock = arg.GetBlockCooked(env);
			const ExprOwner &exprOwner = pExprBlock->GetExprOwner();
			AutoPtr<ArrayT<T_Elem> > pArrayT(new ArrayT<T_Elem>(exprOwner.size()));
			T_Elem *p = pArrayT->GetPointer();
			foreach_const (ExprOwner, ppExpr, exprOwner) {
				const Expr *pExpr = *ppExpr;
				if (pExpr->IsBlock()) {
					sig.SetError(ERR_ValueError, "invalid element for array initialization");
					return Value::Nil;
				}
				Value value = pExpr->Exec(env);
				if (!value.Is_number() && !value.Is_boolean()) {
					sig.SetError(ERR_ValueError, "invalid element for array initialization");
					return Value::Nil;
				}
				*p++ = static_cast<T_Elem>(value.GetNumber());
			}
			return Value(new Object_arrayT<T_Elem>(env, _valType, pArrayT.release()));
		}
	};
#endif
private:
	String _elemName;
public:
	Class_arrayT(Environment *pEnvOuter, ValueType valType, const String &elemName);
	virtual void Prepare(Environment &env);
	virtual bool CastFrom(Environment &env, Value &value, const Declaration *pDecl);
	virtual bool CastTo(Environment &env, Value &value, const Declaration &decl);
};

}

#endif
